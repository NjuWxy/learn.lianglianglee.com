# TCP 流量控制
内核中每一个socket连接都有发送端缓存和接收端缓存。
应用数据写到内核的socket发送端缓存，然后才会被发送到网络；
接收端应用程序从内存的socket接收端缓存读取数据到用户态的缓存。
当使用TCP协议进行连接时，socket连接就是一个TCP连接。
TCP使用滑动窗口来做流量控制。
TCP 头里有一个字段叫window，也就是窗口大小，这个字段是接收端告诉发送端自己还有多少socket缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。
在发送端，滑动窗口是socket发送缓冲区上一块可以“滑动” 的窗口。socket发送缓冲区大小往往是固定的，提前设定好的，而滑动窗口大小根据接收端处理能力来定，是动态变化的。
收到ack的数据会被从socket发送端缓存移除，滑动窗口会移动

# Netty 背压
当接收端数据处理不过来，若一直发送数据，会导致接收端OOM。
接收端可以在压力大的时候设置channel的auto read为false，就是不读channel的数据，这样滑动窗口大小慢慢会变为0，发送端的socket发送缓冲区会被逐渐写满，Netty的缓冲区ChannelOutboundBuffer无法flush进
socket发送缓冲区(write的数据没有直接写在Socket中，
而是写在了ChannelOutboundBuffer缓存中,
[HeadContext # write和AbstractChannel和# AbstractUnsafe # write和addMessage](https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Netty%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e5%89%96%e6%9e%90%e4%b8%8e%20RPC%20%e5%ae%9e%e8%b7%b5-%e5%ae%8c/09%20%20%e6%95%b0%e6%8d%ae%e4%bc%a0%e8%be%93%ef%bc%9awriteAndFlush%20%e5%a4%84%e7%90%86%e6%b5%81%e7%a8%8b%e5%89%96%e6%9e%90.md)，
当调用flush()方法时，会把数据写入Socket中并向网络中发送)，若数据刷不进socket发送缓冲区，那么ChannelOutboundBuffer会越来越大，
ChannelOutboundBuffer里有一个字段totalPendingSize来记录该channel未刷出去的总大小，当超过 channel.config().getWriteBufferHighWaterMark()，ChannelOutboundBuffer里的unwritable标记会被设为true。
同理当flush进socket缓冲区，totalPendingSize会减小，当小于channel.config().getWriteBufferLowWaterMark()时，ChannelOutboundBuffer里的unwritable标记会被设为false
并且触发一个ChannelWritabilityChanged事件，即ChannelInboundHandler里的channelWritabilityChanged会被调用，应用程序可以在这里选择停止写或继续写。

# Flink 背压
Flink在接收数据时，会先把数据从socket缓冲区读到LocalBufferPool缓冲池。
若LocalBufferPool缓冲池申请的数量已经达到上限或NetworkBufferPool中的内存已经被用尽，那么当前Task的Netty Channel暂停读取数据。此时数据积压在TCP缓冲区中，导致其TCP窗口的大小变成零,其上游发送端ChannelOutboundBuffer会超过highwatermark,
Flink在发送数据时，若发现Channel.isWritable()为false，则不会从发送队列中poll出需要发送的数据，从而形成背压。
当Netty输出缓冲区的字节数降到低水位值以下时，Channel.isWritable()返回true，同时channelWritabilityChanged()方法被触发，Flink在channelWritabilityChanged事件中调用发送方法，这样可以继续发送数据。

# Celeborn 背压
Celeborn 没有利用channelWritabilityChanged事件，二是直接控制每个worker的inFlightReqs数量来限流。
当接收端停止读数据时，发送端的现象是sleep等待inFlightReqs<maxInFlightReqs，所以也不会无限制地往ChannelOutboundBuffer里写。
如果接收端一直不读数据，那么push data请求会超时。
